function e(e2) {
  return Array.isArray ? Array.isArray(e2) : d(e2) === `[object Array]`;
}
const t = 1 / 0;
function n(e2) {
  if (typeof e2 == `string`) return e2;
  let n2 = e2 + ``;
  return n2 == `0` && 1 / e2 == -t ? `-0` : n2;
}
function r(e2) {
  return e2 == null ? `` : n(e2);
}
function i(e2) {
  return typeof e2 == `string`;
}
function a(e2) {
  return typeof e2 == `number`;
}
function o(e2) {
  return e2 === true || e2 === false || c(e2) && d(e2) == `[object Boolean]`;
}
function s(e2) {
  return typeof e2 == `object`;
}
function c(e2) {
  return s(e2) && e2 !== null;
}
function l(e2) {
  return e2 != null;
}
function u(e2) {
  return !e2.trim().length;
}
function d(e2) {
  return e2 == null ? e2 === void 0 ? `[object Undefined]` : `[object Null]` : Object.prototype.toString.call(e2);
}
const f = `Incorrect 'index' type`, p = (e2) => `Invalid value for key ${e2}`, m = (e2) => `Pattern length exceeds max of ${e2}.`, h = (e2) => `Missing ${e2} property in key`, g = (e2) => `Property 'weight' in key '${e2}' must be a positive integer`, _ = Object.prototype.hasOwnProperty;
var v = class {
  constructor(e2) {
    this._keys = [], this._keyMap = {};
    let t2 = 0;
    e2.forEach((e3) => {
      let n2 = y(e3);
      this._keys.push(n2), this._keyMap[n2.id] = n2, t2 += n2.weight;
    }), this._keys.forEach((e3) => {
      e3.weight /= t2;
    });
  }
  get(e2) {
    return this._keyMap[e2];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function y(t2) {
  let n2 = null, r2 = null, a2 = null, o2 = 1, s2 = null;
  if (i(t2) || e(t2)) a2 = t2, n2 = b(t2), r2 = x(t2);
  else {
    if (!_.call(t2, `name`)) throw Error(h(`name`));
    let e2 = t2.name;
    if (a2 = e2, _.call(t2, `weight`) && (o2 = t2.weight, o2 <= 0)) throw Error(g(e2));
    n2 = b(e2), r2 = x(e2), s2 = t2.getFn;
  }
  return { path: n2, id: r2, weight: o2, src: a2, getFn: s2 };
}
function b(t2) {
  return e(t2) ? t2 : t2.split(`.`);
}
function x(t2) {
  return e(t2) ? t2.join(`.`) : t2;
}
function S(t2, n2) {
  let s2 = [], c2 = false, u2 = (t3, n3, d2) => {
    if (l(t3)) if (!n3[d2]) s2.push(t3);
    else {
      let f2 = n3[d2], p2 = t3[f2];
      if (!l(p2)) return;
      if (d2 === n3.length - 1 && (i(p2) || a(p2) || o(p2))) s2.push(r(p2));
      else if (e(p2)) {
        c2 = true;
        for (let e2 = 0, t4 = p2.length; e2 < t4; e2 += 1) u2(p2[e2], n3, d2 + 1);
      } else n3.length && u2(p2, n3, d2 + 1);
    }
  };
  return u2(t2, i(n2) ? n2.split(`.`) : n2, 0), c2 ? s2 : s2[0];
}
const C = { includeMatches: false, findAllMatches: false, minMatchCharLength: 1 }, w = { isCaseSensitive: false, ignoreDiacritics: false, includeScore: false, keys: [], shouldSort: true, sortFn: (e2, t2) => e2.score === t2.score ? e2.idx < t2.idx ? -1 : 1 : e2.score < t2.score ? -1 : 1 }, ee = { location: 0, threshold: 0.6, distance: 100 }, te = { useExtendedSearch: false, getFn: S, ignoreLocation: false, ignoreFieldNorm: false, fieldNormWeight: 1 };
var T = { ...w, ...C, ...ee, ...te };
const E = /[^ ]+/g;
function ne(e2 = 1, t2 = 3) {
  let n2 = /* @__PURE__ */ new Map(), r2 = 10 ** t2;
  return { get(t3) {
    let i2 = t3.match(E).length;
    if (n2.has(i2)) return n2.get(i2);
    let a2 = 1 / i2 ** (0.5 * e2), o2 = parseFloat(Math.round(a2 * r2) / r2);
    return n2.set(i2, o2), o2;
  }, clear() {
    n2.clear();
  } };
}
var D = class {
  constructor({ getFn: e2 = T.getFn, fieldNormWeight: t2 = T.fieldNormWeight } = {}) {
    this.norm = ne(t2, 3), this.getFn = e2, this.isCreated = false, this.setIndexRecords();
  }
  setSources(e2 = []) {
    this.docs = e2;
  }
  setIndexRecords(e2 = []) {
    this.records = e2;
  }
  setKeys(e2 = []) {
    this.keys = e2, this._keysMap = {}, e2.forEach((e3, t2) => {
      this._keysMap[e3.id] = t2;
    });
  }
  create() {
    this.isCreated || !this.docs.length || (this.isCreated = true, i(this.docs[0]) ? this.docs.forEach((e2, t2) => {
      this._addString(e2, t2);
    }) : this.docs.forEach((e2, t2) => {
      this._addObject(e2, t2);
    }), this.norm.clear());
  }
  add(e2) {
    let t2 = this.size();
    i(e2) ? this._addString(e2, t2) : this._addObject(e2, t2);
  }
  removeAt(e2) {
    this.records.splice(e2, 1);
    for (let t2 = e2, n2 = this.size(); t2 < n2; t2 += 1) --this.records[t2].i;
  }
  getValueForItemAtKeyId(e2, t2) {
    return e2[this._keysMap[t2]];
  }
  size() {
    return this.records.length;
  }
  _addString(e2, t2) {
    if (!l(e2) || u(e2)) return;
    let n2 = { v: e2, i: t2, n: this.norm.get(e2) };
    this.records.push(n2);
  }
  _addObject(t2, n2) {
    let r2 = { i: n2, $: {} };
    this.keys.forEach((n3, a2) => {
      let o2 = n3.getFn ? n3.getFn(t2) : this.getFn(t2, n3.path);
      if (l(o2)) {
        if (e(o2)) {
          let t3 = [], n4 = [{ nestedArrIndex: -1, value: o2 }];
          for (; n4.length; ) {
            let { nestedArrIndex: r3, value: a3 } = n4.pop();
            if (l(a3)) if (i(a3) && !u(a3)) {
              let e2 = { v: a3, i: r3, n: this.norm.get(a3) };
              t3.push(e2);
            } else e(a3) && a3.forEach((e2, t4) => {
              n4.push({ nestedArrIndex: t4, value: e2 });
            });
          }
          r2.$[a2] = t3;
        } else if (i(o2) && !u(o2)) {
          let e2 = { v: o2, n: this.norm.get(o2) };
          r2.$[a2] = e2;
        }
      }
    }), this.records.push(r2);
  }
  toJSON() {
    return { keys: this.keys, records: this.records };
  }
};
function O(e2, t2, { getFn: n2 = T.getFn, fieldNormWeight: r2 = T.fieldNormWeight } = {}) {
  let i2 = new D({ getFn: n2, fieldNormWeight: r2 });
  return i2.setKeys(e2.map(y)), i2.setSources(t2), i2.create(), i2;
}
function re(e2, { getFn: t2 = T.getFn, fieldNormWeight: n2 = T.fieldNormWeight } = {}) {
  let { keys: r2, records: i2 } = e2, a2 = new D({ getFn: t2, fieldNormWeight: n2 });
  return a2.setKeys(r2), a2.setIndexRecords(i2), a2;
}
function k(e2, { errors: t2 = 0, currentLocation: n2 = 0, expectedLocation: r2 = 0, distance: i2 = T.distance, ignoreLocation: a2 = T.ignoreLocation } = {}) {
  let o2 = t2 / e2.length;
  if (a2) return o2;
  let s2 = Math.abs(r2 - n2);
  return i2 ? o2 + s2 / i2 : s2 ? 1 : o2;
}
function A(e2 = [], t2 = T.minMatchCharLength) {
  let n2 = [], r2 = -1, i2 = -1, a2 = 0;
  for (let o2 = e2.length; a2 < o2; a2 += 1) {
    let o3 = e2[a2];
    o3 && r2 === -1 ? r2 = a2 : !o3 && r2 !== -1 && (i2 = a2 - 1, i2 - r2 + 1 >= t2 && n2.push([r2, i2]), r2 = -1);
  }
  return e2[a2 - 1] && a2 - r2 >= t2 && n2.push([r2, a2 - 1]), n2;
}
const j = 32;
function M(e2, t2, n2, { location: r2 = T.location, distance: i2 = T.distance, threshold: a2 = T.threshold, findAllMatches: o2 = T.findAllMatches, minMatchCharLength: s2 = T.minMatchCharLength, includeMatches: c2 = T.includeMatches, ignoreLocation: l2 = T.ignoreLocation } = {}) {
  if (t2.length > j) throw Error(m(j));
  let u2 = t2.length, d2 = e2.length, f2 = Math.max(0, Math.min(r2, d2)), p2 = a2, h2 = f2, g2 = s2 > 1 || c2, _2 = g2 ? Array(d2) : [], v2;
  for (; (v2 = e2.indexOf(t2, h2)) > -1; ) {
    let e3 = k(t2, { currentLocation: v2, expectedLocation: f2, distance: i2, ignoreLocation: l2 });
    if (p2 = Math.min(e3, p2), h2 = v2 + u2, g2) {
      let e4 = 0;
      for (; e4 < u2; ) _2[v2 + e4] = 1, e4 += 1;
    }
  }
  h2 = -1;
  let y2 = [], b2 = 1, x2 = u2 + d2, S2 = 1 << u2 - 1;
  for (let r3 = 0; r3 < u2; r3 += 1) {
    let a3 = 0, s3 = x2;
    for (; a3 < s3; ) {
      let e3 = k(t2, { errors: r3, currentLocation: f2 + s3, expectedLocation: f2, distance: i2, ignoreLocation: l2 });
      e3 <= p2 ? a3 = s3 : x2 = s3, s3 = Math.floor((x2 - a3) / 2 + a3);
    }
    x2 = s3;
    let c3 = Math.max(1, f2 - s3 + 1), m2 = o2 ? d2 : Math.min(f2 + s3, d2) + u2, v3 = Array(m2 + 2);
    v3[m2 + 1] = (1 << r3) - 1;
    for (let a4 = m2; a4 >= c3; --a4) {
      let o3 = a4 - 1, s4 = n2[e2.charAt(o3)];
      if (g2 && (_2[o3] = +!!s4), v3[a4] = (v3[a4 + 1] << 1 | 1) & s4, r3 && (v3[a4] |= (y2[a4 + 1] | y2[a4]) << 1 | 1 | y2[a4 + 1]), v3[a4] & S2 && (b2 = k(t2, { errors: r3, currentLocation: o3, expectedLocation: f2, distance: i2, ignoreLocation: l2 }), b2 <= p2)) {
        if (p2 = b2, h2 = o3, h2 <= f2) break;
        c3 = Math.max(1, 2 * f2 - h2);
      }
    }
    let C3 = k(t2, { errors: r3 + 1, currentLocation: f2, expectedLocation: f2, distance: i2, ignoreLocation: l2 });
    if (C3 > p2) break;
    y2 = v3;
  }
  let C2 = { isMatch: h2 >= 0, score: Math.max(1e-3, b2) };
  if (g2) {
    let e3 = A(_2, s2);
    e3.length ? c2 && (C2.indices = e3) : C2.isMatch = false;
  }
  return C2;
}
function ie(e2) {
  let t2 = {};
  for (let n2 = 0, r2 = e2.length; n2 < r2; n2 += 1) {
    let i2 = e2.charAt(n2);
    t2[i2] = (t2[i2] || 0) | 1 << r2 - n2 - 1;
  }
  return t2;
}
const N = String.prototype.normalize ? (e2) => e2.normalize(`NFD`).replace(/[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/g, ``) : (e2) => e2;
var P = class {
  constructor(e2, { location: t2 = T.location, threshold: n2 = T.threshold, distance: r2 = T.distance, includeMatches: i2 = T.includeMatches, findAllMatches: a2 = T.findAllMatches, minMatchCharLength: o2 = T.minMatchCharLength, isCaseSensitive: s2 = T.isCaseSensitive, ignoreDiacritics: c2 = T.ignoreDiacritics, ignoreLocation: l2 = T.ignoreLocation } = {}) {
    if (this.options = { location: t2, threshold: n2, distance: r2, includeMatches: i2, findAllMatches: a2, minMatchCharLength: o2, isCaseSensitive: s2, ignoreDiacritics: c2, ignoreLocation: l2 }, e2 = s2 ? e2 : e2.toLowerCase(), e2 = c2 ? N(e2) : e2, this.pattern = e2, this.chunks = [], !this.pattern.length) return;
    let u2 = (e3, t3) => {
      this.chunks.push({ pattern: e3, alphabet: ie(e3), startIndex: t3 });
    }, d2 = this.pattern.length;
    if (d2 > j) {
      let e3 = 0, t3 = d2 % j, n3 = d2 - t3;
      for (; e3 < n3; ) u2(this.pattern.substr(e3, j), e3), e3 += j;
      if (t3) {
        let e4 = d2 - j;
        u2(this.pattern.substr(e4), e4);
      }
    } else u2(this.pattern, 0);
  }
  searchIn(e2) {
    let { isCaseSensitive: t2, ignoreDiacritics: n2, includeMatches: r2 } = this.options;
    if (e2 = t2 ? e2 : e2.toLowerCase(), e2 = n2 ? N(e2) : e2, this.pattern === e2) {
      let t3 = { isMatch: true, score: 0 };
      return r2 && (t3.indices = [[0, e2.length - 1]]), t3;
    }
    let { location: i2, distance: a2, threshold: o2, findAllMatches: s2, minMatchCharLength: c2, ignoreLocation: l2 } = this.options, u2 = [], d2 = 0, f2 = false;
    this.chunks.forEach(({ pattern: t3, alphabet: n3, startIndex: p3 }) => {
      let { isMatch: m2, score: h2, indices: g2 } = M(e2, t3, n3, { location: i2 + p3, distance: a2, threshold: o2, findAllMatches: s2, minMatchCharLength: c2, includeMatches: r2, ignoreLocation: l2 });
      m2 && (f2 = true), d2 += h2, m2 && g2 && (u2 = [...u2, ...g2]);
    });
    let p2 = { isMatch: f2, score: f2 ? d2 / this.chunks.length : 1 };
    return f2 && r2 && (p2.indices = u2), p2;
  }
}, F = class {
  constructor(e2) {
    this.pattern = e2;
  }
  static isMultiMatch(e2) {
    return I(e2, this.multiRegex);
  }
  static isSingleMatch(e2) {
    return I(e2, this.singleRegex);
  }
  search() {
  }
};
function I(e2, t2) {
  let n2 = e2.match(t2);
  return n2 ? n2[1] : null;
}
var ae = class extends F {
  constructor(e2) {
    super(e2);
  }
  static get type() {
    return `exact`;
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(e2) {
    let t2 = e2 === this.pattern;
    return { isMatch: t2, score: t2 ? 0 : 1, indices: [0, this.pattern.length - 1] };
  }
}, oe = class extends F {
  constructor(e2) {
    super(e2);
  }
  static get type() {
    return `inverse-exact`;
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(e2) {
    let t2 = e2.indexOf(this.pattern), n2 = t2 === -1;
    return { isMatch: n2, score: n2 ? 0 : 1, indices: [0, e2.length - 1] };
  }
}, se = class extends F {
  constructor(e2) {
    super(e2);
  }
  static get type() {
    return `prefix-exact`;
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(e2) {
    let t2 = e2.startsWith(this.pattern);
    return { isMatch: t2, score: t2 ? 0 : 1, indices: [0, this.pattern.length - 1] };
  }
}, ce = class extends F {
  constructor(e2) {
    super(e2);
  }
  static get type() {
    return `inverse-prefix-exact`;
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(e2) {
    let t2 = !e2.startsWith(this.pattern);
    return { isMatch: t2, score: t2 ? 0 : 1, indices: [0, e2.length - 1] };
  }
}, L = class extends F {
  constructor(e2) {
    super(e2);
  }
  static get type() {
    return `suffix-exact`;
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(e2) {
    let t2 = e2.endsWith(this.pattern);
    return { isMatch: t2, score: t2 ? 0 : 1, indices: [e2.length - this.pattern.length, e2.length - 1] };
  }
}, R = class extends F {
  constructor(e2) {
    super(e2);
  }
  static get type() {
    return `inverse-suffix-exact`;
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(e2) {
    let t2 = !e2.endsWith(this.pattern);
    return { isMatch: t2, score: t2 ? 0 : 1, indices: [0, e2.length - 1] };
  }
}, z = class extends F {
  constructor(e2, { location: t2 = T.location, threshold: n2 = T.threshold, distance: r2 = T.distance, includeMatches: i2 = T.includeMatches, findAllMatches: a2 = T.findAllMatches, minMatchCharLength: o2 = T.minMatchCharLength, isCaseSensitive: s2 = T.isCaseSensitive, ignoreDiacritics: c2 = T.ignoreDiacritics, ignoreLocation: l2 = T.ignoreLocation } = {}) {
    super(e2), this._bitapSearch = new P(e2, { location: t2, threshold: n2, distance: r2, includeMatches: i2, findAllMatches: a2, minMatchCharLength: o2, isCaseSensitive: s2, ignoreDiacritics: c2, ignoreLocation: l2 });
  }
  static get type() {
    return `fuzzy`;
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(e2) {
    return this._bitapSearch.searchIn(e2);
  }
}, B = class extends F {
  constructor(e2) {
    super(e2);
  }
  static get type() {
    return `include`;
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(e2) {
    let t2 = 0, n2, r2 = [], i2 = this.pattern.length;
    for (; (n2 = e2.indexOf(this.pattern, t2)) > -1; ) t2 = n2 + i2, r2.push([n2, t2 - 1]);
    let a2 = !!r2.length;
    return { isMatch: a2, score: a2 ? 0 : 1, indices: r2 };
  }
};
const V = [ae, B, se, ce, R, L, oe, z], H = V.length, U = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/, W = `|`;
function le(e2, t2 = {}) {
  return e2.split(W).map((e3) => {
    let n2 = e3.trim().split(U).filter((e4) => e4 && !!e4.trim()), r2 = [];
    for (let e4 = 0, i2 = n2.length; e4 < i2; e4 += 1) {
      let i3 = n2[e4], a2 = false, o2 = -1;
      for (; !a2 && ++o2 < H; ) {
        let e5 = V[o2], n3 = e5.isMultiMatch(i3);
        n3 && (r2.push(new e5(n3, t2)), a2 = true);
      }
      if (!a2) for (o2 = -1; ++o2 < H; ) {
        let e5 = V[o2], n3 = e5.isSingleMatch(i3);
        if (n3) {
          r2.push(new e5(n3, t2));
          break;
        }
      }
    }
    return r2;
  });
}
const ue = /* @__PURE__ */ new Set([z.type, B.type]);
var de = class {
  constructor(e2, { isCaseSensitive: t2 = T.isCaseSensitive, ignoreDiacritics: n2 = T.ignoreDiacritics, includeMatches: r2 = T.includeMatches, minMatchCharLength: i2 = T.minMatchCharLength, ignoreLocation: a2 = T.ignoreLocation, findAllMatches: o2 = T.findAllMatches, location: s2 = T.location, threshold: c2 = T.threshold, distance: l2 = T.distance } = {}) {
    this.query = null, this.options = { isCaseSensitive: t2, ignoreDiacritics: n2, includeMatches: r2, minMatchCharLength: i2, findAllMatches: o2, ignoreLocation: a2, location: s2, threshold: c2, distance: l2 }, e2 = t2 ? e2 : e2.toLowerCase(), e2 = n2 ? N(e2) : e2, this.pattern = e2, this.query = le(this.pattern, this.options);
  }
  static condition(e2, t2) {
    return t2.useExtendedSearch;
  }
  searchIn(e2) {
    let t2 = this.query;
    if (!t2) return { isMatch: false, score: 1 };
    let { includeMatches: n2, isCaseSensitive: r2, ignoreDiacritics: i2 } = this.options;
    e2 = r2 ? e2 : e2.toLowerCase(), e2 = i2 ? N(e2) : e2;
    let a2 = 0, o2 = [], s2 = 0;
    for (let r3 = 0, i3 = t2.length; r3 < i3; r3 += 1) {
      let i4 = t2[r3];
      o2.length = 0, a2 = 0;
      for (let t3 = 0, r4 = i4.length; t3 < r4; t3 += 1) {
        let r5 = i4[t3], { isMatch: c2, indices: l2, score: u2 } = r5.search(e2);
        if (c2) {
          if (a2 += 1, s2 += u2, n2) {
            let e3 = r5.constructor.type;
            ue.has(e3) ? o2 = [...o2, ...l2] : o2.push(l2);
          }
        } else {
          s2 = 0, a2 = 0, o2.length = 0;
          break;
        }
      }
      if (a2) {
        let e3 = { isMatch: true, score: s2 / a2 };
        return n2 && (e3.indices = o2), e3;
      }
    }
    return { isMatch: false, score: 1 };
  }
};
const G = [];
function fe(...e2) {
  G.push(...e2);
}
function K(e2, t2) {
  for (let n2 = 0, r2 = G.length; n2 < r2; n2 += 1) {
    let r3 = G[n2];
    if (r3.condition(e2, t2)) return new r3(e2, t2);
  }
  return new P(e2, t2);
}
const q = { AND: `$and`, OR: `$or` }, J = { PATH: `$path`, PATTERN: `$val` }, Y = (e2) => !!(e2[q.AND] || e2[q.OR]), pe = (e2) => !!e2[J.PATH], me = (t2) => !e(t2) && s(t2) && !Y(t2), X = (e2) => ({ [q.AND]: Object.keys(e2).map((t2) => ({ [t2]: e2[t2] })) });
function Z(t2, n2, { auto: r2 = true } = {}) {
  let a2 = (t3) => {
    let o2 = Object.keys(t3), s2 = pe(t3);
    if (!s2 && o2.length > 1 && !Y(t3)) return a2(X(t3));
    if (me(t3)) {
      let e2 = s2 ? t3[J.PATH] : o2[0], a3 = s2 ? t3[J.PATTERN] : t3[e2];
      if (!i(a3)) throw Error(p(e2));
      let c3 = { keyId: x(e2), pattern: a3 };
      return r2 && (c3.searcher = K(a3, n2)), c3;
    }
    let c2 = { children: [], operator: o2[0] };
    return o2.forEach((n3) => {
      let r3 = t3[n3];
      e(r3) && r3.forEach((e2) => {
        c2.children.push(a2(e2));
      });
    }), c2;
  };
  return Y(t2) || (t2 = X(t2)), a2(t2);
}
function Q(e2, { ignoreFieldNorm: t2 = T.ignoreFieldNorm }) {
  e2.forEach((e3) => {
    let n2 = 1;
    e3.matches.forEach(({ key: e4, norm: r2, score: i2 }) => {
      let a2 = e4 ? e4.weight : null;
      n2 *= (i2 === 0 && a2 ? 2 ** -52 : i2) ** +((a2 || 1) * (t2 ? 1 : r2));
    }), e3.score = n2;
  });
}
function he(e2, t2) {
  let n2 = e2.matches;
  t2.matches = [], l(n2) && n2.forEach((e3) => {
    if (!l(e3.indices) || !e3.indices.length) return;
    let { indices: n3, value: r2 } = e3, i2 = { indices: n3, value: r2 };
    e3.key && (i2.key = e3.key.src), e3.idx > -1 && (i2.refIndex = e3.idx), t2.matches.push(i2);
  });
}
function ge(e2, t2) {
  t2.score = e2.score;
}
function _e(e2, t2, { includeMatches: n2 = T.includeMatches, includeScore: r2 = T.includeScore } = {}) {
  let i2 = [];
  return n2 && i2.push(he), r2 && i2.push(ge), e2.map((e3) => {
    let { idx: n3 } = e3, r3 = { item: t2[n3], refIndex: n3 };
    return i2.length && i2.forEach((t3) => {
      t3(e3, r3);
    }), r3;
  });
}
var $ = class {
  constructor(e2, t2 = {}, n2) {
    this.options = { ...T, ...t2 }, this.options.useExtendedSearch, this._keyStore = new v(this.options.keys), this.setCollection(e2, n2);
  }
  setCollection(e2, t2) {
    if (this._docs = e2, t2 && !(t2 instanceof D)) throw Error(f);
    this._myIndex = t2 || O(this.options.keys, this._docs, { getFn: this.options.getFn, fieldNormWeight: this.options.fieldNormWeight });
  }
  add(e2) {
    l(e2) && (this._docs.push(e2), this._myIndex.add(e2));
  }
  remove(e2 = () => false) {
    let t2 = [];
    for (let n2 = 0, r2 = this._docs.length; n2 < r2; n2 += 1) {
      let i2 = this._docs[n2];
      e2(i2, n2) && (this.removeAt(n2), --n2, --r2, t2.push(i2));
    }
    return t2;
  }
  removeAt(e2) {
    this._docs.splice(e2, 1), this._myIndex.removeAt(e2);
  }
  getIndex() {
    return this._myIndex;
  }
  search(e2, { limit: t2 = -1 } = {}) {
    let { includeMatches: n2, includeScore: r2, shouldSort: o2, sortFn: s2, ignoreFieldNorm: c2 } = this.options, l2 = i(e2) ? i(this._docs[0]) ? this._searchStringList(e2) : this._searchObjectList(e2) : this._searchLogical(e2);
    return Q(l2, { ignoreFieldNorm: c2 }), o2 && l2.sort(s2), a(t2) && t2 > -1 && (l2 = l2.slice(0, t2)), _e(l2, this._docs, { includeMatches: n2, includeScore: r2 });
  }
  _searchStringList(e2) {
    let t2 = K(e2, this.options), { records: n2 } = this._myIndex, r2 = [];
    return n2.forEach(({ v: e3, i: n3, n: i2 }) => {
      if (!l(e3)) return;
      let { isMatch: a2, score: o2, indices: s2 } = t2.searchIn(e3);
      a2 && r2.push({ item: e3, idx: n3, matches: [{ score: o2, value: e3, norm: i2, indices: s2 }] });
    }), r2;
  }
  _searchLogical(e2) {
    let t2 = Z(e2, this.options), n2 = (e3, t3, r3) => {
      if (!e3.children) {
        let { keyId: n3, searcher: i4 } = e3, a3 = this._findMatches({ key: this._keyStore.get(n3), value: this._myIndex.getValueForItemAtKeyId(t3, n3), searcher: i4 });
        return a3 && a3.length ? [{ idx: r3, item: t3, matches: a3 }] : [];
      }
      let i3 = [];
      for (let a3 = 0, o2 = e3.children.length; a3 < o2; a3 += 1) {
        let o3 = e3.children[a3], s2 = n2(o3, t3, r3);
        if (s2.length) i3.push(...s2);
        else if (e3.operator === q.AND) return [];
      }
      return i3;
    }, r2 = this._myIndex.records, i2 = {}, a2 = [];
    return r2.forEach(({ $: e3, i: r3 }) => {
      if (l(e3)) {
        let o2 = n2(t2, e3, r3);
        o2.length && (i2[r3] || (i2[r3] = { idx: r3, item: e3, matches: [] }, a2.push(i2[r3])), o2.forEach(({ matches: e4 }) => {
          i2[r3].matches.push(...e4);
        }));
      }
    }), a2;
  }
  _searchObjectList(e2) {
    let t2 = K(e2, this.options), { keys: n2, records: r2 } = this._myIndex, i2 = [];
    return r2.forEach(({ $: e3, i: r3 }) => {
      if (!l(e3)) return;
      let a2 = [];
      n2.forEach((n3, r4) => {
        a2.push(...this._findMatches({ key: n3, value: e3[r4], searcher: t2 }));
      }), a2.length && i2.push({ idx: r3, item: e3, matches: a2 });
    }), i2;
  }
  _findMatches({ key: t2, value: n2, searcher: r2 }) {
    if (!l(n2)) return [];
    let i2 = [];
    if (e(n2)) n2.forEach(({ v: e2, i: n3, n: a2 }) => {
      if (!l(e2)) return;
      let { isMatch: o2, score: s2, indices: c2 } = r2.searchIn(e2);
      o2 && i2.push({ score: s2, key: t2, value: e2, idx: n3, norm: a2, indices: c2 });
    });
    else {
      let { v: e2, n: a2 } = n2, { isMatch: o2, score: s2, indices: c2 } = r2.searchIn(e2);
      o2 && i2.push({ score: s2, key: t2, value: e2, norm: a2, indices: c2 });
    }
    return i2;
  }
};
$.version = `7.1.0`, $.createIndex = O, $.parseIndex = re, $.config = T, $.parseQuery = Z, fe(de);
export {
  $ as Fuse
};
