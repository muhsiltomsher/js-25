const e = [`top`, `right`, `bottom`, `left`], t = [`start`, `end`], n = e.reduce((e2, n2) => e2.concat(n2, n2 + `-` + t[0], n2 + `-` + t[1]), []), r = Math.min, i = Math.max, a = Math.round, o = Math.floor, s = (e2) => ({ x: e2, y: e2 }), c = { left: `right`, right: `left`, bottom: `top`, top: `bottom` }, l = { start: `end`, end: `start` };
function u(e2, t2, n2) {
  return i(e2, r(t2, n2));
}
function d(e2, t2) {
  return typeof e2 == `function` ? e2(t2) : e2;
}
function f(e2) {
  return e2.split(`-`)[0];
}
function p(e2) {
  return e2.split(`-`)[1];
}
function m(e2) {
  return e2 === `x` ? `y` : `x`;
}
function h(e2) {
  return e2 === `y` ? `height` : `width`;
}
function g(e2) {
  return [`top`, `bottom`].includes(f(e2)) ? `y` : `x`;
}
function _(e2) {
  return m(g(e2));
}
function v(e2, t2, n2) {
  n2 === void 0 && (n2 = false);
  let r2 = p(e2), i2 = _(e2), a2 = h(i2), o2 = i2 === `x` ? r2 === (n2 ? `end` : `start`) ? `right` : `left` : r2 === `start` ? `bottom` : `top`;
  return t2.reference[a2] > t2.floating[a2] && (o2 = C(o2)), [o2, C(o2)];
}
function y(e2) {
  let t2 = C(e2);
  return [b(e2), t2, b(t2)];
}
function b(e2) {
  return e2.replace(/start|end/g, (e3) => l[e3]);
}
function x(e2, t2, n2) {
  let r2 = [`left`, `right`], i2 = [`right`, `left`], a2 = [`top`, `bottom`], o2 = [`bottom`, `top`];
  switch (e2) {
    case `top`:
    case `bottom`:
      return n2 ? t2 ? i2 : r2 : t2 ? r2 : i2;
    case `left`:
    case `right`:
      return t2 ? a2 : o2;
    default:
      return [];
  }
}
function S(e2, t2, n2, r2) {
  let i2 = p(e2), a2 = x(f(e2), n2 === `start`, r2);
  return i2 && (a2 = a2.map((e3) => e3 + `-` + i2), t2 && (a2 = a2.concat(a2.map(b)))), a2;
}
function C(e2) {
  return e2.replace(/left|right|bottom|top/g, (e3) => c[e3]);
}
function w(e2) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...e2 };
}
function T(e2) {
  return typeof e2 == `number` ? { top: e2, right: e2, bottom: e2, left: e2 } : w(e2);
}
function E(e2) {
  let { x: t2, y: n2, width: r2, height: i2 } = e2;
  return { width: r2, height: i2, top: n2, left: t2, right: t2 + r2, bottom: n2 + i2, x: t2, y: n2 };
}
function D(e2, t2, n2) {
  let { reference: r2, floating: i2 } = e2, a2 = g(t2), o2 = _(t2), s2 = h(o2), c2 = f(t2), l2 = a2 === `y`, u2 = r2.x + r2.width / 2 - i2.width / 2, d2 = r2.y + r2.height / 2 - i2.height / 2, m2 = r2[s2] / 2 - i2[s2] / 2, v2;
  switch (c2) {
    case `top`:
      v2 = { x: u2, y: r2.y - i2.height };
      break;
    case `bottom`:
      v2 = { x: u2, y: r2.y + r2.height };
      break;
    case `right`:
      v2 = { x: r2.x + r2.width, y: d2 };
      break;
    case `left`:
      v2 = { x: r2.x - i2.width, y: d2 };
      break;
    default:
      v2 = { x: r2.x, y: r2.y };
  }
  switch (p(t2)) {
    case `start`:
      v2[o2] -= m2 * (n2 && l2 ? -1 : 1);
      break;
    case `end`:
      v2[o2] += m2 * (n2 && l2 ? -1 : 1);
      break;
  }
  return v2;
}
const O = async (e2, t2, n2) => {
  let { placement: r2 = `bottom`, strategy: i2 = `absolute`, middleware: a2 = [], platform: o2 } = n2, s2 = a2.filter(Boolean), c2 = await (o2.isRTL == null ? void 0 : o2.isRTL(t2)), l2 = await o2.getElementRects({ reference: e2, floating: t2, strategy: i2 }), { x: u2, y: d2 } = D(l2, r2, c2), f2 = r2, p2 = {}, m2 = 0;
  for (let n3 = 0; n3 < s2.length; n3++) {
    let { name: a3, fn: h2 } = s2[n3], { x: g2, y: _2, data: v2, reset: y2 } = await h2({ x: u2, y: d2, initialPlacement: r2, placement: f2, strategy: i2, middlewareData: p2, rects: l2, platform: o2, elements: { reference: e2, floating: t2 } });
    u2 = g2 ?? u2, d2 = _2 ?? d2, p2 = { ...p2, [a3]: { ...p2[a3], ...v2 } }, y2 && m2 <= 50 && (m2++, typeof y2 == `object` && (y2.placement && (f2 = y2.placement), y2.rects && (l2 = y2.rects === true ? await o2.getElementRects({ reference: e2, floating: t2, strategy: i2 }) : y2.rects), { x: u2, y: d2 } = D(l2, f2, c2)), n3 = -1);
  }
  return { x: u2, y: d2, placement: f2, strategy: i2, middlewareData: p2 };
};
async function k(e2, t2) {
  var n2;
  t2 === void 0 && (t2 = {});
  let { x: r2, y: i2, platform: a2, rects: o2, elements: s2, strategy: c2 } = e2, { boundary: l2 = `clippingAncestors`, rootBoundary: u2 = `viewport`, elementContext: f2 = `floating`, altBoundary: p2 = false, padding: m2 = 0 } = d(t2, e2), h2 = T(m2), g2 = f2 === `floating` ? `reference` : `floating`, _2 = s2[p2 ? g2 : f2], v2 = E(await a2.getClippingRect({ element: (n2 = await (a2.isElement == null ? void 0 : a2.isElement(_2))) ?? true ? _2 : _2.contextElement || await (a2.getDocumentElement == null ? void 0 : a2.getDocumentElement(s2.floating)), boundary: l2, rootBoundary: u2, strategy: c2 })), y2 = f2 === `floating` ? { x: r2, y: i2, width: o2.floating.width, height: o2.floating.height } : o2.reference, b2 = await (a2.getOffsetParent == null ? void 0 : a2.getOffsetParent(s2.floating)), x2 = await (a2.isElement == null ? void 0 : a2.isElement(b2)) && await (a2.getScale == null ? void 0 : a2.getScale(b2)) || { x: 1, y: 1 }, S2 = E(a2.convertOffsetParentRelativeRectToViewportRelativeRect ? await a2.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: s2, rect: y2, offsetParent: b2, strategy: c2 }) : y2);
  return { top: (v2.top - S2.top + h2.top) / x2.y, bottom: (S2.bottom - v2.bottom + h2.bottom) / x2.y, left: (v2.left - S2.left + h2.left) / x2.x, right: (S2.right - v2.right + h2.right) / x2.x };
}
const A = (e2) => ({ name: `arrow`, options: e2, async fn(t2) {
  let { x: n2, y: i2, placement: a2, rects: o2, platform: s2, elements: c2, middlewareData: l2 } = t2, { element: f2, padding: m2 = 0 } = d(e2, t2) || {};
  if (f2 == null) return {};
  let g2 = T(m2), v2 = { x: n2, y: i2 }, y2 = _(a2), b2 = h(y2), x2 = await s2.getDimensions(f2), S2 = y2 === `y`, C2 = S2 ? `top` : `left`, w2 = S2 ? `bottom` : `right`, E2 = S2 ? `clientHeight` : `clientWidth`, D2 = o2.reference[b2] + o2.reference[y2] - v2[y2] - o2.floating[b2], O2 = v2[y2] - o2.reference[y2], k2 = await (s2.getOffsetParent == null ? void 0 : s2.getOffsetParent(f2)), A2 = k2 ? k2[E2] : 0;
  (!A2 || !await (s2.isElement == null ? void 0 : s2.isElement(k2))) && (A2 = c2.floating[E2] || o2.floating[b2]);
  let j2 = D2 / 2 - O2 / 2, M2 = A2 / 2 - x2[b2] / 2 - 1, N2 = r(g2[C2], M2), P2 = r(g2[w2], M2), F2 = N2, I2 = A2 - x2[b2] - P2, L2 = A2 / 2 - x2[b2] / 2 + j2, R2 = u(F2, L2, I2), z2 = !l2.arrow && p(a2) != null && L2 !== R2 && o2.reference[b2] / 2 - (L2 < F2 ? N2 : P2) - x2[b2] / 2 < 0, B2 = z2 ? L2 < F2 ? L2 - F2 : L2 - I2 : 0;
  return { [y2]: v2[y2] + B2, data: { [y2]: R2, centerOffset: L2 - R2 - B2, ...z2 && { alignmentOffset: B2 } }, reset: z2 };
} });
function j(e2, t2, n2) {
  let r2 = e2 ? [...n2.filter((t3) => p(t3) === e2), ...n2.filter((t3) => p(t3) !== e2)] : n2.filter((e3) => f(e3) === e3);
  return r2.filter((n3) => e2 ? p(n3) === e2 || (t2 ? b(n3) !== n3 : false) : true);
}
const M = function(e2) {
  return e2 === void 0 && (e2 = {}), { name: `autoPlacement`, options: e2, async fn(t2) {
    var _a, _b, _c;
    var r2, i2, a2;
    let { rects: o2, middlewareData: s2, placement: c2, platform: l2, elements: u2 } = t2, { crossAxis: m2 = false, alignment: h2, allowedPlacements: g2 = n, autoAlignment: _2 = true, ...y2 } = d(e2, t2), b2 = h2 !== void 0 || g2 === n ? j(h2 || null, _2, g2) : g2, x2 = await k(t2, y2), S2 = ((_a = r2 = s2.autoPlacement) == null ? void 0 : _a.index) || 0, C2 = b2[S2];
    if (C2 == null) return {};
    let w2 = v(C2, o2, await (l2.isRTL == null ? void 0 : l2.isRTL(u2.floating)));
    if (c2 !== C2) return { reset: { placement: b2[0] } };
    let T2 = [x2[f(C2)], x2[w2[0]], x2[w2[1]]], E2 = [...((_b = i2 = s2.autoPlacement) == null ? void 0 : _b.overflows) || [], { placement: C2, overflows: T2 }], D2 = b2[S2 + 1];
    if (D2) return { data: { index: S2 + 1, overflows: E2 }, reset: { placement: D2 } };
    let O2 = E2.map((e3) => {
      let t3 = p(e3.placement);
      return [e3.placement, t3 && m2 ? e3.overflows.slice(0, 2).reduce((e4, t4) => e4 + t4, 0) : e3.overflows[0], e3.overflows];
    }).sort((e3, t3) => e3[1] - t3[1]), A2 = O2.filter((e3) => e3[2].slice(0, p(e3[0]) ? 2 : 3).every((e4) => e4 <= 0)), M2 = ((_c = a2 = A2[0]) == null ? void 0 : _c[0]) || O2[0][0];
    return M2 === c2 ? {} : { data: { index: S2 + 1, overflows: E2 }, reset: { placement: M2 } };
  } };
}, N = function(e2) {
  return e2 === void 0 && (e2 = {}), { name: `flip`, options: e2, async fn(t2) {
    var _a, _b, _c, _d, _e;
    var n2, r2;
    let { placement: i2, middlewareData: a2, rects: o2, initialPlacement: s2, platform: c2, elements: l2 } = t2, { mainAxis: u2 = true, crossAxis: p2 = true, fallbackPlacements: m2, fallbackStrategy: h2 = `bestFit`, fallbackAxisSideDirection: _2 = `none`, flipAlignment: b2 = true, ...x2 } = d(e2, t2);
    if ((n2 = a2.arrow) != null && n2.alignmentOffset) return {};
    let w2 = f(i2), T2 = g(s2), E2 = f(s2) === s2, D2 = await (c2.isRTL == null ? void 0 : c2.isRTL(l2.floating)), O2 = m2 || (E2 || !b2 ? [C(s2)] : y(s2)), A2 = _2 !== `none`;
    !m2 && A2 && O2.push(...S(s2, b2, _2, D2));
    let j2 = [s2, ...O2], M2 = await k(t2, x2), N2 = [], P2 = ((_a = r2 = a2.flip) == null ? void 0 : _a.overflows) || [];
    if (u2 && N2.push(M2[w2]), p2) {
      let e3 = v(i2, o2, D2);
      N2.push(M2[e3[0]], M2[e3[1]]);
    }
    if (P2 = [...P2, { placement: i2, overflows: N2 }], !N2.every((e3) => e3 <= 0)) {
      var F2, I2;
      let e3 = (((_b = F2 = a2.flip) == null ? void 0 : _b.index) || 0) + 1, t3 = j2[e3];
      if (t3) {
        var L2;
        let n4 = p2 === `alignment` ? T2 !== g(t3) : false, r3 = ((_c = L2 = P2[0]) == null ? void 0 : _c.overflows[0]) > 0;
        if (!n4 || r3) return { data: { index: e3, overflows: P2 }, reset: { placement: t3 } };
      }
      let n3 = (_d = I2 = P2.filter((e4) => e4.overflows[0] <= 0).sort((e4, t4) => e4.overflows[1] - t4.overflows[1])[0]) == null ? void 0 : _d.placement;
      if (!n3) switch (h2) {
        case `bestFit`: {
          var R2;
          let e4 = (_e = R2 = P2.filter((e5) => {
            if (A2) {
              let t4 = g(e5.placement);
              return t4 === T2 || t4 === `y`;
            }
            return true;
          }).map((e5) => [e5.placement, e5.overflows.filter((e6) => e6 > 0).reduce((e6, t4) => e6 + t4, 0)]).sort((e5, t4) => e5[1] - t4[1])[0]) == null ? void 0 : _e[0];
          e4 && (n3 = e4);
          break;
        }
        case `initialPlacement`:
          n3 = s2;
          break;
      }
      if (i2 !== n3) return { reset: { placement: n3 } };
    }
    return {};
  } };
};
function P(e2, t2) {
  return { top: e2.top - t2.height, right: e2.right - t2.width, bottom: e2.bottom - t2.height, left: e2.left - t2.width };
}
function F(t2) {
  return e.some((e2) => t2[e2] >= 0);
}
const I = function(e2) {
  return e2 === void 0 && (e2 = {}), { name: `hide`, options: e2, async fn(t2) {
    let { rects: n2 } = t2, { strategy: r2 = `referenceHidden`, ...i2 } = d(e2, t2);
    switch (r2) {
      case `referenceHidden`: {
        let e3 = await k(t2, { ...i2, elementContext: `reference` }), r3 = P(e3, n2.reference);
        return { data: { referenceHiddenOffsets: r3, referenceHidden: F(r3) } };
      }
      case `escaped`: {
        let e3 = await k(t2, { ...i2, altBoundary: true }), r3 = P(e3, n2.floating);
        return { data: { escapedOffsets: r3, escaped: F(r3) } };
      }
      default:
        return {};
    }
  } };
};
async function L(e2, t2) {
  let { placement: n2, platform: r2, elements: i2 } = e2, a2 = await (r2.isRTL == null ? void 0 : r2.isRTL(i2.floating)), o2 = f(n2), s2 = p(n2), c2 = g(n2) === `y`, l2 = [`left`, `top`].includes(o2) ? -1 : 1, u2 = a2 && c2 ? -1 : 1, m2 = d(t2, e2), { mainAxis: h2, crossAxis: _2, alignmentAxis: v2 } = typeof m2 == `number` ? { mainAxis: m2, crossAxis: 0, alignmentAxis: null } : { mainAxis: m2.mainAxis || 0, crossAxis: m2.crossAxis || 0, alignmentAxis: m2.alignmentAxis };
  return s2 && typeof v2 == `number` && (_2 = s2 === `end` ? v2 * -1 : v2), c2 ? { x: _2 * u2, y: h2 * l2 } : { x: h2 * l2, y: _2 * u2 };
}
const R = function(e2) {
  return e2 === void 0 && (e2 = 0), { name: `offset`, options: e2, async fn(t2) {
    var _a;
    var n2, r2;
    let { x: i2, y: a2, placement: o2, middlewareData: s2 } = t2, c2 = await L(t2, e2);
    return o2 === ((_a = n2 = s2.offset) == null ? void 0 : _a.placement) && (r2 = s2.arrow) != null && r2.alignmentOffset ? {} : { x: i2 + c2.x, y: a2 + c2.y, data: { ...c2, placement: o2 } };
  } };
}, z = function(e2) {
  return e2 === void 0 && (e2 = {}), { name: `shift`, options: e2, async fn(t2) {
    let { x: n2, y: r2, placement: i2 } = t2, { mainAxis: a2 = true, crossAxis: o2 = false, limiter: s2 = { fn: (e3) => {
      let { x: t3, y: n3 } = e3;
      return { x: t3, y: n3 };
    } }, ...c2 } = d(e2, t2), l2 = { x: n2, y: r2 }, p2 = await k(t2, c2), h2 = g(f(i2)), _2 = m(h2), v2 = l2[_2], y2 = l2[h2];
    if (a2) {
      let e3 = _2 === `y` ? `top` : `left`, t3 = _2 === `y` ? `bottom` : `right`, n3 = v2 + p2[e3], r3 = v2 - p2[t3];
      v2 = u(n3, v2, r3);
    }
    if (o2) {
      let e3 = h2 === `y` ? `top` : `left`, t3 = h2 === `y` ? `bottom` : `right`, n3 = y2 + p2[e3], r3 = y2 - p2[t3];
      y2 = u(n3, y2, r3);
    }
    let b2 = s2.fn({ ...t2, [_2]: v2, [h2]: y2 });
    return { ...b2, data: { x: b2.x - n2, y: b2.y - r2, enabled: { [_2]: a2, [h2]: o2 } } };
  } };
}, B = function(e2) {
  return e2 === void 0 && (e2 = {}), { options: e2, fn(t2) {
    var _a, _b;
    let { x: n2, y: r2, placement: i2, rects: a2, middlewareData: o2 } = t2, { offset: s2 = 0, mainAxis: c2 = true, crossAxis: l2 = true } = d(e2, t2), u2 = { x: n2, y: r2 }, p2 = g(i2), h2 = m(p2), _2 = u2[h2], v2 = u2[p2], y2 = d(s2, t2), b2 = typeof y2 == `number` ? { mainAxis: y2, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...y2 };
    if (c2) {
      let e3 = h2 === `y` ? `height` : `width`, t3 = a2.reference[h2] - a2.floating[e3] + b2.mainAxis, n3 = a2.reference[h2] + a2.reference[e3] - b2.mainAxis;
      _2 < t3 ? _2 = t3 : _2 > n3 && (_2 = n3);
    }
    if (l2) {
      var x2, S2;
      let e3 = h2 === `y` ? `width` : `height`, t3 = [`top`, `left`].includes(f(i2)), n3 = a2.reference[p2] - a2.floating[e3] + (t3 && ((_a = x2 = o2.offset) == null ? void 0 : _a[p2]) || 0) + (t3 ? 0 : b2.crossAxis), r3 = a2.reference[p2] + a2.reference[e3] + (t3 ? 0 : ((_b = S2 = o2.offset) == null ? void 0 : _b[p2]) || 0) - (t3 ? b2.crossAxis : 0);
      v2 < n3 ? v2 = n3 : v2 > r3 && (v2 = r3);
    }
    return { [h2]: _2, [p2]: v2 };
  } };
}, V = function(e2) {
  return e2 === void 0 && (e2 = {}), { name: `size`, options: e2, async fn(t2) {
    var n2, a2;
    let { placement: o2, rects: s2, platform: c2, elements: l2 } = t2, { apply: u2 = () => {
    }, ...m2 } = d(e2, t2), h2 = await k(t2, m2), _2 = f(o2), v2 = p(o2), y2 = g(o2) === `y`, { width: b2, height: x2 } = s2.floating, S2, C2;
    _2 === `top` || _2 === `bottom` ? (S2 = _2, C2 = v2 === (await (c2.isRTL == null ? void 0 : c2.isRTL(l2.floating)) ? `start` : `end`) ? `left` : `right`) : (C2 = _2, S2 = v2 === `end` ? `top` : `bottom`);
    let w2 = x2 - h2.top - h2.bottom, T2 = b2 - h2.left - h2.right, E2 = r(x2 - h2[S2], w2), D2 = r(b2 - h2[C2], T2), O2 = !t2.middlewareData.shift, A2 = E2, j2 = D2;
    if ((n2 = t2.middlewareData.shift) != null && n2.enabled.x && (j2 = T2), (a2 = t2.middlewareData.shift) != null && a2.enabled.y && (A2 = w2), O2 && !v2) {
      let e3 = i(h2.left, 0), t3 = i(h2.right, 0), n3 = i(h2.top, 0), r2 = i(h2.bottom, 0);
      y2 ? j2 = b2 - 2 * (e3 !== 0 || t3 !== 0 ? e3 + t3 : i(h2.left, h2.right)) : A2 = x2 - 2 * (n3 !== 0 || r2 !== 0 ? n3 + r2 : i(h2.top, h2.bottom));
    }
    await u2({ ...t2, availableWidth: j2, availableHeight: A2 });
    let M2 = await c2.getDimensions(l2.floating);
    return b2 !== M2.width || x2 !== M2.height ? { reset: { rects: true } } : {};
  } };
};
export {
  A as arrow,
  M as autoPlacement,
  O as computePosition,
  s as createCoords,
  N as flip,
  o as floor,
  I as hide,
  B as limitShift,
  i as max,
  r as min,
  R as offset,
  E as rectToClientRect,
  a as round,
  z as shift,
  V as size
};
