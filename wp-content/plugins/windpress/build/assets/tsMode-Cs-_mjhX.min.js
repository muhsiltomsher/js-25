var _a;
import "./preload-helper-DApxheAR.min.js";
import "./dist-BSmntxBi.min.js";
import "./dist-Doa7WVF-.min.js";
import { editor_api_exports as e } from "./editor.api-CNFWHCpp.min.js";
import { typescriptDefaults as t } from "./monaco.contribution-DghwUxMS.min.js";
var n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = Object.getOwnPropertyNames, a = Object.prototype.hasOwnProperty, o = (e4, t2, o2, s2) => {
  if (t2 && typeof t2 == `object` || typeof t2 == `function`) for (let c2 of i(t2)) !a.call(e4, c2) && c2 !== o2 && n(e4, c2, { get: () => t2[c2], enumerable: !(s2 = r(t2, c2)) || s2.enumerable });
  return e4;
}, s = (e4, t2, n2) => (o(e4, t2, `default`), n2 && o(n2, t2, `default`)), c = {};
s(c, e);
var l = class {
  constructor(e4, t2) {
    this._modeId = e4, this._defaults = t2, this._worker = null, this._client = null, this._configChangeListener = this._defaults.onDidChange(() => this._stopWorker()), this._updateExtraLibsToken = 0, this._extraLibsChangeListener = this._defaults.onDidExtraLibsChange(() => this._updateExtraLibs());
  }
  dispose() {
    this._configChangeListener.dispose(), this._extraLibsChangeListener.dispose(), this._stopWorker();
  }
  _stopWorker() {
    this._worker && (this._worker.dispose(), this._worker = null), this._client = null;
  }
  async _updateExtraLibs() {
    if (!this._worker) return;
    let e4 = ++this._updateExtraLibsToken, t2 = await this._worker.getProxy();
    this._updateExtraLibsToken === e4 && t2.updateExtraLibs(this._defaults.getExtraLibs());
  }
  _getClient() {
    return this._client || (this._client = (async () => (this._worker = c.editor.createWebWorker({ moduleId: `vs/language/typescript/tsWorker`, label: this._modeId, keepIdleModels: true, createData: { compilerOptions: this._defaults.getCompilerOptions(), extraLibs: this._defaults.getExtraLibs(), customWorkerPath: this._defaults.workerOptions.customWorkerPath, inlayHintsOptions: this._defaults.inlayHintsOptions } }), this._defaults.getEagerModelSync() ? await this._worker.withSyncedResources(c.editor.getModels().filter((e4) => e4.getLanguageId() === this._modeId).map((e4) => e4.uri)) : await this._worker.getProxy()))()), this._client;
  }
  async getLanguageServiceWorker(...e4) {
    let t2 = await this._getClient();
    return this._worker && await this._worker.withSyncedResources(e4), t2;
  }
}, u = {};
u[`lib.d.ts`] = true, u[`lib.decorators.d.ts`] = true, u[`lib.decorators.legacy.d.ts`] = true, u[`lib.dom.asynciterable.d.ts`] = true, u[`lib.dom.d.ts`] = true, u[`lib.dom.iterable.d.ts`] = true, u[`lib.es2015.collection.d.ts`] = true, u[`lib.es2015.core.d.ts`] = true, u[`lib.es2015.d.ts`] = true, u[`lib.es2015.generator.d.ts`] = true, u[`lib.es2015.iterable.d.ts`] = true, u[`lib.es2015.promise.d.ts`] = true, u[`lib.es2015.proxy.d.ts`] = true, u[`lib.es2015.reflect.d.ts`] = true, u[`lib.es2015.symbol.d.ts`] = true, u[`lib.es2015.symbol.wellknown.d.ts`] = true, u[`lib.es2016.array.include.d.ts`] = true, u[`lib.es2016.d.ts`] = true, u[`lib.es2016.full.d.ts`] = true, u[`lib.es2016.intl.d.ts`] = true, u[`lib.es2017.d.ts`] = true, u[`lib.es2017.date.d.ts`] = true, u[`lib.es2017.full.d.ts`] = true, u[`lib.es2017.intl.d.ts`] = true, u[`lib.es2017.object.d.ts`] = true, u[`lib.es2017.sharedmemory.d.ts`] = true, u[`lib.es2017.string.d.ts`] = true, u[`lib.es2017.typedarrays.d.ts`] = true, u[`lib.es2018.asyncgenerator.d.ts`] = true, u[`lib.es2018.asynciterable.d.ts`] = true, u[`lib.es2018.d.ts`] = true, u[`lib.es2018.full.d.ts`] = true, u[`lib.es2018.intl.d.ts`] = true, u[`lib.es2018.promise.d.ts`] = true, u[`lib.es2018.regexp.d.ts`] = true, u[`lib.es2019.array.d.ts`] = true, u[`lib.es2019.d.ts`] = true, u[`lib.es2019.full.d.ts`] = true, u[`lib.es2019.intl.d.ts`] = true, u[`lib.es2019.object.d.ts`] = true, u[`lib.es2019.string.d.ts`] = true, u[`lib.es2019.symbol.d.ts`] = true, u[`lib.es2020.bigint.d.ts`] = true, u[`lib.es2020.d.ts`] = true, u[`lib.es2020.date.d.ts`] = true, u[`lib.es2020.full.d.ts`] = true, u[`lib.es2020.intl.d.ts`] = true, u[`lib.es2020.number.d.ts`] = true, u[`lib.es2020.promise.d.ts`] = true, u[`lib.es2020.sharedmemory.d.ts`] = true, u[`lib.es2020.string.d.ts`] = true, u[`lib.es2020.symbol.wellknown.d.ts`] = true, u[`lib.es2021.d.ts`] = true, u[`lib.es2021.full.d.ts`] = true, u[`lib.es2021.intl.d.ts`] = true, u[`lib.es2021.promise.d.ts`] = true, u[`lib.es2021.string.d.ts`] = true, u[`lib.es2021.weakref.d.ts`] = true, u[`lib.es2022.array.d.ts`] = true, u[`lib.es2022.d.ts`] = true, u[`lib.es2022.error.d.ts`] = true, u[`lib.es2022.full.d.ts`] = true, u[`lib.es2022.intl.d.ts`] = true, u[`lib.es2022.object.d.ts`] = true, u[`lib.es2022.regexp.d.ts`] = true, u[`lib.es2022.sharedmemory.d.ts`] = true, u[`lib.es2022.string.d.ts`] = true, u[`lib.es2023.array.d.ts`] = true, u[`lib.es2023.collection.d.ts`] = true, u[`lib.es2023.d.ts`] = true, u[`lib.es2023.full.d.ts`] = true, u[`lib.es5.d.ts`] = true, u[`lib.es6.d.ts`] = true, u[`lib.esnext.collection.d.ts`] = true, u[`lib.esnext.d.ts`] = true, u[`lib.esnext.decorators.d.ts`] = true, u[`lib.esnext.disposable.d.ts`] = true, u[`lib.esnext.full.d.ts`] = true, u[`lib.esnext.intl.d.ts`] = true, u[`lib.esnext.object.d.ts`] = true, u[`lib.esnext.promise.d.ts`] = true, u[`lib.scripthost.d.ts`] = true, u[`lib.webworker.asynciterable.d.ts`] = true, u[`lib.webworker.d.ts`] = true, u[`lib.webworker.importscripts.d.ts`] = true, u[`lib.webworker.iterable.d.ts`] = true;
function d(e4, t2, n2 = 0) {
  if (typeof e4 == `string`) return e4;
  if (e4 === void 0) return ``;
  let r2 = ``;
  if (n2) {
    r2 += t2;
    for (let e5 = 0; e5 < n2; e5++) r2 += `  `;
  }
  if (r2 += e4.messageText, n2++, e4.next) for (let i2 of e4.next) r2 += d(i2, t2, n2);
  return r2;
}
function f(e4) {
  return e4 ? e4.map((e5) => e5.text).join(``) : ``;
}
var p = class {
  constructor(e4) {
    this._worker = e4;
  }
  _textSpanToRange(e4, t2) {
    let n2 = e4.getPositionAt(t2.start), r2 = e4.getPositionAt(t2.start + t2.length), { lineNumber: i2, column: a2 } = n2, { lineNumber: o2, column: s2 } = r2;
    return { startLineNumber: i2, startColumn: a2, endLineNumber: o2, endColumn: s2 };
  }
}, m = class {
  constructor(e4) {
    this._worker = e4, this._libFiles = {}, this._hasFetchedLibFiles = false, this._fetchLibFilesPromise = null;
  }
  isLibFile(e4) {
    return e4 && e4.path.indexOf(`/lib.`) === 0 ? !!u[e4.path.slice(1)] : false;
  }
  getOrCreateModel(e4) {
    let n2 = c.Uri.parse(e4), r2 = c.editor.getModel(n2);
    if (r2) return r2;
    if (this.isLibFile(n2) && this._hasFetchedLibFiles) return c.editor.createModel(this._libFiles[n2.path.slice(1)], `typescript`, n2);
    let i2 = t.getExtraLibs()[e4];
    return i2 ? c.editor.createModel(i2.content, `typescript`, n2) : null;
  }
  _containsLibFile(e4) {
    for (let t2 of e4) if (this.isLibFile(t2)) return true;
    return false;
  }
  async fetchLibFilesIfNecessary(e4) {
    this._containsLibFile(e4) && await this._fetchLibFiles();
  }
  _fetchLibFiles() {
    return this._fetchLibFilesPromise || (this._fetchLibFilesPromise = this._worker().then((e4) => e4.getLibFiles()).then((e4) => {
      this._hasFetchedLibFiles = true, this._libFiles = e4;
    })), this._fetchLibFilesPromise;
  }
}, h = class extends p {
  constructor(e4, t2, n2, r2) {
    super(r2), this._libFiles = e4, this._defaults = t2, this._selector = n2, this._disposables = [], this._listener = /* @__PURE__ */ Object.create(null);
    let i2 = (e5) => {
      if (e5.getLanguageId() !== n2) return;
      let t3 = () => {
        let { onlyVisible: t4 } = this._defaults.getDiagnosticsOptions();
        t4 ? e5.isAttachedToEditor() && this._doValidate(e5) : this._doValidate(e5);
      }, r3, i3 = e5.onDidChangeContent(() => {
        clearTimeout(r3), r3 = window.setTimeout(t3, 500);
      }), a3 = e5.onDidChangeAttached(() => {
        let { onlyVisible: n3 } = this._defaults.getDiagnosticsOptions();
        n3 && (e5.isAttachedToEditor() ? t3() : c.editor.setModelMarkers(e5, this._selector, []));
      });
      this._listener[e5.uri.toString()] = { dispose() {
        i3.dispose(), a3.dispose(), clearTimeout(r3);
      } }, t3();
    }, a2 = (e5) => {
      c.editor.setModelMarkers(e5, this._selector, []);
      let t3 = e5.uri.toString();
      this._listener[t3] && (this._listener[t3].dispose(), delete this._listener[t3]);
    };
    this._disposables.push(c.editor.onDidCreateModel((e5) => i2(e5))), this._disposables.push(c.editor.onWillDisposeModel(a2)), this._disposables.push(c.editor.onDidChangeModelLanguage((e5) => {
      a2(e5.model), i2(e5.model);
    })), this._disposables.push({ dispose() {
      for (let e5 of c.editor.getModels()) a2(e5);
    } });
    let o2 = () => {
      for (let e5 of c.editor.getModels()) a2(e5), i2(e5);
    };
    this._disposables.push(this._defaults.onDidChange(o2)), this._disposables.push(this._defaults.onDidExtraLibsChange(o2)), c.editor.getModels().forEach((e5) => i2(e5));
  }
  dispose() {
    this._disposables.forEach((e4) => e4 && e4.dispose()), this._disposables = [];
  }
  async _doValidate(e4) {
    let t2 = await this._worker(e4.uri);
    if (e4.isDisposed()) return;
    let n2 = [], { noSyntaxValidation: r2, noSemanticValidation: i2, noSuggestionDiagnostics: a2 } = this._defaults.getDiagnosticsOptions();
    r2 || n2.push(t2.getSyntacticDiagnostics(e4.uri.toString())), i2 || n2.push(t2.getSemanticDiagnostics(e4.uri.toString())), a2 || n2.push(t2.getSuggestionDiagnostics(e4.uri.toString()));
    let o2 = await Promise.all(n2);
    if (!o2 || e4.isDisposed()) return;
    let s2 = o2.reduce((e5, t3) => t3.concat(e5), []).filter((e5) => (this._defaults.getDiagnosticsOptions().diagnosticCodesToIgnore || []).indexOf(e5.code) === -1), l2 = s2.map((e5) => e5.relatedInformation || []).reduce((e5, t3) => t3.concat(e5), []).map((e5) => e5.file ? c.Uri.parse(e5.file.fileName) : null);
    await this._libFiles.fetchLibFilesIfNecessary(l2), !e4.isDisposed() && c.editor.setModelMarkers(e4, this._selector, s2.map((t3) => this._convertDiagnostics(e4, t3)));
  }
  _convertDiagnostics(e4, t2) {
    let n2 = t2.start || 0, r2 = t2.length || 1, { lineNumber: i2, column: a2 } = e4.getPositionAt(n2), { lineNumber: o2, column: s2 } = e4.getPositionAt(n2 + r2), l2 = [];
    return t2.reportsUnnecessary && l2.push(c.MarkerTag.Unnecessary), t2.reportsDeprecated && l2.push(c.MarkerTag.Deprecated), { severity: this._tsDiagnosticCategoryToMarkerSeverity(t2.category), startLineNumber: i2, startColumn: a2, endLineNumber: o2, endColumn: s2, message: d(t2.messageText, `
`), code: t2.code.toString(), tags: l2, relatedInformation: this._convertRelatedInformation(e4, t2.relatedInformation) };
  }
  _convertRelatedInformation(e4, t2) {
    if (!t2) return [];
    let n2 = [];
    return t2.forEach((t3) => {
      let r2 = e4;
      if (t3.file && (r2 = this._libFiles.getOrCreateModel(t3.file.fileName)), !r2) return;
      let i2 = t3.start || 0, a2 = t3.length || 1, { lineNumber: o2, column: s2 } = r2.getPositionAt(i2), { lineNumber: c2, column: l2 } = r2.getPositionAt(i2 + a2);
      n2.push({ resource: r2.uri, startLineNumber: o2, startColumn: s2, endLineNumber: c2, endColumn: l2, message: d(t3.messageText, `
`) });
    }), n2;
  }
  _tsDiagnosticCategoryToMarkerSeverity(e4) {
    switch (e4) {
      case 1:
        return c.MarkerSeverity.Error;
      case 3:
        return c.MarkerSeverity.Info;
      case 0:
        return c.MarkerSeverity.Warning;
      case 2:
        return c.MarkerSeverity.Hint;
    }
    return c.MarkerSeverity.Info;
  }
}, g = class e2 extends p {
  get triggerCharacters() {
    return [`.`];
  }
  async provideCompletionItems(t2, n2, r2, i2) {
    let a2 = t2.getWordUntilPosition(n2), o2 = new c.Range(n2.lineNumber, a2.startColumn, n2.lineNumber, a2.endColumn), s2 = t2.uri, l2 = t2.getOffsetAt(n2), u2 = await this._worker(s2);
    if (t2.isDisposed()) return;
    let d2 = await u2.getCompletionsAtPosition(s2.toString(), l2);
    if (!d2 || t2.isDisposed()) return;
    let f2 = d2.entries.map((r3) => {
      let i3 = o2;
      if (r3.replacementSpan) {
        let e4 = t2.getPositionAt(r3.replacementSpan.start), n3 = t2.getPositionAt(r3.replacementSpan.start + r3.replacementSpan.length);
        i3 = new c.Range(e4.lineNumber, e4.column, n3.lineNumber, n3.column);
      }
      let a3 = [];
      return r3.kindModifiers !== void 0 && r3.kindModifiers.indexOf(`deprecated`) !== -1 && a3.push(c.languages.CompletionItemTag.Deprecated), { uri: s2, position: n2, offset: l2, range: i3, label: r3.name, insertText: r3.name, sortText: r3.sortText, kind: e2.convertKind(r3.kind), tags: a3 };
    });
    return { suggestions: f2 };
  }
  async resolveCompletionItem(t2, n2) {
    let r2 = t2, i2 = r2.uri, a2 = r2.position, o2 = r2.offset, s2 = await this._worker(i2), c2 = await s2.getCompletionEntryDetails(i2.toString(), o2, r2.label);
    return c2 ? { uri: i2, position: a2, label: c2.name, kind: e2.convertKind(c2.kind), detail: f(c2.displayParts), documentation: { value: e2.createDocumentationString(c2) } } : r2;
  }
  static convertKind(e4) {
    switch (e4) {
      case w.primitiveType:
      case w.keyword:
        return c.languages.CompletionItemKind.Keyword;
      case w.variable:
      case w.localVariable:
        return c.languages.CompletionItemKind.Variable;
      case w.memberVariable:
      case w.memberGetAccessor:
      case w.memberSetAccessor:
        return c.languages.CompletionItemKind.Field;
      case w.function:
      case w.memberFunction:
      case w.constructSignature:
      case w.callSignature:
      case w.indexSignature:
        return c.languages.CompletionItemKind.Function;
      case w.enum:
        return c.languages.CompletionItemKind.Enum;
      case w.module:
        return c.languages.CompletionItemKind.Module;
      case w.class:
        return c.languages.CompletionItemKind.Class;
      case w.interface:
        return c.languages.CompletionItemKind.Interface;
      case w.warning:
        return c.languages.CompletionItemKind.File;
    }
    return c.languages.CompletionItemKind.Property;
  }
  static createDocumentationString(e4) {
    let t2 = f(e4.documentation);
    if (e4.tags) for (let n2 of e4.tags) t2 += `

${_(n2)}`;
    return t2;
  }
};
function _(e4) {
  let t2 = `*@${e4.name}*`;
  if (e4.name === `param` && e4.text) {
    let [n2, ...r2] = e4.text;
    t2 += `\`${n2.text}\``, r2.length > 0 && (t2 += ` \u2014 ${r2.map((e5) => e5.text).join(` `)}`);
  } else Array.isArray(e4.text) ? t2 += ` \u2014 ${e4.text.map((e5) => e5.text).join(` `)}` : e4.text && (t2 += ` \u2014 ${e4.text}`);
  return t2;
}
var v = class e3 extends p {
  constructor() {
    super(...arguments), this.signatureHelpTriggerCharacters = [`(`, `,`];
  }
  static _toSignatureHelpTriggerReason(e4) {
    switch (e4.triggerKind) {
      case c.languages.SignatureHelpTriggerKind.TriggerCharacter:
        return e4.triggerCharacter ? e4.isRetrigger ? { kind: `retrigger`, triggerCharacter: e4.triggerCharacter } : { kind: `characterTyped`, triggerCharacter: e4.triggerCharacter } : { kind: `invoked` };
      case c.languages.SignatureHelpTriggerKind.ContentChange:
        return e4.isRetrigger ? { kind: `retrigger` } : { kind: `invoked` };
      case c.languages.SignatureHelpTriggerKind.Invoke:
      default:
        return { kind: `invoked` };
    }
  }
  async provideSignatureHelp(t2, n2, r2, i2) {
    let a2 = t2.uri, o2 = t2.getOffsetAt(n2), s2 = await this._worker(a2);
    if (t2.isDisposed()) return;
    let c2 = await s2.getSignatureHelpItems(a2.toString(), o2, { triggerReason: e3._toSignatureHelpTriggerReason(i2) });
    if (!c2 || t2.isDisposed()) return;
    let l2 = { activeSignature: c2.selectedItemIndex, activeParameter: c2.argumentIndex, signatures: [] };
    return c2.items.forEach((e4) => {
      let t3 = { label: ``, parameters: [] };
      t3.documentation = { value: f(e4.documentation) }, t3.label += f(e4.prefixDisplayParts), e4.parameters.forEach((n3, r3, i3) => {
        let a3 = f(n3.displayParts), o3 = { label: a3, documentation: { value: f(n3.documentation) } };
        t3.label += a3, t3.parameters.push(o3), r3 < i3.length - 1 && (t3.label += f(e4.separatorDisplayParts));
      }), t3.label += f(e4.suffixDisplayParts), l2.signatures.push(t3);
    }), { value: l2, dispose() {
    } };
  }
}, y = class extends p {
  async provideHover(e4, t2, n2) {
    let r2 = e4.uri, i2 = e4.getOffsetAt(t2), a2 = await this._worker(r2);
    if (e4.isDisposed()) return;
    let o2 = await a2.getQuickInfoAtPosition(r2.toString(), i2);
    if (!o2 || e4.isDisposed()) return;
    let s2 = f(o2.documentation), c2 = o2.tags ? o2.tags.map((e5) => _(e5)).join(`  

`) : ``, l2 = f(o2.displayParts);
    return { range: this._textSpanToRange(e4, o2.textSpan), contents: [{ value: "```typescript\n" + l2 + "\n```\n" }, { value: s2 + (c2 ? `

` + c2 : ``) }] };
  }
}, b = class extends p {
  async provideDocumentHighlights(e4, t2, n2) {
    let r2 = e4.uri, i2 = e4.getOffsetAt(t2), a2 = await this._worker(r2);
    if (e4.isDisposed()) return;
    let o2 = await a2.getDocumentHighlights(r2.toString(), i2, [r2.toString()]);
    if (!(!o2 || e4.isDisposed())) return o2.flatMap((t3) => t3.highlightSpans.map((t4) => ({ range: this._textSpanToRange(e4, t4.textSpan), kind: t4.kind === `writtenReference` ? c.languages.DocumentHighlightKind.Write : c.languages.DocumentHighlightKind.Text })));
  }
}, x = class extends p {
  constructor(e4, t2) {
    super(t2), this._libFiles = e4;
  }
  async provideDefinition(e4, t2, n2) {
    let r2 = e4.uri, i2 = e4.getOffsetAt(t2), a2 = await this._worker(r2);
    if (e4.isDisposed()) return;
    let o2 = await a2.getDefinitionAtPosition(r2.toString(), i2);
    if (!o2 || e4.isDisposed() || (await this._libFiles.fetchLibFilesIfNecessary(o2.map((e5) => c.Uri.parse(e5.fileName))), e4.isDisposed())) return;
    let s2 = [];
    for (let e5 of o2) {
      let t3 = this._libFiles.getOrCreateModel(e5.fileName);
      t3 && s2.push({ uri: t3.uri, range: this._textSpanToRange(t3, e5.textSpan) });
    }
    return s2;
  }
}, S = class extends p {
  constructor(e4, t2) {
    super(t2), this._libFiles = e4;
  }
  async provideReferences(e4, t2, n2, r2) {
    let i2 = e4.uri, a2 = e4.getOffsetAt(t2), o2 = await this._worker(i2);
    if (e4.isDisposed()) return;
    let s2 = await o2.getReferencesAtPosition(i2.toString(), a2);
    if (!s2 || e4.isDisposed() || (await this._libFiles.fetchLibFilesIfNecessary(s2.map((e5) => c.Uri.parse(e5.fileName))), e4.isDisposed())) return;
    let l2 = [];
    for (let e5 of s2) {
      let t3 = this._libFiles.getOrCreateModel(e5.fileName);
      t3 && l2.push({ uri: t3.uri, range: this._textSpanToRange(t3, e5.textSpan) });
    }
    return l2;
  }
}, C = class extends p {
  async provideDocumentSymbols(e4, t2) {
    let n2 = e4.uri, r2 = await this._worker(n2);
    if (e4.isDisposed()) return;
    let i2 = await r2.getNavigationTree(n2.toString());
    if (!i2 || e4.isDisposed()) return;
    let a2 = (t3, n3) => {
      var _a2;
      let r3 = { name: t3.text, detail: ``, kind: T[t3.kind] || c.languages.SymbolKind.Variable, range: this._textSpanToRange(e4, t3.spans[0]), selectionRange: this._textSpanToRange(e4, t3.spans[0]), tags: [], children: (_a2 = t3.childItems) == null ? void 0 : _a2.map((e5) => a2(e5, t3.text)), containerName: n3 };
      return r3;
    }, o2 = i2.childItems ? i2.childItems.map((e5) => a2(e5)) : [];
    return o2;
  }
}, w = (_a = class {
}, _a.unknown = ``, _a.keyword = `keyword`, _a.script = `script`, _a.module = `module`, _a.class = `class`, _a.interface = `interface`, _a.type = `type`, _a.enum = `enum`, _a.variable = `var`, _a.localVariable = `local var`, _a.function = `function`, _a.localFunction = `local function`, _a.memberFunction = `method`, _a.memberGetAccessor = `getter`, _a.memberSetAccessor = `setter`, _a.memberVariable = `property`, _a.constructorImplementation = `constructor`, _a.callSignature = `call`, _a.indexSignature = `index`, _a.constructSignature = `construct`, _a.parameter = `parameter`, _a.typeParameter = `type parameter`, _a.primitiveType = `primitive type`, _a.label = `label`, _a.alias = `alias`, _a.const = `const`, _a.let = `let`, _a.warning = `warning`, _a), T = /* @__PURE__ */ Object.create(null);
T[w.module] = c.languages.SymbolKind.Module, T[w.class] = c.languages.SymbolKind.Class, T[w.enum] = c.languages.SymbolKind.Enum, T[w.interface] = c.languages.SymbolKind.Interface, T[w.memberFunction] = c.languages.SymbolKind.Method, T[w.memberVariable] = c.languages.SymbolKind.Property, T[w.memberGetAccessor] = c.languages.SymbolKind.Property, T[w.memberSetAccessor] = c.languages.SymbolKind.Property, T[w.variable] = c.languages.SymbolKind.Variable, T[w.const] = c.languages.SymbolKind.Variable, T[w.localVariable] = c.languages.SymbolKind.Variable, T[w.variable] = c.languages.SymbolKind.Variable, T[w.function] = c.languages.SymbolKind.Function, T[w.localFunction] = c.languages.SymbolKind.Function;
var E = class extends p {
  static _convertOptions(e4) {
    return { ConvertTabsToSpaces: e4.insertSpaces, TabSize: e4.tabSize, IndentSize: e4.tabSize, IndentStyle: 2, NewLineCharacter: `
`, InsertSpaceAfterCommaDelimiter: true, InsertSpaceAfterSemicolonInForStatements: true, InsertSpaceBeforeAndAfterBinaryOperators: true, InsertSpaceAfterKeywordsInControlFlowStatements: true, InsertSpaceAfterFunctionKeywordForAnonymousFunctions: true, InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: false, InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: false, InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: false, PlaceOpenBraceOnNewLineForControlBlocks: false, PlaceOpenBraceOnNewLineForFunctions: false };
  }
  _convertTextChanges(e4, t2) {
    return { text: t2.newText, range: this._textSpanToRange(e4, t2.span) };
  }
}, D = class extends E {
  constructor() {
    super(...arguments), this.canFormatMultipleRanges = false;
  }
  async provideDocumentRangeFormattingEdits(e4, t2, n2, r2) {
    let i2 = e4.uri, a2 = e4.getOffsetAt({ lineNumber: t2.startLineNumber, column: t2.startColumn }), o2 = e4.getOffsetAt({ lineNumber: t2.endLineNumber, column: t2.endColumn }), s2 = await this._worker(i2);
    if (e4.isDisposed()) return;
    let c2 = await s2.getFormattingEditsForRange(i2.toString(), a2, o2, E._convertOptions(n2));
    if (!(!c2 || e4.isDisposed())) return c2.map((t3) => this._convertTextChanges(e4, t3));
  }
}, O = class extends E {
  get autoFormatTriggerCharacters() {
    return [`;`, `}`, `
`];
  }
  async provideOnTypeFormattingEdits(e4, t2, n2, r2, i2) {
    let a2 = e4.uri, o2 = e4.getOffsetAt(t2), s2 = await this._worker(a2);
    if (e4.isDisposed()) return;
    let c2 = await s2.getFormattingEditsAfterKeystroke(a2.toString(), o2, n2, E._convertOptions(r2));
    if (!(!c2 || e4.isDisposed())) return c2.map((t3) => this._convertTextChanges(e4, t3));
  }
}, k = class extends E {
  async provideCodeActions(e4, t2, n2, r2) {
    let i2 = e4.uri, a2 = e4.getOffsetAt({ lineNumber: t2.startLineNumber, column: t2.startColumn }), o2 = e4.getOffsetAt({ lineNumber: t2.endLineNumber, column: t2.endColumn }), s2 = E._convertOptions(e4.getOptions()), c2 = n2.markers.filter((e5) => e5.code).map((e5) => e5.code).map(Number), l2 = await this._worker(i2);
    if (e4.isDisposed()) return;
    let u2 = await l2.getCodeFixesAtPosition(i2.toString(), a2, o2, c2, s2);
    if (!u2 || e4.isDisposed()) return { actions: [], dispose: () => {
    } };
    let d2 = u2.filter((e5) => e5.changes.filter((e6) => e6.isNewFile).length === 0).map((t3) => this._tsCodeFixActionToMonacoCodeAction(e4, n2, t3));
    return { actions: d2, dispose: () => {
    } };
  }
  _tsCodeFixActionToMonacoCodeAction(e4, t2, n2) {
    let r2 = [];
    for (let t3 of n2.changes) for (let n3 of t3.textChanges) r2.push({ resource: e4.uri, versionId: void 0, textEdit: { range: this._textSpanToRange(e4, n3.span), text: n3.newText } });
    let i2 = { title: n2.description, edit: { edits: r2 }, diagnostics: t2.markers, kind: `quickfix` };
    return i2;
  }
}, A = class extends p {
  constructor(e4, t2) {
    super(t2), this._libFiles = e4;
  }
  async provideRenameEdits(e4, t2, n2, r2) {
    let i2 = e4.uri, a2 = i2.toString(), o2 = e4.getOffsetAt(t2), s2 = await this._worker(i2);
    if (e4.isDisposed()) return;
    let c2 = await s2.getRenameInfo(a2, o2, { allowRenameOfImportPath: false });
    if (c2.canRename === false) return { edits: [], rejectReason: c2.localizedErrorMessage };
    if (c2.fileToRename !== void 0) throw Error(`Renaming files is not supported.`);
    let l2 = await s2.findRenameLocations(a2, o2, false, false, false);
    if (!l2 || e4.isDisposed()) return;
    let u2 = [];
    for (let e5 of l2) {
      let t3 = this._libFiles.getOrCreateModel(e5.fileName);
      if (t3) u2.push({ resource: t3.uri, versionId: void 0, textEdit: { range: this._textSpanToRange(t3, e5.textSpan), text: n2 } });
      else throw Error(`Unknown file ${e5.fileName}.`);
    }
    return { edits: u2 };
  }
}, j = class extends p {
  async provideInlayHints(e4, t2, n2) {
    let r2 = e4.uri, i2 = r2.toString(), a2 = e4.getOffsetAt({ lineNumber: t2.startLineNumber, column: t2.startColumn }), o2 = e4.getOffsetAt({ lineNumber: t2.endLineNumber, column: t2.endColumn }), s2 = await this._worker(r2);
    if (e4.isDisposed()) return null;
    let c2 = await s2.provideInlayHints(i2, a2, o2), l2 = c2.map((t3) => ({ ...t3, label: t3.text, position: e4.getPositionAt(t3.position), kind: this._convertHintKind(t3.kind) }));
    return { hints: l2, dispose: () => {
    } };
  }
  _convertHintKind(e4) {
    switch (e4) {
      case `Parameter`:
        return c.languages.InlayHintKind.Parameter;
      case `Type`:
        return c.languages.InlayHintKind.Type;
      default:
        return c.languages.InlayHintKind.Type;
    }
  }
}, M, N;
function P(e4) {
  N = R(e4, `typescript`);
}
function F(e4) {
  M = R(e4, `javascript`);
}
function I() {
  return new Promise((e4, t2) => {
    if (!M) return t2(`JavaScript not registered!`);
    e4(M);
  });
}
function L() {
  return new Promise((e4, t2) => {
    if (!N) return t2(`TypeScript not registered!`);
    e4(N);
  });
}
function R(e4, t2) {
  let n2 = [], r2 = [], i2 = new l(t2, e4);
  n2.push(i2);
  let a2 = (...e5) => i2.getLanguageServiceWorker(...e5), o2 = new m(a2);
  function s2() {
    let { modeConfiguration: n3 } = e4;
    B(r2), n3.completionItems && r2.push(c.languages.registerCompletionItemProvider(t2, new g(a2))), n3.signatureHelp && r2.push(c.languages.registerSignatureHelpProvider(t2, new v(a2))), n3.hovers && r2.push(c.languages.registerHoverProvider(t2, new y(a2))), n3.documentHighlights && r2.push(c.languages.registerDocumentHighlightProvider(t2, new b(a2))), n3.definitions && r2.push(c.languages.registerDefinitionProvider(t2, new x(o2, a2))), n3.references && r2.push(c.languages.registerReferenceProvider(t2, new S(o2, a2))), n3.documentSymbols && r2.push(c.languages.registerDocumentSymbolProvider(t2, new C(a2))), n3.rename && r2.push(c.languages.registerRenameProvider(t2, new A(o2, a2))), n3.documentRangeFormattingEdits && r2.push(c.languages.registerDocumentRangeFormattingEditProvider(t2, new D(a2))), n3.onTypeFormattingEdits && r2.push(c.languages.registerOnTypeFormattingEditProvider(t2, new O(a2))), n3.codeActions && r2.push(c.languages.registerCodeActionProvider(t2, new k(a2))), n3.inlayHints && r2.push(c.languages.registerInlayHintsProvider(t2, new j(a2))), n3.diagnostics && r2.push(new h(o2, e4, t2, a2));
  }
  return s2(), n2.push(z(r2)), a2;
}
function z(e4) {
  return { dispose: () => B(e4) };
}
function B(e4) {
  for (; e4.length; ) e4.pop().dispose();
}
export {
  p as Adapter,
  k as CodeActionAdaptor,
  x as DefinitionAdapter,
  h as DiagnosticsAdapter,
  b as DocumentHighlightAdapter,
  D as FormatAdapter,
  E as FormatHelper,
  O as FormatOnTypeAdapter,
  j as InlayHintsAdapter,
  w as Kind,
  m as LibFiles,
  C as OutlineAdapter,
  y as QuickInfoAdapter,
  S as ReferenceAdapter,
  A as RenameAdapter,
  v as SignatureHelpAdapter,
  g as SuggestAdapter,
  l as WorkerManager,
  d as flattenDiagnosticMessageText,
  I as getJavaScriptWorker,
  L as getTypeScriptWorker,
  F as setupJavaScript,
  P as setupTypeScript
};
