if (Array.prototype.find || (Array.prototype.find = function(e3) {
  if (this === null) throw TypeError(`Array.prototype.find called on null or undefined`);
  if (typeof e3 != `function`) throw TypeError(`predicate must be a function`);
  for (var t2 = Object(this), n2 = t2.length >>> 0, r2 = arguments[1], i3, a2 = 0; a2 < n2; a2++) if (i3 = t2[a2], e3.call(r2, i3, a2, t2)) return i3;
}), window && typeof window.CustomEvent != `function`) {
  let e3 = function(e4, t2) {
    t2 || (t2 = { bubbles: false, cancelable: false, detail: void 0 });
    var n2 = document.createEvent(`CustomEvent`);
    return n2.initCustomEvent(e4, t2.bubbles, t2.cancelable, t2.detail), n2;
  };
  window.Event !== void 0 && (e3.prototype = window.Event.prototype), window.CustomEvent = e3;
}
var e = class e2 {
  constructor(e3) {
    this.tribute = e3, this.tribute.events = this;
  }
  static keys() {
    return [{ key: 9, value: `TAB` }, { key: 8, value: `DELETE` }, { key: 13, value: `ENTER` }, { key: 27, value: `ESCAPE` }, { key: 32, value: `SPACE` }, { key: 38, value: `UP` }, { key: 40, value: `DOWN` }];
  }
  bind(e3) {
    e3.boundKeydown = this.keydown.bind(e3, this), e3.boundKeyup = this.keyup.bind(e3, this), e3.boundInput = this.input.bind(e3, this), e3.addEventListener(`keydown`, e3.boundKeydown, false), e3.addEventListener(`keyup`, e3.boundKeyup, false), e3.addEventListener(`input`, e3.boundInput, false);
  }
  unbind(e3) {
    e3.removeEventListener(`keydown`, e3.boundKeydown, false), e3.removeEventListener(`keyup`, e3.boundKeyup, false), e3.removeEventListener(`input`, e3.boundInput, false), delete e3.boundKeydown, delete e3.boundKeyup, delete e3.boundInput;
  }
  keydown(t2, n2) {
    t2.shouldDeactivate(n2) && (t2.tribute.isActive = false, t2.tribute.hideMenu());
    let r2 = this;
    t2.commandEvent = false, e2.keys().forEach((e3) => {
      e3.key === n2.keyCode && (t2.commandEvent = true, t2.callbacks()[e3.value.toLowerCase()](n2, r2));
    });
  }
  input(e3, t2) {
    e3.inputEvent = true, e3.keyup.call(this, e3, t2);
  }
  click(e3, t2) {
    let n2 = e3.tribute;
    if (n2.menu && n2.menu.contains(t2.target)) {
      let e4 = t2.target;
      for (t2.preventDefault(), t2.stopPropagation(); e4.nodeName.toLowerCase() !== `li`; ) if (e4 = e4.parentNode, !e4 || e4 === n2.menu) throw Error(`cannot find the <li> container for the click`);
      n2.selectItemAtIndex(e4.getAttribute(`data-index`), t2), n2.hideMenu();
    } else n2.current.element && !n2.current.externalTrigger && (n2.current.externalTrigger = false, setTimeout(() => n2.hideMenu()));
  }
  keyup(e3, t2) {
    if (e3.inputEvent && (e3.inputEvent = false), e3.updateSelection(this), t2.keyCode !== 27) {
      if (!e3.tribute.allowSpaces && e3.tribute.hasTrailingSpace) {
        e3.tribute.hasTrailingSpace = false, e3.commandEvent = true, e3.callbacks().space(t2, this);
        return;
      }
      if (!e3.tribute.isActive) if (e3.tribute.autocompleteMode) e3.callbacks().triggerChar(t2, this, ``);
      else {
        let n2 = e3.getKeyCode(e3, this, t2);
        if (isNaN(n2) || !n2) return;
        let r2 = e3.tribute.triggers().find((e4) => e4.charCodeAt(0) === n2);
        r2 !== void 0 && e3.callbacks().triggerChar(t2, this, r2);
      }
      e3.tribute.current.mentionText.length < e3.tribute.current.collection.menuShowMinLength || ((e3.tribute.current.trigger || e3.tribute.autocompleteMode) && e3.commandEvent === false || e3.tribute.isActive && t2.keyCode === 8) && e3.tribute.showMenuFor(this, true);
    }
  }
  shouldDeactivate(t2) {
    if (!this.tribute.isActive) return false;
    if (this.tribute.current.mentionText.length === 0) {
      let n2 = false;
      return e2.keys().forEach((e3) => {
        t2.keyCode === e3.key && (n2 = true);
      }), !n2;
    }
    return false;
  }
  getKeyCode(e3, t2, n2) {
    let r2 = e3.tribute, i3 = r2.range.getTriggerInfo(false, r2.hasTrailingSpace, true, r2.allowSpaces, r2.autocompleteMode);
    return i3 ? i3.mentionTriggerChar.charCodeAt(0) : false;
  }
  updateSelection(e3) {
    this.tribute.current.element = e3;
    let t2 = this.tribute.range.getTriggerInfo(false, this.tribute.hasTrailingSpace, true, this.tribute.allowSpaces, this.tribute.autocompleteMode);
    t2 && (this.tribute.current.selectedPath = t2.mentionSelectedPath, this.tribute.current.mentionText = t2.mentionText, this.tribute.current.selectedOffset = t2.mentionSelectedOffset);
  }
  callbacks() {
    return { triggerChar: (e3, t2, n2) => {
      let r2 = this.tribute;
      r2.current.trigger = n2;
      let i3 = r2.collection.find((e4) => e4.trigger === n2);
      r2.current.collection = i3, r2.current.mentionText.length >= r2.current.collection.menuShowMinLength && r2.inputEvent && r2.showMenuFor(t2, true);
    }, enter: (e3, t2) => {
      this.tribute.isActive && this.tribute.current.filteredItems && (e3.preventDefault(), e3.stopPropagation(), setTimeout(() => {
        this.tribute.selectItemAtIndex(this.tribute.menuSelected, e3), this.tribute.hideMenu();
      }, 0));
    }, escape: (e3, t2) => {
      this.tribute.isActive && (e3.preventDefault(), e3.stopPropagation(), this.tribute.isActive = false, this.tribute.hideMenu());
    }, tab: (e3, t2) => {
      this.callbacks().enter(e3, t2);
    }, space: (e3, t2) => {
      this.tribute.isActive && (this.tribute.spaceSelectsMatch ? this.callbacks().enter(e3, t2) : this.tribute.allowSpaces || (e3.stopPropagation(), setTimeout(() => {
        this.tribute.hideMenu(), this.tribute.isActive = false;
      }, 0)));
    }, up: (e3, t2) => {
      if (this.tribute.isActive && this.tribute.current.filteredItems) {
        e3.preventDefault(), e3.stopPropagation();
        let t3 = this.tribute.current.filteredItems.length, n2 = this.tribute.menuSelected;
        t3 > n2 && n2 > 0 ? (this.tribute.menuSelected--, this.setActiveLi()) : n2 === 0 && (this.tribute.menuSelected = t3 - 1, this.setActiveLi(), this.tribute.menu.scrollTop = this.tribute.menu.scrollHeight);
      }
    }, down: (e3, t2) => {
      if (this.tribute.isActive && this.tribute.current.filteredItems) {
        e3.preventDefault(), e3.stopPropagation();
        let t3 = this.tribute.current.filteredItems.length - 1, n2 = this.tribute.menuSelected;
        t3 > n2 ? (this.tribute.menuSelected++, this.setActiveLi()) : t3 === n2 && (this.tribute.menuSelected = 0, this.setActiveLi(), this.tribute.menu.scrollTop = 0);
      }
    }, delete: (e3, t2) => {
      this.tribute.isActive && this.tribute.current.mentionText.length < 1 ? this.tribute.hideMenu() : this.tribute.isActive && this.tribute.showMenuFor(t2);
    } };
  }
  setActiveLi(e3) {
    let t2 = this.tribute.menu.querySelectorAll(`li`), n2 = t2.length >>> 0;
    e3 && (this.tribute.menuSelected = parseInt(e3));
    for (let e4 = 0; e4 < n2; e4++) {
      let n3 = t2[e4];
      if (e4 === this.tribute.menuSelected) {
        n3.classList.add(this.tribute.current.collection.selectClass);
        let e5 = n3.getBoundingClientRect(), t3 = this.tribute.menu.getBoundingClientRect();
        if (e5.bottom > t3.bottom) {
          let n4 = e5.bottom - t3.bottom;
          this.tribute.menu.scrollTop += n4;
        } else if (e5.top < t3.top) {
          let n4 = t3.top - e5.top;
          this.tribute.menu.scrollTop -= n4;
        }
      } else n3.classList.remove(this.tribute.current.collection.selectClass);
    }
  }
  getFullHeight(e3, t2) {
    let n2 = e3.getBoundingClientRect().height;
    if (t2) {
      let t3 = e3.currentStyle || window.getComputedStyle(e3);
      return n2 + parseFloat(t3.marginTop) + parseFloat(t3.marginBottom);
    }
    return n2;
  }
}, t = class {
  constructor(e3) {
    this.tribute = e3, this.tribute.menuEvents = this, this.menu = this.tribute.menu;
  }
  bind(e3) {
    this.menuClickEvent = this.tribute.events.click.bind(null, this), this.menuContainerScrollEvent = this.debounce(() => {
      this.tribute.isActive && this.tribute.hideMenu();
    }, 10, false), this.windowResizeEvent = this.debounce(() => {
      this.tribute.isActive && this.tribute.hideMenu();
    }, 10, false), this.tribute.range.getDocument().addEventListener(`MSPointerDown`, this.menuClickEvent, false), this.tribute.range.getDocument().addEventListener(`mousedown`, this.menuClickEvent, false), window.addEventListener(`resize`, this.windowResizeEvent), this.menuContainer ? this.menuContainer.addEventListener(`scroll`, this.menuContainerScrollEvent, false) : window.addEventListener(`scroll`, this.menuContainerScrollEvent);
  }
  unbind(e3) {
    this.tribute.range.getDocument().removeEventListener(`mousedown`, this.menuClickEvent, false), this.tribute.range.getDocument().removeEventListener(`MSPointerDown`, this.menuClickEvent, false), window.removeEventListener(`resize`, this.windowResizeEvent), this.menuContainer ? this.menuContainer.removeEventListener(`scroll`, this.menuContainerScrollEvent, false) : window.removeEventListener(`scroll`, this.menuContainerScrollEvent);
  }
  debounce(e3, t2, n2) {
    var r2;
    return () => {
      var i3 = this, a2 = arguments, o = () => {
        r2 = null, n2 || e3.apply(i3, a2);
      }, s = n2 && !r2;
      clearTimeout(r2), r2 = setTimeout(o, t2), s && e3.apply(i3, a2);
    };
  }
}, n = class {
  constructor(e3) {
    this.tribute = e3, this.tribute.range = this;
  }
  getDocument() {
    let e3;
    return this.tribute.current.collection && (e3 = this.tribute.current.collection.iframe), e3 ? e3.contentWindow.document : document;
  }
  positionMenuAtCaret(e3) {
    let t2 = this.tribute.current, n2, r2 = this.getTriggerInfo(false, this.tribute.hasTrailingSpace, true, this.tribute.allowSpaces, this.tribute.autocompleteMode);
    if (r2 !== void 0) {
      if (!this.tribute.positionMenu) {
        this.tribute.menu.style.cssText = `display: block;`;
        return;
      }
      n2 = this.isContentEditable(t2.element) ? this.getContentEditableCaretPosition(r2.mentionPosition) : this.getTextAreaOrInputUnderlinePosition(this.tribute.current.element, r2.mentionPosition), this.tribute.menu.style.cssText = `top: ${n2.top}px;
                                     left: ${n2.left}px;
                                     right: ${n2.right}px;
                                     bottom: ${n2.bottom}px;
                                     max-height: ${n2.maxHeight || 500}px;
                                     max-width: ${n2.maxWidth || 300}px;
                                     position: ${n2.position || `absolute`};
                                     display: block;`, n2.left === `auto` && (this.tribute.menu.style.left = `auto`), n2.top === `auto` && (this.tribute.menu.style.top = `auto`), e3 && this.scrollIntoView();
    } else this.tribute.menu.style.cssText = `display: none`;
  }
  get menuContainerIsBody() {
    return this.tribute.menuContainer === document.body || !this.tribute.menuContainer;
  }
  selectElement(e3, t2, n2) {
    let r2, i3 = e3;
    if (t2) for (var a2 = 0; a2 < t2.length; a2++) {
      if (i3 = i3.childNodes[t2[a2]], i3 === void 0) return;
      for (; i3.length < n2; ) n2 -= i3.length, i3 = i3.nextSibling;
      i3.childNodes.length === 0 && !i3.length && (i3 = i3.previousSibling);
    }
    let o = this.getWindowSelection();
    r2 = this.getDocument().createRange(), r2.setStart(i3, n2), r2.setEnd(i3, n2), r2.collapse(true);
    try {
      o.removeAllRanges();
    } catch {
    }
    o.addRange(r2), e3.focus();
  }
  replaceTriggerText(e3, t2, n2, r2, i3) {
    let a2 = this.getTriggerInfo(true, n2, t2, this.tribute.allowSpaces, this.tribute.autocompleteMode);
    if (a2 !== void 0) {
      let t3 = this.tribute.current, n3 = new CustomEvent(`tribute-replaced`, { detail: { item: i3, instance: t3, context: a2, event: r2 } });
      if (this.isContentEditable(t3.element)) {
        let t4 = typeof this.tribute.replaceTextSuffix == `string` ? this.tribute.replaceTextSuffix : `\xA0`;
        e3 += t4;
        let n4 = a2.mentionPosition + a2.mentionText.length;
        this.tribute.autocompleteMode || (n4 += a2.mentionTriggerChar.length), this.pasteHtml(e3, a2.mentionPosition, n4);
      } else {
        let t4 = this.tribute.current.element, n4 = typeof this.tribute.replaceTextSuffix == `string` ? this.tribute.replaceTextSuffix : ` `;
        e3 += n4;
        let r3 = a2.mentionPosition, i4 = a2.mentionPosition + a2.mentionText.length + n4.length;
        this.tribute.autocompleteMode || (i4 += a2.mentionTriggerChar.length - 1), t4.value = t4.value.substring(0, r3) + e3 + t4.value.substring(i4, t4.value.length), t4.selectionStart = r3 + e3.length, t4.selectionEnd = r3 + e3.length;
      }
      t3.element.dispatchEvent(new CustomEvent(`input`, { bubbles: true })), t3.element.dispatchEvent(n3);
    }
  }
  pasteHtml(e3, t2, n2) {
    let r2, i3;
    i3 = this.getWindowSelection(), r2 = this.getDocument().createRange(), r2.setStart(i3.anchorNode, t2), r2.setEnd(i3.anchorNode, n2), r2.deleteContents();
    let a2 = this.getDocument().createElement(`div`);
    a2.innerHTML = e3;
    let o = this.getDocument().createDocumentFragment(), s, c;
    for (; s = a2.firstChild; ) c = o.appendChild(s);
    r2.insertNode(o), c && (r2 = r2.cloneRange(), r2.setStartAfter(c), r2.collapse(true), i3.removeAllRanges(), i3.addRange(r2));
  }
  getWindowSelection() {
    return this.tribute.collection.iframe ? this.tribute.collection.iframe.contentWindow.getSelection() : window.getSelection();
  }
  getNodePositionInParent(e3) {
    if (e3.parentNode === null) return 0;
    for (var t2 = 0; t2 < e3.parentNode.childNodes.length; t2++) {
      let n2 = e3.parentNode.childNodes[t2];
      if (n2 === e3) return t2;
    }
  }
  getContentEditableSelectedPath(e3) {
    let t2 = this.getWindowSelection(), n2 = t2.anchorNode, r2 = [], i3;
    if (n2 != null) {
      let e4, a2 = n2.contentEditable;
      for (; n2 !== null && a2 !== `true`; ) e4 = this.getNodePositionInParent(n2), r2.push(e4), n2 = n2.parentNode, n2 !== null && (a2 = n2.contentEditable);
      return r2.reverse(), i3 = t2.getRangeAt(0).startOffset, { selected: n2, path: r2, offset: i3 };
    }
  }
  getTextPrecedingCurrentSelection() {
    let e3 = this.tribute.current, t2 = ``;
    if (this.isContentEditable(e3.element)) {
      let e4 = this.getWindowSelection().anchorNode;
      if (e4 != null) {
        let n2 = e4.textContent, r2 = this.getWindowSelection().getRangeAt(0).startOffset;
        n2 && r2 >= 0 && (t2 = n2.substring(0, r2));
      }
    } else {
      let e4 = this.tribute.current.element;
      if (e4) {
        let n2 = e4.selectionStart;
        e4.value && n2 >= 0 && (t2 = e4.value.substring(0, n2));
      }
    }
    return t2;
  }
  getLastWordInText(e3) {
    e3 = e3.replace(/\u00A0/g, ` `);
    var t2;
    t2 = this.tribute.autocompleteSeparator ? e3.split(this.tribute.autocompleteSeparator) : e3.split(/\s+/);
    var n2 = t2.length - 1;
    return t2[n2].trim();
  }
  getTriggerInfo(e3, t2, n2, r2, i3) {
    let a2 = this.tribute.current, o, s, c;
    if (!this.isContentEditable(a2.element)) o = this.tribute.current.element;
    else {
      let e4 = this.getContentEditableSelectedPath(a2);
      e4 && (o = e4.selected, s = e4.path, c = e4.offset);
    }
    let l = this.getTextPrecedingCurrentSelection(), u = this.getLastWordInText(l);
    if (i3) return { mentionPosition: l.length - u.length, mentionText: u, mentionSelectedElement: o, mentionSelectedPath: s, mentionSelectedOffset: c };
    if (l != null) {
      let i4 = -1, a3;
      if (this.tribute.collection.forEach((e4) => {
        let t3 = e4.trigger, r3 = e4.requireLeadingSpace ? this.lastIndexWithLeadingSpace(l, t3) : l.lastIndexOf(t3);
        r3 > i4 && (i4 = r3, a3 = t3, n2 = e4.requireLeadingSpace);
      }), i4 >= 0 && (i4 === 0 || !n2 || /[\xA0\s]/g.test(l.substring(i4 - 1, i4)))) {
        let n3 = l.substring(i4 + a3.length, l.length);
        a3 = l.substring(i4, i4 + a3.length);
        let u2 = n3.substring(0, 1), d = n3.length > 0 && (u2 === ` ` || u2 === `\xA0`);
        t2 && (n3 = n3.trim());
        let f = r2 ? /[^\S ]/g : /[\xA0\s]/g;
        if (this.tribute.hasTrailingSpace = f.test(n3), !d && (e3 || !f.test(n3))) return { mentionPosition: i4, mentionText: n3, mentionSelectedElement: o, mentionSelectedPath: s, mentionSelectedOffset: c, mentionTriggerChar: a3 };
      }
    }
  }
  lastIndexWithLeadingSpace(e3, t2) {
    let n2 = e3.split(``).reverse().join(``), r2 = -1;
    for (let i3 = 0, a2 = e3.length; i3 < a2; i3++) {
      let a3 = i3 === e3.length - 1, o = /\s/.test(n2[i3 + 1]), s = true;
      for (let e4 = t2.length - 1; e4 >= 0; e4--) if (t2[e4] !== n2[i3 - e4]) {
        s = false;
        break;
      }
      if (s && (a3 || o)) {
        r2 = e3.length - 1 - i3;
        break;
      }
    }
    return r2;
  }
  isContentEditable(e3) {
    return e3.nodeName !== `INPUT` && e3.nodeName !== `TEXTAREA`;
  }
  isMenuOffScreen(e3, t2) {
    let n2 = window.innerWidth, r2 = window.innerHeight, i3 = document.documentElement, a2 = (window.pageXOffset || i3.scrollLeft) - (i3.clientLeft || 0), o = (window.pageYOffset || i3.scrollTop) - (i3.clientTop || 0), s = typeof e3.top == `number` ? e3.top : o + r2 - e3.bottom - t2.height, c = typeof e3.right == `number` ? e3.right : e3.left + t2.width, l = typeof e3.bottom == `number` ? e3.bottom : e3.top + t2.height, u = typeof e3.left == `number` ? e3.left : a2 + n2 - e3.right - t2.width;
    return { top: s < Math.floor(o), right: c > Math.ceil(a2 + n2), bottom: l > Math.ceil(o + r2), left: u < Math.floor(a2) };
  }
  getMenuDimensions() {
    let e3 = { width: null, height: null };
    return this.tribute.menu.style.cssText = `top: 0px;
                                 left: 0px;
                                 position: fixed;
                                 display: block;
                                 visibility; hidden;
                                 max-height:500px;`, e3.width = this.tribute.menu.offsetWidth, e3.height = this.tribute.menu.offsetHeight, this.tribute.menu.style.cssText = `display: none;`, e3;
  }
  getTextAreaOrInputUnderlinePosition(e3, t2, n2) {
    let r2 = `direction.boxSizing.width.height.overflowX.overflowY.borderTopWidth.borderRightWidth.borderBottomWidth.borderLeftWidth.borderStyle.paddingTop.paddingRight.paddingBottom.paddingLeft.fontStyle.fontVariant.fontWeight.fontStretch.fontSize.fontSizeAdjust.lineHeight.fontFamily.textAlign.textTransform.textIndent.textDecoration.letterSpacing.wordSpacing`.split(`.`), i3 = this.getDocument().createElement(`div`);
    i3.id = `input-textarea-caret-position-mirror-div`, this.getDocument().body.appendChild(i3);
    let a2 = i3.style, o = window.getComputedStyle ? getComputedStyle(e3) : e3.currentStyle;
    a2.whiteSpace = `pre-wrap`, e3.nodeName !== `INPUT` && (a2.wordWrap = `break-word`), a2.position = `absolute`, a2.visibility = `hidden`, r2.forEach((e4) => {
      a2[e4] = o[e4];
    });
    let s = document.createElement(`span`);
    s.textContent = e3.value.substring(0, t2), i3.appendChild(s), e3.nodeName === `INPUT` && (i3.textContent = i3.textContent.replace(/\s/g, `\xA0`));
    let c = this.getDocument().createElement(`span`);
    c.textContent = `&#x200B;`, i3.appendChild(c);
    let l = this.getDocument().createElement(`span`);
    l.textContent = e3.value.substring(t2), i3.appendChild(l);
    let u = e3.getBoundingClientRect();
    i3.style.position = `fixed`, i3.style.left = u.left + `px`, i3.style.top = u.top + `px`, i3.style.width = u.width + `px`, i3.style.height = u.height + `px`, i3.scrollTop = e3.scrollTop;
    var d = c.getBoundingClientRect();
    return this.getDocument().body.removeChild(i3), this.getFixedCoordinatesRelativeToRect(d);
  }
  getContentEditableCaretPosition(e3) {
    let t2, n2 = this.getWindowSelection();
    t2 = this.getDocument().createRange(), t2.setStart(n2.anchorNode, e3), t2.setEnd(n2.anchorNode, e3), t2.collapse(false);
    let r2 = t2.getBoundingClientRect();
    return this.getFixedCoordinatesRelativeToRect(r2);
  }
  getFixedCoordinatesRelativeToRect(e3) {
    let t2 = { position: `fixed`, left: e3.left, top: e3.top + e3.height }, n2 = this.getMenuDimensions();
    var r2 = e3.top, i3 = window.innerHeight - (e3.top + e3.height);
    i3 < n2.height && (r2 >= n2.height || r2 > i3 ? (t2.top = `auto`, t2.bottom = window.innerHeight - e3.top, i3 < n2.height && (t2.maxHeight = r2)) : r2 < n2.height && (t2.maxHeight = i3));
    var a2 = e3.left, o = window.innerWidth - e3.left;
    return o < n2.width && (a2 >= n2.width || a2 > o ? (t2.left = `auto`, t2.right = window.innerWidth - e3.left, o < n2.width && (t2.maxWidth = a2)) : a2 < n2.width && (t2.maxWidth = o)), t2;
  }
  scrollIntoView(e3) {
    let t2 = 20, n2, r2 = 100, i3 = this.menu;
    if (i3 === void 0) return;
    for (; n2 === void 0 || n2.height === 0; ) if (n2 = i3.getBoundingClientRect(), n2.height === 0 && (i3 = i3.childNodes[0], i3 === void 0 || !i3.getBoundingClientRect)) return;
    let a2 = n2.top, o = a2 + n2.height;
    if (a2 < 0) window.scrollTo(0, window.pageYOffset + n2.top - t2);
    else if (o > window.innerHeight) {
      let e4 = window.pageYOffset + n2.top - t2;
      e4 - window.pageYOffset > r2 && (e4 = window.pageYOffset + r2);
      let i4 = window.pageYOffset - (window.innerHeight - o);
      i4 > e4 && (i4 = e4), window.scrollTo(0, i4);
    }
  }
}, r = class {
  constructor(e3) {
    this.tribute = e3, this.tribute.search = this;
  }
  simpleFilter(e3, t2) {
    return t2.filter((t3) => this.test(e3, t3));
  }
  test(e3, t2) {
    return this.match(e3, t2) !== null;
  }
  match(e3, t2, n2) {
    n2 || (n2 = {});
    let r2 = t2.length, i3 = n2.pre || ``, a2 = n2.post || ``, o = n2.caseSensitive && t2 || t2.toLowerCase();
    if (n2.skip) return { rendered: t2, score: 0 };
    e3 = n2.caseSensitive && e3 || e3.toLowerCase();
    let s = this.traverse(o, e3, 0, 0, []);
    return s ? { rendered: this.render(t2, s.cache, i3, a2), score: s.score } : null;
  }
  traverse(e3, t2, n2, r2, i3) {
    if (this.tribute.autocompleteSeparator && (t2 = t2.split(this.tribute.autocompleteSeparator).splice(-1)[0]), t2.length === r2) return { score: this.calculateScore(i3), cache: i3.slice() };
    if (e3.length === n2 || t2.length - r2 > e3.length - n2) return;
    let a2 = t2[r2], o = e3.indexOf(a2, n2), s, c;
    for (; o > -1; ) {
      if (i3.push(o), c = this.traverse(e3, t2, o + 1, r2 + 1, i3), i3.pop(), !c) return s;
      (!s || s.score < c.score) && (s = c), o = e3.indexOf(a2, o + 1);
    }
    return s;
  }
  calculateScore(e3) {
    let t2 = 0, n2 = 1;
    return e3.forEach((r2, i3) => {
      i3 > 0 && (e3[i3 - 1] + 1 === r2 ? n2 += n2 + 1 : n2 = 1), t2 += n2;
    }), t2;
  }
  render(e3, t2, n2, r2) {
    var i3 = e3.substring(0, t2[0]);
    return t2.forEach((a2, o) => {
      i3 += n2 + e3[a2] + r2 + e3.substring(a2 + 1, t2[o + 1] ? t2[o + 1] : e3.length);
    }), i3;
  }
  filter(e3, t2, n2) {
    return n2 || (n2 = {}), t2.reduce((t3, r2, i3, a2) => {
      let o = r2;
      n2.extract && (o = n2.extract(r2), o || (o = ``));
      let s = this.match(e3, o, n2);
      return s != null && (t3[t3.length] = { string: s.rendered, score: s.score, index: i3, original: r2 }), t3;
    }, []).sort((e4, t3) => {
      let n3 = t3.score - e4.score;
      return n3 || e4.index - t3.index;
    });
  }
}, i = class i2 {
  constructor({ values: a2 = null, loadingItemTemplate: o = null, iframe: s = null, selectClass: c = `highlight`, containerClass: l = `tribute-container`, itemClass: u = ``, trigger: d = `@`, autocompleteMode: f = false, autocompleteSeparator: p = null, selectTemplate: m = null, menuItemTemplate: h = null, lookup: g = `key`, fillAttr: _ = `value`, collection: v = null, menuContainer: y = null, noMatchTemplate: b = null, requireLeadingSpace: x = true, allowSpaces: S = false, replaceTextSuffix: C = null, positionMenu: w = true, spaceSelectsMatch: T = false, searchOpts: E = {}, menuItemLimit: D = null, menuShowMinLength: O = 0 }) {
    if (this.autocompleteMode = f, this.autocompleteSeparator = p, this.menuSelected = 0, this.current = {}, this.inputEvent = false, this.isActive = false, this.menuContainer = y, this.allowSpaces = S, this.replaceTextSuffix = C, this.positionMenu = w, this.hasTrailingSpace = false, this.spaceSelectsMatch = T, this.autocompleteMode && (d = ``, S = false), a2) this.collection = [{ trigger: d, iframe: s, selectClass: c, containerClass: l, itemClass: u, selectTemplate: (m || i2.defaultSelectTemplate).bind(this), menuItemTemplate: (h || i2.defaultMenuItemTemplate).bind(this), noMatchTemplate: ((e3) => typeof e3 == `string` ? e3.trim() === `` ? null : e3 : typeof e3 == `function` ? e3.bind(this) : b || (function() {
      return `<li>No Match Found!</li>`;
    }).bind(this))(b), lookup: g, fillAttr: _, values: a2, loadingItemTemplate: o, requireLeadingSpace: x, searchOpts: E, menuItemLimit: D, menuShowMinLength: O }];
    else if (v) this.autocompleteMode && console.warn(`Tribute in autocomplete mode does not work for collections`), this.collection = v.map((e3) => ({ trigger: e3.trigger || d, iframe: e3.iframe || s, selectClass: e3.selectClass || c, containerClass: e3.containerClass || l, itemClass: e3.itemClass || u, selectTemplate: (e3.selectTemplate || i2.defaultSelectTemplate).bind(this), menuItemTemplate: (e3.menuItemTemplate || i2.defaultMenuItemTemplate).bind(this), noMatchTemplate: ((e4) => typeof e4 == `string` ? e4.trim() === `` ? null : e4 : typeof e4 == `function` ? e4.bind(this) : b || (function() {
      return `<li>No Match Found!</li>`;
    }).bind(this))(b), lookup: e3.lookup || g, fillAttr: e3.fillAttr || _, values: e3.values, loadingItemTemplate: e3.loadingItemTemplate, requireLeadingSpace: e3.requireLeadingSpace, searchOpts: e3.searchOpts || E, menuItemLimit: e3.menuItemLimit || D, menuShowMinLength: e3.menuShowMinLength || O }));
    else throw Error(`[Tribute] No collection specified.`);
    new n(this), new e(this), new t(this), new r(this);
  }
  get isActive() {
    return this._isActive;
  }
  set isActive(e3) {
    if (this._isActive != e3 && (this._isActive = e3, this.current.element)) {
      let t2 = new CustomEvent(`tribute-active-${e3}`);
      this.current.element.dispatchEvent(t2);
    }
  }
  static defaultSelectTemplate(e3) {
    return e3 === void 0 ? `${this.current.collection.trigger}${this.current.mentionText}` : this.range.isContentEditable(this.current.element) ? `<span class="tribute-mention">` + (this.current.collection.trigger + e3.original[this.current.collection.fillAttr]) + `</span>` : this.current.collection.trigger + e3.original[this.current.collection.fillAttr];
  }
  static defaultMenuItemTemplate(e3) {
    return e3.string;
  }
  static inputTypes() {
    return [`TEXTAREA`, `INPUT`];
  }
  triggers() {
    return this.collection.map((e3) => e3.trigger);
  }
  attach(e3) {
    if (!e3) throw Error(`[Tribute] Must pass in a DOM node or NodeList.`);
    if (typeof jQuery < `u` && e3 instanceof jQuery && (e3 = e3.get()), e3.constructor === NodeList || e3.constructor === HTMLCollection || e3.constructor === Array) {
      let n2 = e3.length;
      for (var t2 = 0; t2 < n2; ++t2) this._attach(e3[t2]);
    } else this._attach(e3);
  }
  _attach(e3) {
    e3.hasAttribute(`data-tribute`) && console.warn(`Tribute was already bound to ` + e3.nodeName), this.ensureEditable(e3), this.events.bind(e3), e3.setAttribute(`data-tribute`, true);
  }
  ensureEditable(e3) {
    if (i2.inputTypes().indexOf(e3.nodeName) === -1) if (e3.contentEditable) e3.contentEditable = true;
    else throw Error(`[Tribute] Cannot bind to ` + e3.nodeName);
  }
  createMenu(e3) {
    let t2 = this.range.getDocument().createElement(`div`), n2 = this.range.getDocument().createElement(`ul`);
    return t2.className = e3, t2.appendChild(n2), this.menuContainer ? this.menuContainer.appendChild(t2) : this.range.getDocument().body.appendChild(t2);
  }
  showMenuFor(e3, t2) {
    if (this.isActive && this.current.element === e3 && this.current.mentionText === this.currentMentionTextSnapshot) return;
    this.currentMentionTextSnapshot = this.current.mentionText, this.menu || (this.menu = this.createMenu(this.current.collection.containerClass), e3.tributeMenu = this.menu, this.menuEvents.bind(this.menu)), this.isActive = true, this.menuSelected = 0, this.current.mentionText || (this.current.mentionText = ``);
    let n2 = (e4) => {
      if (!this.isActive) return;
      let n3 = this.search.filter(this.current.mentionText, e4, { pre: this.current.collection.searchOpts.pre || `<span>`, post: this.current.collection.searchOpts.post || `</span>`, skip: this.current.collection.searchOpts.skip, extract: (e5) => {
        if (typeof this.current.collection.lookup == `string`) return e5[this.current.collection.lookup];
        if (typeof this.current.collection.lookup == `function`) return this.current.collection.lookup(e5, this.current.mentionText);
        throw Error(`Invalid lookup attribute, lookup must be string or function.`);
      } });
      this.current.collection.menuItemLimit && (n3 = n3.slice(0, this.current.collection.menuItemLimit)), this.current.filteredItems = n3;
      let r2 = this.menu.querySelector(`ul`);
      if (!n3.length) {
        let e5 = new CustomEvent(`tribute-no-match`, { detail: this.menu });
        this.current.element.dispatchEvent(e5), typeof this.current.collection.noMatchTemplate == `function` && !this.current.collection.noMatchTemplate() || !this.current.collection.noMatchTemplate ? this.hideMenu() : (typeof this.current.collection.noMatchTemplate == `function` ? r2.innerHTML = this.current.collection.noMatchTemplate() : r2.innerHTML = this.current.collection.noMatchTemplate, this.range.positionMenuAtCaret(t2));
        return;
      }
      r2.innerHTML = ``;
      let i3 = this.range.getDocument().createDocumentFragment();
      n3.forEach((e5, t3) => {
        let n4 = this.range.getDocument().createElement(`li`);
        n4.setAttribute(`data-index`, t3), n4.className = this.current.collection.itemClass, n4.addEventListener(`mousemove`, (e6) => {
          let [t4, n5] = this._findLiTarget(e6.target);
          e6.movementY !== 0 && this.events.setActiveLi(n5);
        }), this.menuSelected === t3 && n4.classList.add(this.current.collection.selectClass), n4.innerHTML = this.current.collection.menuItemTemplate(e5), i3.appendChild(n4);
      }), r2.appendChild(i3), this.range.positionMenuAtCaret(t2);
    };
    typeof this.current.collection.values == `function` ? (this.current.collection.loadingItemTemplate && (this.menu.querySelector(`ul`).innerHTML = this.current.collection.loadingItemTemplate, this.range.positionMenuAtCaret(t2)), this.current.collection.values(this.current.mentionText, n2)) : n2(this.current.collection.values);
  }
  _findLiTarget(e3) {
    if (!e3) return [];
    let t2 = e3.getAttribute(`data-index`);
    return t2 ? [e3, t2] : this._findLiTarget(e3.parentNode);
  }
  showMenuForCollection(e3, t2) {
    e3 !== document.activeElement && this.placeCaretAtEnd(e3), this.current.collection = this.collection[t2 || 0], this.current.externalTrigger = true, this.current.element = e3, e3.isContentEditable ? this.insertTextAtCursor(this.current.collection.trigger) : this.insertAtCaret(e3, this.current.collection.trigger), this.showMenuFor(e3);
  }
  placeCaretAtEnd(e3) {
    if (e3.focus(), window.getSelection !== void 0 && document.createRange !== void 0) {
      var t2 = document.createRange();
      t2.selectNodeContents(e3), t2.collapse(false);
      var n2 = window.getSelection();
      n2.removeAllRanges(), n2.addRange(t2);
    } else if (document.body.createTextRange !== void 0) {
      var r2 = document.body.createTextRange();
      r2.moveToElementText(e3), r2.collapse(false), r2.select();
    }
  }
  insertTextAtCursor(e3) {
    var t2, n2;
    t2 = window.getSelection(), n2 = t2.getRangeAt(0), n2.deleteContents();
    var r2 = document.createTextNode(e3);
    n2.insertNode(r2), n2.selectNodeContents(r2), n2.collapse(false), t2.removeAllRanges(), t2.addRange(n2);
  }
  insertAtCaret(e3, t2) {
    var n2 = e3.scrollTop, r2 = e3.selectionStart, i3 = e3.value.substring(0, r2), a2 = e3.value.substring(e3.selectionEnd, e3.value.length);
    e3.value = i3 + t2 + a2, r2 += t2.length, e3.selectionStart = r2, e3.selectionEnd = r2, e3.focus(), e3.scrollTop = n2;
  }
  hideMenu() {
    this.menu && (this.menu.style.cssText = `display: none;`, this.isActive = false, this.menuSelected = 0, this.current = {});
  }
  selectItemAtIndex(e3, t2) {
    if (e3 = parseInt(e3), typeof e3 != `number` || isNaN(e3)) return;
    let n2 = this.current.filteredItems[e3], r2 = this.current.collection.selectTemplate(n2);
    r2 !== null && this.replaceText(r2, t2, n2);
  }
  replaceText(e3, t2, n2) {
    this.range.replaceTriggerText(e3, true, true, t2, n2);
  }
  _append(e3, t2, n2) {
    if (typeof e3.values == `function`) throw Error(`Unable to append to values, as it is a function.`);
    n2 ? e3.values = t2 : e3.values = e3.values.concat(t2);
  }
  append(e3, t2, n2) {
    let r2 = parseInt(e3);
    if (typeof r2 != `number`) throw Error(`please provide an index for the collection to update.`);
    let i3 = this.collection[r2];
    this._append(i3, t2, n2);
  }
  appendCurrent(e3, t2) {
    if (this.isActive) this._append(this.current.collection, e3, t2);
    else throw Error(`No active state. Please use append instead and pass an index.`);
  }
  detach(e3) {
    if (!e3) throw Error(`[Tribute] Must pass in a DOM node or NodeList.`);
    if (typeof jQuery < `u` && e3 instanceof jQuery && (e3 = e3.get()), e3.constructor === NodeList || e3.constructor === HTMLCollection || e3.constructor === Array) {
      let n2 = e3.length;
      for (var t2 = 0; t2 < n2; ++t2) this._detach(e3[t2]);
    } else this._detach(e3);
  }
  _detach(e3) {
    this.events.unbind(e3), e3.tributeMenu && this.menuEvents.unbind(e3.tributeMenu), setTimeout(() => {
      e3.removeAttribute(`data-tribute`), this.isActive = false, e3.tributeMenu && e3.tributeMenu.remove();
    });
  }
}, a = i;
export {
  a as tribute_esm_default
};
