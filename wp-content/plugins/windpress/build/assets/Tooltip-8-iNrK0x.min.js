import { Comment as e, Fragment as t, Teleport as n, camelize as r, computed as i, createBlock as a, createCommentVNode as o, createElementBlock as s, createTextVNode as c, createVNode as l, defineComponent as u, getCurrentInstance as d, getCurrentScope as f, guardReactiveProps as p, h as m, inject as h, mergeDefaults as g, mergeProps as _, nextTick as v, normalizeClass as y, normalizeProps as b, normalizeStyle as x, onMounted as S, onScopeDispose as ee, onUnmounted as C, openBlock as w, provide as T, reactive as te, ref as E, renderList as ne, renderSlot as D, resolveDynamicComponent as re, shallowReadonly as O, shallowRef as ie, toDisplayString as k, toHandlerKey as ae, toHandlers as oe, toRef as se, toRefs as ce, toValue as le, unref as A, useId as ue, useSlots as de, watch as j, watchEffect as M, watchPostEffect as fe, withCtx as N } from "./runtime-core.esm-bundler-CFIgNHFT.min.js";
import { vue_runtime_esm_bundler_exports as pe, withModifiers as me } from "./vue.runtime.esm-bundler-WcNVUy75.min.js";
import { Icon_default as he, Primitive as P, defu as ge, renderSlotFragments as _e, tv as F, useAppConfig as ve, useForwardProps as ye, useKbd as be } from "./Link-83qDN5tY.min.js";
import { reactivePick as xe } from "./core-DXhlFaDq.min.js";
import { arrow as Se, computePosition as Ce, createCoords as I, flip as we, floor as Te, hide as Ee, limitShift as De, max as L, min as Oe, offset as ke, rectToClientRect as Ae, round as je, shift as Me, size as Ne } from "./floating-ui.core-PLF1GSJg.min.js";
import { _sfc_main$14 as Pe, computedEager as Fe, createContext as R, createEventHook as Ie, defaultWindow as Le, isClient as Re, onKeyStroke as ze, refAutoReset as Be, unrefElement as Ve, useEventListener$1 as He, useForwardExpose as z, useMounted as Ue, useTimeoutFn as We, useVModel as Ge } from "./tv-CD-q12eC.min.js";
import { Avatar_default as Ke, useButtonGroup as qe, useComponentIcons as Je } from "./Button-DeZRGJ9-.min.js";
function Ye() {
  return typeof window < `u`;
}
function B(e2) {
  return Xe(e2) ? (e2.nodeName || ``).toLowerCase() : `#document`;
}
function V(e2) {
  var t2;
  return (e2 == null || (t2 = e2.ownerDocument) == null ? void 0 : t2.defaultView) || window;
}
function H(e2) {
  var _a;
  var t2;
  return (_a = t2 = (Xe(e2) ? e2.ownerDocument : e2.document) || window.document) == null ? void 0 : _a.documentElement;
}
function Xe(e2) {
  return Ye() ? e2 instanceof Node || e2 instanceof V(e2).Node : false;
}
function U(e2) {
  return Ye() ? e2 instanceof Element || e2 instanceof V(e2).Element : false;
}
function W(e2) {
  return Ye() ? e2 instanceof HTMLElement || e2 instanceof V(e2).HTMLElement : false;
}
function Ze(e2) {
  return !Ye() || typeof ShadowRoot > `u` ? false : e2 instanceof ShadowRoot || e2 instanceof V(e2).ShadowRoot;
}
function G(e2) {
  let { overflow: t2, overflowX: n2, overflowY: r2, display: i2 } = q(e2);
  return /auto|scroll|overlay|hidden|clip/.test(t2 + r2 + n2) && ![`inline`, `contents`].includes(i2);
}
function Qe(e2) {
  return [`table`, `td`, `th`].includes(B(e2));
}
function $e(e2) {
  return [`:popover-open`, `:modal`].some((t2) => {
    try {
      return e2.matches(t2);
    } catch {
      return false;
    }
  });
}
function et(e2) {
  let t2 = nt(), n2 = U(e2) ? q(e2) : e2;
  return [`transform`, `translate`, `scale`, `rotate`, `perspective`].some((e3) => n2[e3] ? n2[e3] !== `none` : false) || (n2.containerType ? n2.containerType !== `normal` : false) || !t2 && (n2.backdropFilter ? n2.backdropFilter !== `none` : false) || !t2 && (n2.filter ? n2.filter !== `none` : false) || [`transform`, `translate`, `scale`, `rotate`, `perspective`, `filter`].some((e3) => (n2.willChange || ``).includes(e3)) || [`paint`, `layout`, `strict`, `content`].some((e3) => (n2.contain || ``).includes(e3));
}
function tt(e2) {
  let t2 = J(e2);
  for (; W(t2) && !K(t2); ) {
    if (et(t2)) return t2;
    if ($e(t2)) return null;
    t2 = J(t2);
  }
  return null;
}
function nt() {
  return typeof CSS > `u` || !CSS.supports ? false : CSS.supports(`-webkit-backdrop-filter`, `none`);
}
function K(e2) {
  return [`html`, `body`, `#document`].includes(B(e2));
}
function q(e2) {
  return V(e2).getComputedStyle(e2);
}
function rt(e2) {
  return U(e2) ? { scrollLeft: e2.scrollLeft, scrollTop: e2.scrollTop } : { scrollLeft: e2.scrollX, scrollTop: e2.scrollY };
}
function J(e2) {
  if (B(e2) === `html`) return e2;
  let t2 = e2.assignedSlot || e2.parentNode || Ze(e2) && e2.host || H(e2);
  return Ze(t2) ? t2.host : t2;
}
function it(e2) {
  let t2 = J(e2);
  return K(t2) ? e2.ownerDocument ? e2.ownerDocument.body : e2.body : W(t2) && G(t2) ? t2 : it(t2);
}
function Y(e2, t2, n2) {
  var _a;
  var r2;
  t2 === void 0 && (t2 = []), n2 === void 0 && (n2 = true);
  let i2 = it(e2), a2 = i2 === ((_a = r2 = e2.ownerDocument) == null ? void 0 : _a.body), o2 = V(i2);
  if (a2) {
    let e3 = at(o2);
    return t2.concat(o2, o2.visualViewport || [], G(i2) ? i2 : [], e3 && n2 ? Y(e3) : []);
  }
  return t2.concat(i2, Y(i2, [], n2));
}
function at(e2) {
  return e2.parent && Object.getPrototypeOf(e2.parent) ? e2.frameElement : null;
}
function ot(e2) {
  let t2 = q(e2), n2 = parseFloat(t2.width) || 0, r2 = parseFloat(t2.height) || 0, i2 = W(e2), a2 = i2 ? e2.offsetWidth : n2, o2 = i2 ? e2.offsetHeight : r2, s2 = je(n2) !== a2 || je(r2) !== o2;
  return s2 && (n2 = a2, r2 = o2), { width: n2, height: r2, $: s2 };
}
function st(e2) {
  return U(e2) ? e2 : e2.contextElement;
}
function X(e2) {
  let t2 = st(e2);
  if (!W(t2)) return I(1);
  let n2 = t2.getBoundingClientRect(), { width: r2, height: i2, $: a2 } = ot(t2), o2 = (a2 ? je(n2.width) : n2.width) / r2, s2 = (a2 ? je(n2.height) : n2.height) / i2;
  return (!o2 || !Number.isFinite(o2)) && (o2 = 1), (!s2 || !Number.isFinite(s2)) && (s2 = 1), { x: o2, y: s2 };
}
const ct = I(0);
function lt(e2) {
  let t2 = V(e2);
  return !nt() || !t2.visualViewport ? ct : { x: t2.visualViewport.offsetLeft, y: t2.visualViewport.offsetTop };
}
function ut(e2, t2, n2) {
  return t2 === void 0 && (t2 = false), !n2 || t2 && n2 !== V(e2) ? false : t2;
}
function Z(e2, t2, n2, r2) {
  t2 === void 0 && (t2 = false), n2 === void 0 && (n2 = false);
  let i2 = e2.getBoundingClientRect(), a2 = st(e2), o2 = I(1);
  t2 && (r2 ? U(r2) && (o2 = X(r2)) : o2 = X(e2));
  let s2 = ut(a2, n2, r2) ? lt(a2) : I(0), c2 = (i2.left + s2.x) / o2.x, l2 = (i2.top + s2.y) / o2.y, u2 = i2.width / o2.x, d2 = i2.height / o2.y;
  if (a2) {
    let e3 = V(a2), t3 = r2 && U(r2) ? V(r2) : r2, n3 = e3, i3 = at(n3);
    for (; i3 && r2 && t3 !== n3; ) {
      let e4 = X(i3), t4 = i3.getBoundingClientRect(), r3 = q(i3), a3 = t4.left + (i3.clientLeft + parseFloat(r3.paddingLeft)) * e4.x, o3 = t4.top + (i3.clientTop + parseFloat(r3.paddingTop)) * e4.y;
      c2 *= e4.x, l2 *= e4.y, u2 *= e4.x, d2 *= e4.y, c2 += a3, l2 += o3, n3 = V(i3), i3 = at(n3);
    }
  }
  return Ae({ width: u2, height: d2, x: c2, y: l2 });
}
function dt(e2, t2) {
  let n2 = rt(e2).scrollLeft;
  return t2 ? t2.left + n2 : Z(H(e2)).left + n2;
}
function ft(e2, t2, n2) {
  n2 === void 0 && (n2 = false);
  let r2 = e2.getBoundingClientRect(), i2 = r2.left + t2.scrollLeft - (n2 ? 0 : dt(e2, r2)), a2 = r2.top + t2.scrollTop;
  return { x: i2, y: a2 };
}
function pt(e2) {
  let { elements: t2, rect: n2, offsetParent: r2, strategy: i2 } = e2, a2 = i2 === `fixed`, o2 = H(r2), s2 = t2 ? $e(t2.floating) : false;
  if (r2 === o2 || s2 && a2) return n2;
  let c2 = { scrollLeft: 0, scrollTop: 0 }, l2 = I(1), u2 = I(0), d2 = W(r2);
  if ((d2 || !d2 && !a2) && ((B(r2) !== `body` || G(o2)) && (c2 = rt(r2)), W(r2))) {
    let e3 = Z(r2);
    l2 = X(r2), u2.x = e3.x + r2.clientLeft, u2.y = e3.y + r2.clientTop;
  }
  let f2 = o2 && !d2 && !a2 ? ft(o2, c2, true) : I(0);
  return { width: n2.width * l2.x, height: n2.height * l2.y, x: n2.x * l2.x - c2.scrollLeft * l2.x + u2.x + f2.x, y: n2.y * l2.y - c2.scrollTop * l2.y + u2.y + f2.y };
}
function mt(e2) {
  return Array.from(e2.getClientRects());
}
function ht(e2) {
  let t2 = H(e2), n2 = rt(e2), r2 = e2.ownerDocument.body, i2 = L(t2.scrollWidth, t2.clientWidth, r2.scrollWidth, r2.clientWidth), a2 = L(t2.scrollHeight, t2.clientHeight, r2.scrollHeight, r2.clientHeight), o2 = -n2.scrollLeft + dt(e2), s2 = -n2.scrollTop;
  return q(r2).direction === `rtl` && (o2 += L(t2.clientWidth, r2.clientWidth) - i2), { width: i2, height: a2, x: o2, y: s2 };
}
function gt(e2, t2) {
  let n2 = V(e2), r2 = H(e2), i2 = n2.visualViewport, a2 = r2.clientWidth, o2 = r2.clientHeight, s2 = 0, c2 = 0;
  if (i2) {
    a2 = i2.width, o2 = i2.height;
    let e3 = nt();
    (!e3 || e3 && t2 === `fixed`) && (s2 = i2.offsetLeft, c2 = i2.offsetTop);
  }
  return { width: a2, height: o2, x: s2, y: c2 };
}
function _t(e2, t2) {
  let n2 = Z(e2, true, t2 === `fixed`), r2 = n2.top + e2.clientTop, i2 = n2.left + e2.clientLeft, a2 = W(e2) ? X(e2) : I(1), o2 = e2.clientWidth * a2.x, s2 = e2.clientHeight * a2.y, c2 = i2 * a2.x, l2 = r2 * a2.y;
  return { width: o2, height: s2, x: c2, y: l2 };
}
function vt(e2, t2, n2) {
  let r2;
  if (t2 === `viewport`) r2 = gt(e2, n2);
  else if (t2 === `document`) r2 = ht(H(e2));
  else if (U(t2)) r2 = _t(t2, n2);
  else {
    let n3 = lt(e2);
    r2 = { x: t2.x - n3.x, y: t2.y - n3.y, width: t2.width, height: t2.height };
  }
  return Ae(r2);
}
function yt(e2, t2) {
  let n2 = J(e2);
  return n2 === t2 || !U(n2) || K(n2) ? false : q(n2).position === `fixed` || yt(n2, t2);
}
function bt(e2, t2) {
  let n2 = t2.get(e2);
  if (n2) return n2;
  let r2 = Y(e2, [], false).filter((e3) => U(e3) && B(e3) !== `body`), i2 = null, a2 = q(e2).position === `fixed`, o2 = a2 ? J(e2) : e2;
  for (; U(o2) && !K(o2); ) {
    let t3 = q(o2), n3 = et(o2);
    !n3 && t3.position === `fixed` && (i2 = null);
    let s2 = a2 ? !n3 && !i2 : !n3 && t3.position === `static` && !!i2 && [`absolute`, `fixed`].includes(i2.position) || G(o2) && !n3 && yt(e2, o2);
    s2 ? r2 = r2.filter((e3) => e3 !== o2) : i2 = t3, o2 = J(o2);
  }
  return t2.set(e2, r2), r2;
}
function xt(e2) {
  let { element: t2, boundary: n2, rootBoundary: r2, strategy: i2 } = e2, a2 = n2 === `clippingAncestors` ? $e(t2) ? [] : bt(t2, this._c) : [].concat(n2), o2 = [...a2, r2], s2 = o2[0], c2 = o2.reduce((e3, n3) => {
    let r3 = vt(t2, n3, i2);
    return e3.top = L(r3.top, e3.top), e3.right = Oe(r3.right, e3.right), e3.bottom = Oe(r3.bottom, e3.bottom), e3.left = L(r3.left, e3.left), e3;
  }, vt(t2, s2, i2));
  return { width: c2.right - c2.left, height: c2.bottom - c2.top, x: c2.left, y: c2.top };
}
function St(e2) {
  let { width: t2, height: n2 } = ot(e2);
  return { width: t2, height: n2 };
}
function Ct(e2, t2, n2) {
  let r2 = W(t2), i2 = H(t2), a2 = n2 === `fixed`, o2 = Z(e2, true, a2, t2), s2 = { scrollLeft: 0, scrollTop: 0 }, c2 = I(0);
  function l2() {
    c2.x = dt(i2);
  }
  if (r2 || !r2 && !a2) if ((B(t2) !== `body` || G(i2)) && (s2 = rt(t2)), r2) {
    let e3 = Z(t2, true, a2, t2);
    c2.x = e3.x + t2.clientLeft, c2.y = e3.y + t2.clientTop;
  } else i2 && l2();
  a2 && !r2 && i2 && l2();
  let u2 = i2 && !r2 && !a2 ? ft(i2, s2) : I(0), d2 = o2.left + s2.scrollLeft - c2.x - u2.x, f2 = o2.top + s2.scrollTop - c2.y - u2.y;
  return { x: d2, y: f2, width: o2.width, height: o2.height };
}
function wt(e2) {
  return q(e2).position === `static`;
}
function Tt(e2, t2) {
  if (!W(e2) || q(e2).position === `fixed`) return null;
  if (t2) return t2(e2);
  let n2 = e2.offsetParent;
  return H(e2) === n2 && (n2 = n2.ownerDocument.body), n2;
}
function Et(e2, t2) {
  let n2 = V(e2);
  if ($e(e2)) return n2;
  if (!W(e2)) {
    let t3 = J(e2);
    for (; t3 && !K(t3); ) {
      if (U(t3) && !wt(t3)) return t3;
      t3 = J(t3);
    }
    return n2;
  }
  let r2 = Tt(e2, t2);
  for (; r2 && Qe(r2) && wt(r2); ) r2 = Tt(r2, t2);
  return r2 && K(r2) && wt(r2) && !et(r2) ? n2 : r2 || tt(e2) || n2;
}
const Dt = async function(e2) {
  let t2 = this.getOffsetParent || Et, n2 = this.getDimensions, r2 = await n2(e2.floating);
  return { reference: Ct(e2.reference, await t2(e2.floating), e2.strategy), floating: { x: 0, y: 0, width: r2.width, height: r2.height } };
};
function Ot(e2) {
  return q(e2).direction === `rtl`;
}
const kt = { convertOffsetParentRelativeRectToViewportRelativeRect: pt, getDocumentElement: H, getClippingRect: xt, getOffsetParent: Et, getElementRects: Dt, getClientRects: mt, getDimensions: St, getScale: X, isElement: U, isRTL: Ot };
function At(e2, t2) {
  return e2.x === t2.x && e2.y === t2.y && e2.width === t2.width && e2.height === t2.height;
}
function jt(e2, t2) {
  let n2 = null, r2, i2 = H(e2);
  function a2() {
    var e3;
    clearTimeout(r2), (e3 = n2) == null || e3.disconnect(), n2 = null;
  }
  function o2(s2, c2) {
    s2 === void 0 && (s2 = false), c2 === void 0 && (c2 = 1), a2();
    let l2 = e2.getBoundingClientRect(), { left: u2, top: d2, width: f2, height: p2 } = l2;
    if (s2 || t2(), !f2 || !p2) return;
    let m2 = Te(d2), h2 = Te(i2.clientWidth - (u2 + f2)), g2 = Te(i2.clientHeight - (d2 + p2)), _2 = Te(u2), v2 = -m2 + `px ` + -h2 + `px ` + -g2 + `px ` + -_2 + `px`, y2 = { rootMargin: v2, threshold: L(0, Oe(1, c2)) || 1 }, b2 = true;
    function x2(t3) {
      let n3 = t3[0].intersectionRatio;
      if (n3 !== c2) {
        if (!b2) return o2();
        n3 ? o2(false, n3) : r2 = setTimeout(() => {
          o2(false, 1e-7);
        }, 1e3);
      }
      n3 === 1 && !At(l2, e2.getBoundingClientRect()) && o2(), b2 = false;
    }
    try {
      n2 = new IntersectionObserver(x2, { ...y2, root: i2.ownerDocument });
    } catch {
      n2 = new IntersectionObserver(x2, y2);
    }
    n2.observe(e2);
  }
  return o2(true), a2;
}
function Mt(e2, t2, n2, r2) {
  r2 === void 0 && (r2 = {});
  let { ancestorScroll: i2 = true, ancestorResize: a2 = true, elementResize: o2 = typeof ResizeObserver == `function`, layoutShift: s2 = typeof IntersectionObserver == `function`, animationFrame: c2 = false } = r2, l2 = st(e2), u2 = i2 || a2 ? [...l2 ? Y(l2) : [], ...Y(t2)] : [];
  u2.forEach((e3) => {
    i2 && e3.addEventListener(`scroll`, n2, { passive: true }), a2 && e3.addEventListener(`resize`, n2);
  });
  let d2 = l2 && s2 ? jt(l2, n2) : null, f2 = -1, p2 = null;
  o2 && (p2 = new ResizeObserver((e3) => {
    let [r3] = e3;
    r3 && r3.target === l2 && p2 && (p2.unobserve(t2), cancelAnimationFrame(f2), f2 = requestAnimationFrame(() => {
      var e4;
      (e4 = p2) == null || e4.observe(t2);
    })), n2();
  }), l2 && !c2 && p2.observe(l2), p2.observe(t2));
  let m2, h2 = c2 ? Z(e2) : null;
  c2 && g2();
  function g2() {
    let t3 = Z(e2);
    h2 && !At(h2, t3) && n2(), h2 = t3, m2 = requestAnimationFrame(g2);
  }
  return n2(), () => {
    var e3;
    u2.forEach((e4) => {
      i2 && e4.removeEventListener(`scroll`, n2), a2 && e4.removeEventListener(`resize`, n2);
    }), d2 == null ? void 0 : d2(), (e3 = p2) == null || e3.disconnect(), p2 = null, c2 && cancelAnimationFrame(m2);
  };
}
const Nt = ke, Pt = Me, Ft = we, It = Ne, Lt = Ee, Rt = Se, zt = De, Bt = (e2, t2, n2) => {
  let r2 = /* @__PURE__ */ new Map(), i2 = { platform: kt, ...n2 }, a2 = { ...i2.platform, _c: r2 };
  return Ce(e2, t2, { ...i2, platform: a2 });
};
function Vt(e2) {
  return typeof e2 == `object` && !!e2 && `$el` in e2;
}
function Ht(e2) {
  if (Vt(e2)) {
    let t2 = e2.$el;
    return Xe(t2) && B(t2) === `#comment` ? null : t2;
  }
  return e2;
}
function Q(e2) {
  return typeof e2 == `function` ? e2() : A(e2);
}
function Ut(e2) {
  return { name: `arrow`, options: e2, fn(t2) {
    let n2 = Ht(Q(e2.element));
    return n2 == null ? {} : Rt({ element: n2, padding: e2.padding }).fn(t2);
  } };
}
function Wt(e2) {
  if (typeof window > `u`) return 1;
  let t2 = e2.ownerDocument.defaultView || window;
  return t2.devicePixelRatio || 1;
}
function Gt(e2, t2) {
  let n2 = Wt(e2);
  return Math.round(t2 * n2) / n2;
}
function Kt(e2, t2, n2) {
  n2 === void 0 && (n2 = {});
  let r2 = n2.whileElementsMounted, a2 = i(() => {
    var e3;
    return (e3 = Q(n2.open)) ?? true;
  }), o2 = i(() => Q(n2.middleware)), s2 = i(() => {
    var e3;
    return (e3 = Q(n2.placement)) ?? `bottom`;
  }), c2 = i(() => {
    var e3;
    return (e3 = Q(n2.strategy)) ?? `absolute`;
  }), l2 = i(() => {
    var e3;
    return (e3 = Q(n2.transform)) ?? true;
  }), u2 = i(() => Ht(e2.value)), d2 = i(() => Ht(t2.value)), p2 = E(0), m2 = E(0), h2 = E(c2.value), g2 = E(s2.value), _2 = ie({}), v2 = E(false), y2 = i(() => {
    let e3 = { position: h2.value, left: `0`, top: `0` };
    if (!d2.value) return e3;
    let t3 = Gt(d2.value, p2.value), n3 = Gt(d2.value, m2.value);
    return l2.value ? { ...e3, transform: `translate(` + t3 + `px, ` + n3 + `px)`, ...Wt(d2.value) >= 1.5 && { willChange: `transform` } } : { position: h2.value, left: t3 + `px`, top: n3 + `px` };
  }), b2;
  function x2() {
    if (u2.value == null || d2.value == null) return;
    let e3 = a2.value;
    Bt(u2.value, d2.value, { middleware: o2.value, placement: s2.value, strategy: c2.value }).then((t3) => {
      p2.value = t3.x, m2.value = t3.y, h2.value = t3.strategy, g2.value = t3.placement, _2.value = t3.middlewareData, v2.value = e3 !== false;
    });
  }
  function S2() {
    typeof b2 == `function` && (b2(), b2 = void 0);
  }
  function C2() {
    if (S2(), r2 === void 0) {
      x2();
      return;
    }
    if (u2.value != null && d2.value != null) {
      b2 = r2(u2.value, d2.value, x2);
      return;
    }
  }
  function w2() {
    a2.value || (v2.value = false);
  }
  return j([o2, s2, c2, a2], x2, { flush: `sync` }), j([u2, d2], C2, { flush: `sync` }), j(a2, w2, { flush: `sync` }), f() && ee(S2), { x: O(p2), y: O(m2), strategy: O(h2), placement: O(g2), middlewareData: O(_2), isPositioned: O(v2), floatingStyles: y2, update: x2 };
}
const [qt, Jt] = R(`ConfigProvider`), Yt = u({ inheritAttrs: false, __name: `ConfigProvider`, props: { dir: { default: `ltr` }, locale: { default: `en` }, scrollBody: { type: [Boolean, Object], default: true }, nonce: { default: void 0 }, useId: { type: Function, default: void 0 } }, setup(e2) {
  let t2 = e2, { dir: n2, locale: r2, scrollBody: i2, nonce: a2 } = ce(t2);
  return Jt({ dir: n2, locale: r2, scrollBody: i2, nonce: a2, useId: t2.useId }), (e3, t3) => D(e3.$slots, `default`);
} });
let Xt = 0;
function Zt(e2, t2 = `reka`) {
  var _a;
  if (e2) return e2;
  let n2 = qt({ useId: void 0 });
  return Object.hasOwn(pe, `useId`) ? `${t2}-${(_a = ue) == null ? void 0 : _a()}` : n2.useId ? `${t2}-${n2.useId()}` : `${t2}-${++Xt}`;
}
function Qt(e2, t2) {
  let n2 = E(e2);
  function r2(e3) {
    let r3 = t2[n2.value][e3];
    return r3 ?? n2.value;
  }
  let i2 = (e3) => {
    n2.value = r2(e3);
  };
  return { state: n2, dispatch: i2 };
}
function $t(e2, t2) {
  var _a;
  let n2 = E({}), r2 = E(`none`), a2 = E(e2), o2 = e2.value ? `mounted` : `unmounted`, s2, c2 = ((_a = t2.value) == null ? void 0 : _a.ownerDocument.defaultView) ?? Le, { state: l2, dispatch: u2 } = Qt(o2, { mounted: { UNMOUNT: `unmounted`, ANIMATION_OUT: `unmountSuspended` }, unmountSuspended: { MOUNT: `mounted`, ANIMATION_END: `unmounted` }, unmounted: { MOUNT: `mounted` } }), d2 = (e3) => {
    var _a2;
    if (Re) {
      let n3 = new CustomEvent(e3, { bubbles: false, cancelable: false });
      (_a2 = t2.value) == null ? void 0 : _a2.dispatchEvent(n3);
    }
  };
  j(e2, async (e3, i2) => {
    var _a2;
    let a3 = i2 !== e3;
    if (await v(), a3) {
      let a4 = r2.value, o3 = en(t2.value);
      if (e3) u2(`MOUNT`), d2(`enter`), o3 === `none` && d2(`after-enter`);
      else if (o3 === `none` || o3 === `undefined` || ((_a2 = n2.value) == null ? void 0 : _a2.display) === `none`) u2(`UNMOUNT`), d2(`leave`), d2(`after-leave`);
      else {
        let e4 = a4 !== o3;
        i2 && e4 ? (u2(`ANIMATION_OUT`), d2(`leave`)) : (u2(`UNMOUNT`), d2(`after-leave`));
      }
    }
  }, { immediate: true });
  let f2 = (e3) => {
    let n3 = en(t2.value), r3 = n3.includes(e3.animationName), i2 = l2.value === `mounted` ? `enter` : `leave`;
    if (e3.target === t2.value && r3 && (d2(`after-${i2}`), u2(`ANIMATION_END`), !a2.value)) {
      let e4 = t2.value.style.animationFillMode;
      t2.value.style.animationFillMode = `forwards`, s2 = c2 == null ? void 0 : c2.setTimeout(() => {
        var _a2;
        ((_a2 = t2.value) == null ? void 0 : _a2.style.animationFillMode) === `forwards` && (t2.value.style.animationFillMode = e4);
      });
    }
    e3.target === t2.value && n3 === `none` && u2(`ANIMATION_END`);
  }, p2 = (e3) => {
    e3.target === t2.value && (r2.value = en(t2.value));
  }, m2 = j(t2, (e3, t3) => {
    e3 ? (n2.value = getComputedStyle(e3), e3.addEventListener(`animationstart`, p2), e3.addEventListener(`animationcancel`, f2), e3.addEventListener(`animationend`, f2)) : (u2(`ANIMATION_END`), s2 !== void 0 && (c2 == null ? void 0 : c2.clearTimeout(s2)), t3 == null ? void 0 : t3.removeEventListener(`animationstart`, p2), t3 == null ? void 0 : t3.removeEventListener(`animationcancel`, f2), t3 == null ? void 0 : t3.removeEventListener(`animationend`, f2));
  }, { immediate: true }), h2 = j(l2, () => {
    let e3 = en(t2.value);
    r2.value = l2.value === `mounted` ? e3 : `none`;
  });
  C(() => {
    m2(), h2();
  });
  let g2 = i(() => [`mounted`, `unmountSuspended`].includes(l2.value));
  return { isPresent: g2 };
}
function en(e2) {
  return e2 && getComputedStyle(e2).animationName || `none`;
}
const tn = u({ name: `Presence`, props: { present: { type: Boolean, required: true }, forceMount: { type: Boolean } }, slots: {}, setup(e2, { slots: t2, expose: n2 }) {
  var _a;
  let { present: r2, forceMount: i2 } = ce(e2), a2 = E(), { isPresent: o2 } = $t(r2, a2);
  n2({ present: o2 });
  let s2 = t2.default({ present: o2.value });
  s2 = _e(s2 || []);
  let c2 = d();
  if (s2 && (s2 == null ? void 0 : s2.length) > 1) {
    let e3 = ((_a = c2 == null ? void 0 : c2.parent) == null ? void 0 : _a.type.name) ? `<${c2.parent.type.name} />` : `component`;
    throw Error([`Detected an invalid children for \`${e3}\` for  \`Presence\` component.`, ``, "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.", `You can apply a few solutions:`, ["Provide a single child element so that `presence` directive attach correctly.", `Ensure the first child is an actual element instead of a raw text node or comment node.`].map((e4) => `  - ${e4}`).join(`
`)].join(`
`));
  }
  return () => i2.value || r2.value || o2.value ? m(t2.default({ present: o2.value })[0], { ref: (e3) => {
    let t3 = Ve(e3);
    return (t3 == null ? void 0 : t3.hasAttribute) === void 0 || ((t3 == null ? void 0 : t3.hasAttribute(`data-reka-popper-content-wrapper`)) ? a2.value = t3.firstElementChild : a2.value = t3), t3;
  } }) : null;
} });
function nn(e2) {
  let t2 = d(), n2 = t2 == null ? void 0 : t2.type.emits, i2 = {};
  return (n2 == null ? void 0 : n2.length) || console.warn(`No emitted event found. Please check component: ${t2 == null ? void 0 : t2.type.__name}`), n2 == null ? void 0 : n2.forEach((t3) => {
    i2[ae(r(t3))] = (...n3) => e2(t3, ...n3);
  }), i2;
}
function rn(e2, t2, n2) {
  let r2 = n2.originalEvent.target, i2 = new CustomEvent(e2, { bubbles: false, cancelable: true, detail: n2 });
  t2 && r2.addEventListener(e2, t2, { once: true }), r2.dispatchEvent(i2);
}
const an = `dismissableLayer.pointerDownOutside`, on = `dismissableLayer.focusOutside`;
function sn(e2, t2) {
  let n2 = t2.closest(`[data-dismissable-layer]`), r2 = e2.dataset.dismissableLayer === `` ? e2 : e2.querySelector(`[data-dismissable-layer]`), i2 = Array.from(e2.ownerDocument.querySelectorAll(`[data-dismissable-layer]`));
  return !!(n2 && (r2 === n2 || i2.indexOf(r2) < i2.indexOf(n2)));
}
function cn(e2, t2, n2 = true) {
  var _a;
  let r2 = ((_a = t2 == null ? void 0 : t2.value) == null ? void 0 : _a.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), i2 = E(false), a2 = E(() => {
  });
  return M((o2) => {
    if (!Re || !le(n2)) return;
    let s2 = async (n3) => {
      let o3 = n3.target;
      if (!(!(t2 == null ? void 0 : t2.value) || !o3)) {
        if (sn(t2.value, o3)) {
          i2.value = false;
          return;
        }
        if (n3.target && !i2.value) {
          let t3 = function() {
            rn(an, e2, i3);
          }, i3 = { originalEvent: n3 };
          n3.pointerType === `touch` ? (r2.removeEventListener(`click`, a2.value), a2.value = t3, r2.addEventListener(`click`, a2.value, { once: true })) : t3();
        } else r2.removeEventListener(`click`, a2.value);
        i2.value = false;
      }
    }, c2 = window.setTimeout(() => {
      r2.addEventListener(`pointerdown`, s2);
    }, 0);
    o2(() => {
      window.clearTimeout(c2), r2.removeEventListener(`pointerdown`, s2), r2.removeEventListener(`click`, a2.value);
    });
  }), { onPointerDownCapture: () => {
    le(n2) && (i2.value = true);
  } };
}
function ln(e2, t2) {
  var _a;
  let n2 = ((_a = t2 == null ? void 0 : t2.value) == null ? void 0 : _a.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), r2 = E(false);
  return M((i2) => {
    if (!Re) return;
    let a2 = async (n3) => {
      if (!(t2 == null ? void 0 : t2.value)) return;
      await v(), await v();
      let i3 = n3.target;
      if (!(!t2.value || !i3 || sn(t2.value, i3)) && n3.target && !r2.value) {
        let t3 = { originalEvent: n3 };
        rn(on, e2, t3);
      }
    };
    n2.addEventListener(`focusin`, a2), i2(() => n2.removeEventListener(`focusin`, a2));
  }), { onFocusCapture: () => r2.value = true, onBlurCapture: () => r2.value = false };
}
const $ = te({ layersRoot: /* @__PURE__ */ new Set(), layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(), branches: /* @__PURE__ */ new Set() }), un = u({ __name: `DismissableLayer`, props: { disableOutsidePointerEvents: { type: Boolean, default: false }, asChild: { type: Boolean }, as: {} }, emits: [`escapeKeyDown`, `pointerDownOutside`, `focusOutside`, `interactOutside`, `dismiss`], setup(e2, { emit: t2 }) {
  let n2 = e2, r2 = t2, { forwardRef: o2, currentElement: s2 } = z(), c2 = i(() => {
    var _a;
    return ((_a = s2.value) == null ? void 0 : _a.ownerDocument) ?? globalThis.document;
  }), l2 = i(() => $.layersRoot), u2 = i(() => s2.value ? Array.from(l2.value).indexOf(s2.value) : -1), d2 = i(() => $.layersWithOutsidePointerEventsDisabled.size > 0), f2 = i(() => {
    let e3 = Array.from(l2.value), [t3] = [...$.layersWithOutsidePointerEventsDisabled].slice(-1), n3 = e3.indexOf(t3);
    return u2.value >= n3;
  }), p2 = cn(async (e3) => {
    let t3 = [...$.branches].some((t4) => t4 == null ? void 0 : t4.contains(e3.target));
    !f2.value || t3 || (r2(`pointerDownOutside`, e3), r2(`interactOutside`, e3), await v(), e3.defaultPrevented || r2(`dismiss`));
  }, s2), m2 = ln((e3) => {
    let t3 = [...$.branches].some((t4) => t4 == null ? void 0 : t4.contains(e3.target));
    t3 || (r2(`focusOutside`, e3), r2(`interactOutside`, e3), e3.defaultPrevented || r2(`dismiss`));
  }, s2);
  ze(`Escape`, (e3) => {
    let t3 = u2.value === l2.value.size - 1;
    t3 && (r2(`escapeKeyDown`, e3), e3.defaultPrevented || r2(`dismiss`));
  });
  let h2;
  return M((e3) => {
    s2.value && (n2.disableOutsidePointerEvents && ($.layersWithOutsidePointerEventsDisabled.size === 0 && (h2 = c2.value.body.style.pointerEvents, c2.value.body.style.pointerEvents = `none`), $.layersWithOutsidePointerEventsDisabled.add(s2.value)), l2.value.add(s2.value), e3(() => {
      n2.disableOutsidePointerEvents && $.layersWithOutsidePointerEventsDisabled.size === 1 && (c2.value.body.style.pointerEvents = h2);
    }));
  }), M((e3) => {
    e3(() => {
      s2.value && (l2.value.delete(s2.value), $.layersWithOutsidePointerEventsDisabled.delete(s2.value));
    });
  }), (e3, t3) => (w(), a(A(P), { ref: A(o2), "as-child": e3.asChild, as: e3.as, "data-dismissable-layer": ``, style: x({ pointerEvents: d2.value ? f2.value ? `auto` : `none` : void 0 }), onFocusCapture: A(m2).onFocusCapture, onBlurCapture: A(m2).onBlurCapture, onPointerdownCapture: A(p2).onPointerDownCapture }, { default: N(() => [D(e3.$slots, `default`)]), _: 3 }, 8, [`as-child`, `as`, `style`, `onFocusCapture`, `onBlurCapture`, `onPointerdownCapture`]));
} }), dn = u({ __name: `Teleport`, props: { to: { default: `body` }, disabled: { type: Boolean }, defer: { type: Boolean }, forceMount: { type: Boolean } }, setup(e2) {
  let t2 = Ue();
  return (e3, r2) => A(t2) || e3.forceMount ? (w(), a(n, { key: 0, to: e3.to, disabled: e3.disabled, defer: e3.defer }, [D(e3.$slots, `default`)], 8, [`to`, `disabled`, `defer`])) : o(``, true);
} });
function fn(e2, t2) {
  let n2 = ye(e2), r2 = t2 ? nn(t2) : {};
  return i(() => ({ ...n2.value, ...r2 }));
}
const [pn, mn] = R(`PopperRoot`), hn = u({ inheritAttrs: false, __name: `PopperRoot`, setup(e2) {
  let t2 = E();
  return mn({ anchor: t2, onAnchorChange: (e3) => t2.value = e3 }), (e3, t3) => D(e3.$slots, `default`);
} }), gn = u({ __name: `PopperAnchor`, props: { reference: {}, asChild: { type: Boolean }, as: {} }, setup(e2) {
  let t2 = e2, { forwardRef: n2, currentElement: r2 } = z(), i2 = pn();
  return fe(() => {
    i2.onAnchorChange(t2.reference ?? r2.value);
  }), (e3, t3) => (w(), a(A(P), { ref: A(n2), as: e3.as, "as-child": e3.asChild }, { default: N(() => [D(e3.$slots, `default`)]), _: 3 }, 8, [`as`, `as-child`]));
} }), _n = { key: 0, d: `M0 0L6 6L12 0` }, vn = { key: 1, d: `M0 0L4.58579 4.58579C5.36683 5.36683 6.63316 5.36684 7.41421 4.58579L12 0` }, yn = u({ __name: `Arrow`, props: { width: { default: 10 }, height: { default: 5 }, rounded: { type: Boolean }, asChild: { type: Boolean }, as: { default: `svg` } }, setup(e2) {
  let t2 = e2;
  return z(), (e3, n2) => (w(), a(A(P), _(t2, { width: e3.width, height: e3.height, viewBox: e3.asChild ? void 0 : `0 0 12 6`, preserveAspectRatio: e3.asChild ? void 0 : `none` }), { default: N(() => [D(e3.$slots, `default`, {}, () => [e3.rounded ? (w(), s(`path`, vn)) : (w(), s(`path`, _n))])]), _: 3 }, 16, [`width`, `height`, `viewBox`, `preserveAspectRatio`]));
} });
function bn(e2) {
  return e2 !== null;
}
function xn(e2) {
  return { name: `transformOrigin`, options: e2, fn(t2) {
    var _a, _b, _c;
    let { placement: n2, rects: r2, middlewareData: i2 } = t2, a2 = ((_a = i2.arrow) == null ? void 0 : _a.centerOffset) !== 0, o2 = a2, s2 = o2 ? 0 : e2.arrowWidth, c2 = o2 ? 0 : e2.arrowHeight, [l2, u2] = Sn(n2), d2 = { start: `0%`, center: `50%`, end: `100%` }[u2], f2 = (((_b = i2.arrow) == null ? void 0 : _b.x) ?? 0) + s2 / 2, p2 = (((_c = i2.arrow) == null ? void 0 : _c.y) ?? 0) + c2 / 2, m2 = ``, h2 = ``;
    return l2 === `bottom` ? (m2 = o2 ? d2 : `${f2}px`, h2 = `${-c2}px`) : l2 === `top` ? (m2 = o2 ? d2 : `${f2}px`, h2 = `${r2.floating.height + c2}px`) : l2 === `right` ? (m2 = `${-c2}px`, h2 = o2 ? d2 : `${p2}px`) : l2 === `left` && (m2 = `${r2.floating.width + c2}px`, h2 = o2 ? d2 : `${p2}px`), { data: { x: m2, y: h2 } };
  } };
}
function Sn(e2) {
  let [t2, n2 = `center`] = e2.split(`-`);
  return [t2, n2];
}
function Cn(e2) {
  let t2 = E(), n2 = i(() => {
    var _a;
    return ((_a = t2.value) == null ? void 0 : _a.width) ?? 0;
  }), r2 = i(() => {
    var _a;
    return ((_a = t2.value) == null ? void 0 : _a.height) ?? 0;
  });
  return S(() => {
    let n3 = Ve(e2);
    if (n3) {
      t2.value = { width: n3.offsetWidth, height: n3.offsetHeight };
      let e3 = new ResizeObserver((e4) => {
        if (!Array.isArray(e4) || !e4.length) return;
        let r3 = e4[0], i2, a2;
        if (`borderBoxSize` in r3) {
          let e5 = r3.borderBoxSize, t3 = Array.isArray(e5) ? e5[0] : e5;
          i2 = t3.inlineSize, a2 = t3.blockSize;
        } else i2 = n3.offsetWidth, a2 = n3.offsetHeight;
        t2.value = { width: i2, height: a2 };
      });
      return e3.observe(n3, { box: `border-box` }), () => e3.unobserve(n3);
    } else t2.value = void 0;
  }), { width: n2, height: r2 };
}
const wn = { side: `bottom`, sideOffset: 0, align: `center`, alignOffset: 0, arrowPadding: 0, avoidCollisions: true, collisionBoundary: () => [], collisionPadding: 0, sticky: `partial`, hideWhenDetached: false, positionStrategy: `fixed`, updatePositionStrategy: `optimized`, prioritizePosition: false }, [Tn, En] = R(`PopperContent`), Dn = u({ inheritAttrs: false, __name: `PopperContent`, props: g({ side: {}, sideOffset: {}, align: {}, alignOffset: {}, avoidCollisions: { type: Boolean }, collisionBoundary: {}, collisionPadding: {}, arrowPadding: {}, sticky: {}, hideWhenDetached: { type: Boolean }, positionStrategy: {}, updatePositionStrategy: {}, disableUpdateOnLayoutShift: { type: Boolean }, prioritizePosition: { type: Boolean }, reference: {}, asChild: { type: Boolean }, as: {} }, { ...wn }), emits: [`placed`], setup(e2, { emit: t2 }) {
  let n2 = e2, r2 = t2, a2 = pn(), { forwardRef: o2, currentElement: c2 } = z(), u2 = E(), d2 = E(), { width: f2, height: p2 } = Cn(d2), m2 = i(() => n2.side + (n2.align === `center` ? `` : `-${n2.align}`)), h2 = i(() => typeof n2.collisionPadding == `number` ? n2.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...n2.collisionPadding }), g2 = i(() => Array.isArray(n2.collisionBoundary) ? n2.collisionBoundary : [n2.collisionBoundary]), v2 = i(() => ({ padding: h2.value, boundary: g2.value.filter(bn), altBoundary: g2.value.length > 0 })), y2 = Fe(() => [Nt({ mainAxis: n2.sideOffset + p2.value, alignmentAxis: n2.alignOffset }), n2.prioritizePosition && n2.avoidCollisions && Ft({ ...v2.value }), n2.avoidCollisions && Pt({ mainAxis: true, crossAxis: !!n2.prioritizePosition, limiter: n2.sticky === `partial` ? zt() : void 0, ...v2.value }), !n2.prioritizePosition && n2.avoidCollisions && Ft({ ...v2.value }), It({ ...v2.value, apply: ({ elements: e3, rects: t3, availableWidth: n3, availableHeight: r3 }) => {
    let { width: i2, height: a3 } = t3.reference, o3 = e3.floating.style;
    o3.setProperty(`--reka-popper-available-width`, `${n3}px`), o3.setProperty(`--reka-popper-available-height`, `${r3}px`), o3.setProperty(`--reka-popper-anchor-width`, `${i2}px`), o3.setProperty(`--reka-popper-anchor-height`, `${a3}px`);
  } }), d2.value && Ut({ element: d2.value, padding: n2.arrowPadding }), xn({ arrowWidth: f2.value, arrowHeight: p2.value }), n2.hideWhenDetached && Lt({ strategy: `referenceHidden`, ...v2.value })]), b2 = i(() => n2.reference ?? a2.anchor.value), { floatingStyles: S2, placement: ee2, isPositioned: C2, middlewareData: T2, update: te2 } = Kt(b2, u2, { strategy: n2.positionStrategy, placement: m2, whileElementsMounted: (...e3) => {
    let t3 = Mt(...e3, { layoutShift: !n2.disableUpdateOnLayoutShift, animationFrame: n2.updatePositionStrategy === `always` });
    return t3;
  }, middleware: y2 }), ne2 = i(() => Sn(ee2.value)[0]), re2 = i(() => Sn(ee2.value)[1]);
  fe(() => {
    C2.value && r2(`placed`);
  });
  let O2 = i(() => {
    var _a;
    return ((_a = T2.value.arrow) == null ? void 0 : _a.centerOffset) !== 0;
  }), ie2 = E(``);
  M(() => {
    c2.value && (ie2.value = window.getComputedStyle(c2.value).zIndex);
  });
  let k2 = i(() => {
    var _a;
    return ((_a = T2.value.arrow) == null ? void 0 : _a.x) ?? 0;
  }), ae2 = i(() => {
    var _a;
    return ((_a = T2.value.arrow) == null ? void 0 : _a.y) ?? 0;
  });
  return En({ placedSide: ne2, onArrowChange: (e3) => d2.value = e3, arrowX: k2, arrowY: ae2, shouldHideArrow: O2 }), (e3, t3) => {
    var _a, _b, _c;
    return w(), s(`div`, { ref_key: `floatingRef`, ref: u2, "data-reka-popper-content-wrapper": ``, style: x({ ...A(S2), transform: A(C2) ? A(S2).transform : `translate(0, -200%)`, minWidth: `max-content`, zIndex: ie2.value, "--reka-popper-transform-origin": [(_a = A(T2).transformOrigin) == null ? void 0 : _a.x, (_b = A(T2).transformOrigin) == null ? void 0 : _b.y].join(` `), ...((_c = A(T2).hide) == null ? void 0 : _c.referenceHidden) && { visibility: `hidden`, pointerEvents: `none` } }) }, [l(A(P), _({ ref: A(o2) }, e3.$attrs, { "as-child": n2.asChild, as: e3.as, "data-side": ne2.value, "data-align": re2.value, style: { animation: A(C2) ? void 0 : `none` } }), { default: N(() => [D(e3.$slots, `default`)]), _: 3 }, 16, [`as-child`, `as`, `data-side`, `data-align`, `style`])], 4);
  };
} }), On = { top: `bottom`, right: `left`, bottom: `top`, left: `right` }, kn = u({ inheritAttrs: false, __name: `PopperArrow`, props: { width: {}, height: {}, rounded: { type: Boolean }, asChild: { type: Boolean }, as: { default: `svg` } }, setup(e2) {
  let { forwardRef: t2 } = z(), n2 = Tn(), r2 = i(() => On[n2.placedSide.value]);
  return (e3, i2) => {
    var _a, _b, _c, _d;
    return w(), s(`span`, { ref: (e4) => {
      A(n2).onArrowChange(e4);
    }, style: x({ position: `absolute`, left: ((_a = A(n2).arrowX) == null ? void 0 : _a.value) ? `${(_b = A(n2).arrowX) == null ? void 0 : _b.value}px` : void 0, top: ((_c = A(n2).arrowY) == null ? void 0 : _c.value) ? `${(_d = A(n2).arrowY) == null ? void 0 : _d.value}px` : void 0, [r2.value]: 0, transformOrigin: { top: ``, right: `0 0`, bottom: `center 0`, left: `100% 0` }[A(n2).placedSide.value], transform: { top: `translateY(100%)`, right: `translateY(50%) rotate(90deg) translateX(-50%)`, bottom: `rotate(180deg)`, left: `translateY(50%) rotate(-90deg) translateX(50%)` }[A(n2).placedSide.value], visibility: A(n2).shouldHideArrow.value ? `hidden` : void 0 }) }, [l(yn, _(e3.$attrs, { ref: A(t2), style: { display: `block` }, as: e3.as, "as-child": e3.asChild, rounded: e3.rounded, width: e3.width, height: e3.height }), { default: N(() => [D(e3.$slots, `default`)]), _: 3 }, 16, [`as`, `as-child`, `rounded`, `width`, `height`])], 4);
  };
} });
function An(e2, t2) {
  let n2 = Be(false, 300), r2 = E(null), i2 = Ie();
  function a2() {
    r2.value = null, n2.value = false;
  }
  function o2(e3, t3) {
    let i3 = e3.currentTarget, a3 = { x: e3.clientX, y: e3.clientY }, o3 = jn(a3, i3.getBoundingClientRect()), s2 = Mn(a3, o3), c2 = Nn(t3.getBoundingClientRect()), l2 = Fn([...s2, ...c2]);
    r2.value = l2, n2.value = true;
  }
  return M((n3) => {
    if (e2.value && t2.value) {
      let r3 = (e3) => o2(e3, t2.value), i3 = (t3) => o2(t3, e2.value);
      e2.value.addEventListener(`pointerleave`, r3), t2.value.addEventListener(`pointerleave`, i3), n3(() => {
        var _a, _b;
        (_a = e2.value) == null ? void 0 : _a.removeEventListener(`pointerleave`, r3), (_b = t2.value) == null ? void 0 : _b.removeEventListener(`pointerleave`, i3);
      });
    }
  }), M((n3) => {
    var _a;
    if (r2.value) {
      let o3 = (n4) => {
        var _a2, _b;
        if (!r2.value || !(n4.target instanceof HTMLElement)) return;
        let o4 = n4.target, s2 = { x: n4.clientX, y: n4.clientY }, c2 = ((_a2 = e2.value) == null ? void 0 : _a2.contains(o4)) || ((_b = t2.value) == null ? void 0 : _b.contains(o4)), l2 = !Pn(s2, r2.value), u2 = !!o4.closest(`[data-grace-area-trigger]`);
        c2 ? a2() : (l2 || u2) && (a2(), i2.trigger());
      };
      (_a = e2.value) == null ? void 0 : _a.ownerDocument.addEventListener(`pointermove`, o3), n3(() => {
        var _a2;
        return (_a2 = e2.value) == null ? void 0 : _a2.ownerDocument.removeEventListener(`pointermove`, o3);
      });
    }
  }), { isPointerInTransit: n2, onPointerExit: i2.on };
}
function jn(e2, t2) {
  let n2 = Math.abs(t2.top - e2.y), r2 = Math.abs(t2.bottom - e2.y), i2 = Math.abs(t2.right - e2.x), a2 = Math.abs(t2.left - e2.x);
  switch (Math.min(n2, r2, i2, a2)) {
    case a2:
      return `left`;
    case i2:
      return `right`;
    case n2:
      return `top`;
    case r2:
      return `bottom`;
    default:
      throw Error(`unreachable`);
  }
}
function Mn(e2, t2, n2 = 5) {
  let r2 = [];
  switch (t2) {
    case `top`:
      r2.push({ x: e2.x - n2, y: e2.y + n2 }, { x: e2.x + n2, y: e2.y + n2 });
      break;
    case `bottom`:
      r2.push({ x: e2.x - n2, y: e2.y - n2 }, { x: e2.x + n2, y: e2.y - n2 });
      break;
    case `left`:
      r2.push({ x: e2.x + n2, y: e2.y - n2 }, { x: e2.x + n2, y: e2.y + n2 });
      break;
    case `right`:
      r2.push({ x: e2.x - n2, y: e2.y - n2 }, { x: e2.x - n2, y: e2.y + n2 });
      break;
  }
  return r2;
}
function Nn(e2) {
  let { top: t2, right: n2, bottom: r2, left: i2 } = e2;
  return [{ x: i2, y: t2 }, { x: n2, y: t2 }, { x: n2, y: r2 }, { x: i2, y: r2 }];
}
function Pn(e2, t2) {
  let { x: n2, y: r2 } = e2, i2 = false;
  for (let e3 = 0, a2 = t2.length - 1; e3 < t2.length; a2 = e3++) {
    let o2 = t2[e3].x, s2 = t2[e3].y, c2 = t2[a2].x, l2 = t2[a2].y, u2 = s2 > r2 != l2 > r2 && n2 < (c2 - o2) * (r2 - s2) / (l2 - s2) + o2;
    u2 && (i2 = !i2);
  }
  return i2;
}
function Fn(e2) {
  let t2 = e2.slice();
  return t2.sort((e3, t3) => e3.x < t3.x ? -1 : e3.x > t3.x ? 1 : e3.y < t3.y ? -1 : e3.y > t3.y ? 1 : 0), In(t2);
}
function In(e2) {
  if (e2.length <= 1) return e2.slice();
  let t2 = [];
  for (let n3 = 0; n3 < e2.length; n3++) {
    let r2 = e2[n3];
    for (; t2.length >= 2; ) {
      let e3 = t2[t2.length - 1], n4 = t2[t2.length - 2];
      if ((e3.x - n4.x) * (r2.y - n4.y) >= (e3.y - n4.y) * (r2.x - n4.x)) t2.pop();
      else break;
    }
    t2.push(r2);
  }
  t2.pop();
  let n2 = [];
  for (let t3 = e2.length - 1; t3 >= 0; t3--) {
    let r2 = e2[t3];
    for (; n2.length >= 2; ) {
      let e3 = n2[n2.length - 1], t4 = n2[n2.length - 2];
      if ((e3.x - t4.x) * (r2.y - t4.y) >= (e3.y - t4.y) * (r2.x - t4.x)) n2.pop();
      else break;
    }
    n2.push(r2);
  }
  return n2.pop(), t2.length === 1 && n2.length === 1 && t2[0].x === n2[0].x && t2[0].y === n2[0].y ? t2 : t2.concat(n2);
}
const Ln = u({ __name: `TooltipArrow`, props: { width: { default: 10 }, height: { default: 5 }, asChild: { type: Boolean }, as: { default: `svg` } }, setup(e2) {
  let t2 = e2;
  return z(), (e3, n2) => (w(), a(A(kn), b(p(t2)), { default: N(() => [D(e3.$slots, `default`)]), _: 3 }, 16));
} }), Rn = `tooltip.open`, [zn, Bn] = R(`TooltipProvider`), Vn = u({ inheritAttrs: false, __name: `TooltipProvider`, props: { delayDuration: { default: 700 }, skipDelayDuration: { default: 300 }, disableHoverableContent: { type: Boolean, default: false }, disableClosingTrigger: { type: Boolean }, disabled: { type: Boolean }, ignoreNonKeyboardFocus: { type: Boolean, default: false } }, setup(e2) {
  let t2 = e2, { delayDuration: n2, skipDelayDuration: r2, disableHoverableContent: i2, disableClosingTrigger: a2, ignoreNonKeyboardFocus: o2, disabled: s2 } = ce(t2);
  z();
  let c2 = E(true), l2 = E(false), { start: u2, stop: d2 } = We(() => {
    c2.value = true;
  }, r2, { immediate: false });
  return Bn({ isOpenDelayed: c2, delayDuration: n2, onOpen() {
    d2(), c2.value = false;
  }, onClose() {
    u2();
  }, isPointerInTransitRef: l2, disableHoverableContent: i2, disableClosingTrigger: a2, disabled: s2, ignoreNonKeyboardFocus: o2 }), (e3, t3) => D(e3.$slots, `default`);
} }), [Hn, Un] = R(`TooltipRoot`), Wn = u({ __name: `TooltipRoot`, props: { defaultOpen: { type: Boolean, default: false }, open: { type: Boolean, default: void 0 }, delayDuration: { default: void 0 }, disableHoverableContent: { type: Boolean, default: void 0 }, disableClosingTrigger: { type: Boolean, default: void 0 }, disabled: { type: Boolean, default: void 0 }, ignoreNonKeyboardFocus: { type: Boolean, default: void 0 } }, emits: [`update:open`], setup(e2, { emit: t2 }) {
  let n2 = e2, r2 = t2;
  z();
  let o2 = zn(), s2 = i(() => n2.disableHoverableContent ?? o2.disableHoverableContent.value), c2 = i(() => n2.disableClosingTrigger ?? o2.disableClosingTrigger.value), l2 = i(() => n2.disabled ?? o2.disabled.value), u2 = i(() => n2.delayDuration ?? o2.delayDuration.value), d2 = i(() => n2.ignoreNonKeyboardFocus ?? o2.ignoreNonKeyboardFocus.value), f2 = Ge(n2, `open`, r2, { defaultValue: n2.defaultOpen, passive: n2.open === void 0 });
  j(f2, (e3) => {
    o2.onClose && (e3 ? (o2.onOpen(), document.dispatchEvent(new CustomEvent(Rn))) : o2.onClose());
  });
  let p2 = E(false), m2 = E(), h2 = i(() => f2.value ? p2.value ? `delayed-open` : `instant-open` : `closed`), { start: g2, stop: _2 } = We(() => {
    p2.value = true, f2.value = true;
  }, u2, { immediate: false });
  function v2() {
    _2(), p2.value = false, f2.value = true;
  }
  function y2() {
    _2(), f2.value = false;
  }
  function b2() {
    g2();
  }
  return Un({ contentId: ``, open: f2, stateAttribute: h2, trigger: m2, onTriggerChange(e3) {
    m2.value = e3;
  }, onTriggerEnter() {
    o2.isOpenDelayed.value ? b2() : v2();
  }, onTriggerLeave() {
    s2.value ? y2() : _2();
  }, onOpen: v2, onClose: y2, disableHoverableContent: s2, disableClosingTrigger: c2, disabled: l2, ignoreNonKeyboardFocus: d2 }), (e3, t3) => (w(), a(A(hn), null, { default: N(() => [D(e3.$slots, `default`, { open: A(f2) })]), _: 3 }));
} }), Gn = u({ __name: `TooltipContentImpl`, props: { ariaLabel: {}, asChild: { type: Boolean }, as: {}, side: { default: `top` }, sideOffset: { default: 0 }, align: { default: `center` }, alignOffset: {}, avoidCollisions: { type: Boolean, default: true }, collisionBoundary: { default: () => [] }, collisionPadding: { default: 0 }, arrowPadding: { default: 0 }, sticky: { default: `partial` }, hideWhenDetached: { type: Boolean, default: false }, positionStrategy: {}, updatePositionStrategy: {} }, emits: [`escapeKeyDown`, `pointerDownOutside`], setup(t2, { emit: n2 }) {
  let r2 = t2, o2 = n2, s2 = Hn(), { forwardRef: u2 } = z(), d2 = de(), f2 = i(() => {
    var _a;
    return (_a = d2.default) == null ? void 0 : _a.call(d2, {});
  }), p2 = i(() => {
    var _a;
    if (r2.ariaLabel) return r2.ariaLabel;
    let t3 = ``;
    function n3(r3) {
      typeof r3.children == `string` && r3.type !== e ? t3 += r3.children : Array.isArray(r3.children) && r3.children.forEach((e2) => n3(e2));
    }
    return (_a = f2.value) == null ? void 0 : _a.forEach((e2) => n3(e2)), t3;
  }), m2 = i(() => {
    let { ariaLabel: e2, ...t3 } = r2;
    return t3;
  });
  return S(() => {
    He(window, `scroll`, (e2) => {
      let t3 = e2.target;
      (t3 == null ? void 0 : t3.contains(s2.trigger.value)) && s2.onClose();
    }), He(window, Rn, s2.onClose);
  }), (e2, t3) => (w(), a(A(un), { "as-child": ``, "disable-outside-pointer-events": false, onEscapeKeyDown: t3[0] || (t3[0] = (e3) => o2(`escapeKeyDown`, e3)), onPointerDownOutside: t3[1] || (t3[1] = (e3) => {
    var _a;
    A(s2).disableClosingTrigger.value && ((_a = A(s2).trigger.value) == null ? void 0 : _a.contains(e3.target)) && e3.preventDefault(), o2(`pointerDownOutside`, e3);
  }), onFocusOutside: t3[2] || (t3[2] = me(() => {
  }, [`prevent`])), onDismiss: t3[3] || (t3[3] = (e3) => A(s2).onClose()) }, { default: N(() => [l(A(Dn), _({ ref: A(u2), "data-state": A(s2).stateAttribute.value }, { ...e2.$attrs, ...m2.value }, { style: { "--reka-tooltip-content-transform-origin": `var(--reka-popper-transform-origin)`, "--reka-tooltip-content-available-width": `var(--reka-popper-available-width)`, "--reka-tooltip-content-available-height": `var(--reka-popper-available-height)`, "--reka-tooltip-trigger-width": `var(--reka-popper-anchor-width)`, "--reka-tooltip-trigger-height": `var(--reka-popper-anchor-height)` } }), { default: N(() => [D(e2.$slots, `default`), l(A(Pe), { id: A(s2).contentId, role: `tooltip` }, { default: N(() => [c(k(p2.value), 1)]), _: 1 }, 8, [`id`])]), _: 3 }, 16, [`data-state`])]), _: 3 }));
} }), Kn = u({ __name: `TooltipContentHoverable`, props: { ariaLabel: {}, asChild: { type: Boolean }, as: {}, side: {}, sideOffset: {}, align: {}, alignOffset: {}, avoidCollisions: { type: Boolean }, collisionBoundary: {}, collisionPadding: {}, arrowPadding: {}, sticky: {}, hideWhenDetached: { type: Boolean }, positionStrategy: {}, updatePositionStrategy: {} }, setup(e2) {
  let t2 = e2, n2 = ye(t2), { forwardRef: r2, currentElement: i2 } = z(), { trigger: o2, onClose: s2 } = Hn(), c2 = zn(), { isPointerInTransit: l2, onPointerExit: u2 } = An(o2, i2);
  return c2.isPointerInTransitRef = l2, u2(() => {
    s2();
  }), (e3, t3) => (w(), a(Gn, _({ ref: A(r2) }, A(n2)), { default: N(() => [D(e3.$slots, `default`)]), _: 3 }, 16));
} }), qn = u({ __name: `TooltipContent`, props: { forceMount: { type: Boolean }, ariaLabel: {}, asChild: { type: Boolean }, as: {}, side: { default: `top` }, sideOffset: {}, align: {}, alignOffset: {}, avoidCollisions: { type: Boolean }, collisionBoundary: {}, collisionPadding: {}, arrowPadding: {}, sticky: {}, hideWhenDetached: { type: Boolean }, positionStrategy: {}, updatePositionStrategy: {} }, emits: [`escapeKeyDown`, `pointerDownOutside`], setup(e2, { emit: t2 }) {
  let n2 = e2, r2 = t2, i2 = Hn(), o2 = fn(n2, r2), { forwardRef: s2 } = z();
  return (e3, t3) => (w(), a(A(tn), { present: e3.forceMount || A(i2).open.value }, { default: N(() => [(w(), a(re(A(i2).disableHoverableContent.value ? Gn : Kn), _({ ref: A(s2) }, A(o2)), { default: N(() => [D(e3.$slots, `default`)]), _: 3 }, 16))]), _: 3 }, 8, [`present`]));
} }), Jn = u({ __name: `TooltipPortal`, props: { to: {}, disabled: { type: Boolean }, defer: { type: Boolean }, forceMount: { type: Boolean } }, setup(e2) {
  let t2 = e2;
  return (e3, n2) => (w(), a(A(dn), b(p(t2)), { default: N(() => [D(e3.$slots, `default`)]), _: 3 }, 16));
} }), Yn = u({ __name: `TooltipTrigger`, props: { reference: {}, asChild: { type: Boolean }, as: { default: `button` } }, setup(e2) {
  let t2 = e2, n2 = Hn(), r2 = zn();
  n2.contentId || (n2.contentId = Zt(void 0, `reka-tooltip-content`));
  let { forwardRef: o2, currentElement: s2 } = z(), c2 = E(false), u2 = E(false), d2 = i(() => n2.disabled.value ? {} : { click: y2, focus: g2, pointermove: m2, pointerleave: h2, pointerdown: p2, blur: v2 });
  S(() => {
    n2.onTriggerChange(s2.value);
  });
  function f2() {
    setTimeout(() => {
      c2.value = false;
    }, 1);
  }
  function p2() {
    n2.open && !n2.disableClosingTrigger.value && n2.onClose(), c2.value = true, document.addEventListener(`pointerup`, f2, { once: true });
  }
  function m2(e3) {
    e3.pointerType !== `touch` && !u2.value && !r2.isPointerInTransitRef.value && (n2.onTriggerEnter(), u2.value = true);
  }
  function h2() {
    n2.onTriggerLeave(), u2.value = false;
  }
  function g2(e3) {
    var _a, _b;
    c2.value || n2.ignoreNonKeyboardFocus.value && !((_b = (_a = e3.target).matches) == null ? void 0 : _b.call(_a, `:focus-visible`)) || n2.onOpen();
  }
  function v2() {
    n2.onClose();
  }
  function y2() {
    n2.disableClosingTrigger.value || n2.onClose();
  }
  return (e3, r3) => (w(), a(A(gn), { "as-child": ``, reference: e3.reference }, { default: N(() => [l(A(P), _({ ref: A(o2), "aria-describedby": A(n2).open.value ? A(n2).contentId : void 0, "data-state": A(n2).stateAttribute.value, as: e3.as, "as-child": t2.asChild, "data-grace-area-trigger": `` }, oe(d2.value)), { default: N(() => [D(e3.$slots, `default`)]), _: 3 }, 16, [`aria-describedby`, `data-state`, `as`, `as-child`])]), _: 3 }, 8, [`reference`]));
} }), Xn = Symbol(`nuxt-ui.portal-target`);
function Zn(e2) {
  let t2 = h(Xn, void 0), n2 = i(() => typeof e2.value == `boolean` || e2.value === void 0 ? (t2 == null ? void 0 : t2.value) ?? `body` : e2.value), r2 = i(() => typeof e2.value == `boolean` ? !e2.value : false);
  return T(Xn, i(() => n2.value)), i(() => ({ to: n2.value, disabled: r2.value }));
}
var Qn = { base: `inline-flex items-center justify-center px-1 rounded-sm font-medium font-sans`, variants: { variant: { solid: `bg-inverted text-inverted`, outline: `bg-default text-highlighted ring ring-inset ring-accented`, subtle: `bg-elevated text-default ring ring-inset ring-accented` }, size: { sm: `h-4 min-w-[16px] text-[10px]`, md: `h-5 min-w-[20px] text-[11px]`, lg: `h-6 min-w-[24px] text-[12px]` } }, defaultVariants: { variant: `outline`, size: `md` } };
const $n = { __name: `Kbd`, props: { as: { type: null, required: false, default: `kbd` }, value: { type: null, required: false }, variant: { type: null, required: false }, size: { type: null, required: false }, class: { type: null, required: false } }, setup(e2) {
  let t2 = e2, { getKbdKey: n2 } = be(), r2 = ve(), o2 = i(() => {
    var _a;
    return F({ extend: F(Qn), ...((_a = r2.ui) == null ? void 0 : _a.kbd) || {} });
  });
  return (r3, i2) => (w(), a(A(P), { as: e2.as, class: y(o2.value({ variant: e2.variant, size: e2.size, class: t2.class })) }, { default: N(() => [D(r3.$slots, `default`, {}, () => [c(k(A(n2)(e2.value)), 1)])]), _: 3 }, 8, [`as`, `class`]));
} };
var er = $n, tr = { slots: { base: `font-medium inline-flex items-center`, label: `truncate`, leadingIcon: `shrink-0`, leadingAvatar: `shrink-0`, leadingAvatarSize: ``, trailingIcon: `shrink-0` }, variants: { buttonGroup: { horizontal: `not-only:first:rounded-e-none not-only:last:rounded-s-none not-last:not-first:rounded-none focus-visible:z-[1]`, vertical: `not-only:first:rounded-b-none not-only:last:rounded-t-none not-last:not-first:rounded-none focus-visible:z-[1]` }, color: { primary: ``, secondary: ``, success: ``, info: ``, warning: ``, error: ``, neutral: `` }, variant: { solid: ``, outline: ``, soft: ``, subtle: `` }, size: { xs: { base: `text-[8px]/3 px-1 py-0.5 gap-1 rounded-sm`, leadingIcon: `size-3`, leadingAvatarSize: `3xs`, trailingIcon: `size-3` }, sm: { base: `text-[10px]/3 px-1.5 py-1 gap-1 rounded-sm`, leadingIcon: `size-3`, leadingAvatarSize: `3xs`, trailingIcon: `size-3` }, md: { base: `text-xs px-2 py-1 gap-1 rounded-md`, leadingIcon: `size-4`, leadingAvatarSize: `3xs`, trailingIcon: `size-4` }, lg: { base: `text-sm px-2 py-1 gap-1.5 rounded-md`, leadingIcon: `size-5`, leadingAvatarSize: `2xs`, trailingIcon: `size-5` }, xl: { base: `text-base px-2.5 py-1 gap-1.5 rounded-md`, leadingIcon: `size-6`, leadingAvatarSize: `2xs`, trailingIcon: `size-6` } }, square: { true: `` } }, compoundVariants: [{ color: `primary`, variant: `solid`, class: `bg-primary text-inverted` }, { color: `secondary`, variant: `solid`, class: `bg-secondary text-inverted` }, { color: `success`, variant: `solid`, class: `bg-success text-inverted` }, { color: `info`, variant: `solid`, class: `bg-info text-inverted` }, { color: `warning`, variant: `solid`, class: `bg-warning text-inverted` }, { color: `error`, variant: `solid`, class: `bg-error text-inverted` }, { color: `primary`, variant: `outline`, class: `text-primary ring ring-inset ring-primary/50` }, { color: `secondary`, variant: `outline`, class: `text-secondary ring ring-inset ring-secondary/50` }, { color: `success`, variant: `outline`, class: `text-success ring ring-inset ring-success/50` }, { color: `info`, variant: `outline`, class: `text-info ring ring-inset ring-info/50` }, { color: `warning`, variant: `outline`, class: `text-warning ring ring-inset ring-warning/50` }, { color: `error`, variant: `outline`, class: `text-error ring ring-inset ring-error/50` }, { color: `primary`, variant: `soft`, class: `bg-primary/10 text-primary` }, { color: `secondary`, variant: `soft`, class: `bg-secondary/10 text-secondary` }, { color: `success`, variant: `soft`, class: `bg-success/10 text-success` }, { color: `info`, variant: `soft`, class: `bg-info/10 text-info` }, { color: `warning`, variant: `soft`, class: `bg-warning/10 text-warning` }, { color: `error`, variant: `soft`, class: `bg-error/10 text-error` }, { color: `primary`, variant: `subtle`, class: `bg-primary/10 text-primary ring ring-inset ring-primary/25` }, { color: `secondary`, variant: `subtle`, class: `bg-secondary/10 text-secondary ring ring-inset ring-secondary/25` }, { color: `success`, variant: `subtle`, class: `bg-success/10 text-success ring ring-inset ring-success/25` }, { color: `info`, variant: `subtle`, class: `bg-info/10 text-info ring ring-inset ring-info/25` }, { color: `warning`, variant: `subtle`, class: `bg-warning/10 text-warning ring ring-inset ring-warning/25` }, { color: `error`, variant: `subtle`, class: `bg-error/10 text-error ring ring-inset ring-error/25` }, { color: `neutral`, variant: `solid`, class: `text-inverted bg-inverted` }, { color: `neutral`, variant: `outline`, class: `ring ring-inset ring-accented text-default bg-default` }, { color: `neutral`, variant: `soft`, class: `text-default bg-elevated` }, { color: `neutral`, variant: `subtle`, class: `ring ring-inset ring-accented text-default bg-elevated` }, { size: `xs`, square: true, class: `p-0.5` }, { size: `sm`, square: true, class: `p-1` }, { size: `md`, square: true, class: `p-1` }, { size: `lg`, square: true, class: `p-1` }, { size: `xl`, square: true, class: `p-1` }], defaultVariants: { color: `primary`, variant: `solid`, size: `md` } };
const nr = { __name: `Badge`, props: { as: { type: null, required: false, default: `span` }, label: { type: [String, Number], required: false }, color: { type: null, required: false }, variant: { type: null, required: false }, size: { type: null, required: false }, square: { type: Boolean, required: false }, class: { type: null, required: false }, ui: { type: null, required: false }, icon: { type: String, required: false }, avatar: { type: Object, required: false }, leading: { type: Boolean, required: false }, leadingIcon: { type: String, required: false }, trailing: { type: Boolean, required: false }, trailingIcon: { type: String, required: false } }, setup(e2) {
  let t2 = e2, n2 = de(), r2 = ve(), { orientation: c2, size: l2 } = qe(t2), { isLeading: u2, isTrailing: d2, leadingIconName: f2, trailingIconName: p2 } = Je(t2), m2 = i(() => {
    var _a;
    return F({ extend: F(tr), ...((_a = r2.ui) == null ? void 0 : _a.badge) || {} })({ color: t2.color, variant: t2.variant, size: l2.value || t2.size, square: t2.square || !n2.default && !t2.label, buttonGroup: c2.value });
  });
  return (n3, r3) => {
    var _a;
    return w(), a(A(P), { as: e2.as, class: y(m2.value.base({ class: [(_a = t2.ui) == null ? void 0 : _a.base, t2.class] })) }, { default: N(() => [D(n3.$slots, `leading`, {}, () => {
      var _a2, _b, _c;
      return [A(u2) && A(f2) ? (w(), a(he, { key: 0, name: A(f2), class: y(m2.value.leadingIcon({ class: (_a2 = t2.ui) == null ? void 0 : _a2.leadingIcon })) }, null, 8, [`name`, `class`])) : e2.avatar ? (w(), a(Ke, _({ key: 1, size: ((_b = t2.ui) == null ? void 0 : _b.leadingAvatarSize) || m2.value.leadingAvatarSize() }, e2.avatar, { class: m2.value.leadingAvatar({ class: (_c = t2.ui) == null ? void 0 : _c.leadingAvatar }) }), null, 16, [`size`, `class`])) : o(``, true)];
    }), D(n3.$slots, `default`, {}, () => {
      var _a2;
      return [e2.label !== void 0 && e2.label !== null ? (w(), s(`span`, { key: 0, class: y(m2.value.label({ class: (_a2 = t2.ui) == null ? void 0 : _a2.label })) }, k(e2.label), 3)) : o(``, true)];
    }), D(n3.$slots, `trailing`, {}, () => {
      var _a2;
      return [A(d2) && A(p2) ? (w(), a(he, { key: 0, name: A(p2), class: y(m2.value.trailingIcon({ class: (_a2 = t2.ui) == null ? void 0 : _a2.trailingIcon })) }, null, 8, [`name`, `class`])) : o(``, true)];
    })]), _: 3 }, 8, [`as`, `class`]);
  };
} };
var rr = nr, ir = { slots: { content: `flex items-center gap-1 bg-default text-highlighted shadow-sm rounded-sm ring ring-default h-6 px-2.5 py-1 text-xs select-none data-[state=delayed-open]:animate-[scale-in_100ms_ease-out] data-[state=closed]:animate-[scale-out_100ms_ease-in] origin-(--reka-tooltip-content-transform-origin) pointer-events-auto`, arrow: `fill-default`, text: `truncate`, kbds: `hidden lg:inline-flex items-center shrink-0 gap-0.5 before:content-['\xB7'] before:me-0.5`, kbdsSize: `sm` } };
const ar = { __name: `Tooltip`, props: { text: { type: String, required: false }, kbds: { type: Array, required: false }, content: { type: Object, required: false }, arrow: { type: [Boolean, Object], required: false }, portal: { type: [Boolean, String], required: false, skipCheck: true, default: true }, class: { type: null, required: false }, ui: { type: null, required: false }, defaultOpen: { type: Boolean, required: false }, open: { type: Boolean, required: false }, delayDuration: { type: Number, required: false }, disableHoverableContent: { type: Boolean, required: false }, disableClosingTrigger: { type: Boolean, required: false }, disabled: { type: Boolean, required: false }, ignoreNonKeyboardFocus: { type: Boolean, required: false } }, emits: [`update:open`], setup(e2, { emit: n2 }) {
  let r2 = e2, c2 = n2, u2 = de(), d2 = ve(), f2 = fn(xe(r2, `defaultOpen`, `open`, `delayDuration`, `disableHoverableContent`, `disableClosingTrigger`, `disabled`, `ignoreNonKeyboardFocus`), c2), m2 = Zn(se(() => r2.portal)), h2 = se(() => ge(r2.content, { side: `bottom`, sideOffset: 8, collisionPadding: 8 })), g2 = se(() => r2.arrow), v2 = i(() => {
    var _a;
    return F({ extend: F(ir), ...((_a = d2.ui) == null ? void 0 : _a.tooltip) || {} })({ side: h2.value.side });
  });
  return (n3, i2) => (w(), a(A(Wn), b(p(A(f2))), { default: N(({ open: i3 }) => [u2.default ? (w(), a(A(Yn), _({ key: 0 }, n3.$attrs, { "as-child": ``, class: r2.class }), { default: N(() => [D(n3.$slots, `default`, { open: i3 })]), _: 2 }, 1040, [`class`])) : o(``, true), l(A(Jn), b(p(A(m2))), { default: N(() => {
    var _a;
    return [l(A(qn), _(h2.value, { class: v2.value.content({ class: [!u2.default && r2.class, (_a = r2.ui) == null ? void 0 : _a.content] }) }), { default: N(() => {
      var _a2;
      return [D(n3.$slots, `content`, {}, () => {
        var _a3, _b, _c;
        return [e2.text ? (w(), s(`span`, { key: 0, class: y(v2.value.text({ class: (_a3 = r2.ui) == null ? void 0 : _a3.text })) }, k(e2.text), 3)) : o(``, true), ((_b = e2.kbds) == null ? void 0 : _b.length) ? (w(), s(`span`, { key: 1, class: y(v2.value.kbds({ class: (_c = r2.ui) == null ? void 0 : _c.kbds })) }, [(w(true), s(t, null, ne(e2.kbds, (e3, t2) => {
          var _a4;
          return w(), a(er, _({ key: t2, size: ((_a4 = r2.ui) == null ? void 0 : _a4.kbdsSize) || v2.value.kbdsSize() }, { ref_for: true }, typeof e3 == `string` ? { value: e3 } : e3), null, 16, [`size`]);
        }), 128))], 2)) : o(``, true)];
      }), e2.arrow ? (w(), a(A(Ln), _({ key: 0 }, g2.value, { class: v2.value.arrow({ class: (_a2 = r2.ui) == null ? void 0 : _a2.arrow }) }), null, 16, [`class`])) : o(``, true)];
    }), _: 3 }, 16, [`class`])];
  }), _: 3 }, 16)]), _: 3 }, 16));
} };
var or = ar;
export {
  rr as Badge_default,
  er as Kbd_default,
  wn as PopperContentPropsDefaultValue,
  tn as Presence,
  or as Tooltip_default,
  Vn as _sfc_main$15,
  kn as _sfc_main$16,
  Dn as _sfc_main$17,
  gn as _sfc_main$18,
  hn as _sfc_main$19,
  dn as _sfc_main$20,
  un as _sfc_main$21,
  Yt as _sfc_main$22,
  $ as context,
  rn as handleAndDispatchCustomEvent,
  qt as injectConfigProviderContext,
  Xn as portalTargetInjectionKey,
  nn as useEmitAsProps,
  fn as useForwardPropsEmits,
  An as useGraceArea,
  Zt as useId$1,
  Zn as usePortal
};
