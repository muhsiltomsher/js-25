import { __export as e } from "./chunk-GxRd6SvM.min.js";
import { BaseTransition as t, BaseTransitionPropsValidators as n, Comment as r, DeprecationTypes as i, EMPTY_OBJ as a, EffectScope as o, ErrorCodes as s, ErrorTypeStrings as c, Fragment as l, KeepAlive as u, NOOP as d, ReactiveEffect as f, Static as p, Suspense as m, Teleport as ee, Text as te, TrackOpTypes as ne, TriggerOpTypes as h, assertNumber as re, callWithAsyncErrorHandling as g, callWithErrorHandling as ie, camelize as _, capitalize as ae, cloneVNode as oe, compatUtils as v, computed as se, createBaseVNode as y, createBlock as ce, createCommentVNode as le, createElementBlock as ue, createHydrationRenderer as de, createPropsRestProxy as fe, createRenderer as pe, createSlots as me, createStaticVNode as he, createTextVNode as ge, createVNode as b, customRef as _e, defineAsyncComponent as ve, defineComponent as ye, defineEmits as be, defineExpose as xe, defineModel as Se, defineOptions as Ce, defineProps as we, defineSlots as Te, devtools as Ee, effect as De, effectScope as Oe, extend as x, getCurrentInstance as S, getCurrentScope as ke, getCurrentWatcher as Ae, getTransitionRawChildren as je, guardReactiveProps as Me, h as Ne, handleError as Pe, hasInjectionContext as Fe, hasOwn as Ie, hydrateOnIdle as Le, hydrateOnInteraction as Re, hydrateOnMediaQuery as ze, hydrateOnVisible as Be, hyphenate as C, includeBooleanAttr as Ve, initCustomFormatter as He, inject as Ue, invokeArrayFns as We, isArray as w, isFunction as Ge, isMemoSame as Ke, isModelListener as qe, isObject as Je, isOn as Ye, isPlainObject as Xe, isProxy as Ze, isReactive as Qe, isReadonly as $e, isRef as et, isRuntimeOnly as tt, isSet as T, isShallow as nt, isSpecialBooleanAttr as rt, isString as E, isSymbol as it, isVNode as at, looseEqual as D, looseIndexOf as O, looseToNumber$1 as ot, markRaw as st, mergeDefaults as ct, mergeModels as lt, mergeProps as ut, nextTick as dt, normalizeClass as ft, normalizeProps as pt, normalizeStyle as mt, onActivated as ht, onBeforeMount as gt, onBeforeUnmount as _t, onBeforeUpdate as vt, onDeactivated as yt, onErrorCaptured as bt, onMounted as xt, onRenderTracked as St, onRenderTriggered as Ct, onScopeDispose as wt, onServerPrefetch as Tt, onUnmounted as Et, onUpdated as Dt, onWatcherCleanup as Ot, openBlock as kt, popScopeId as At, provide as jt, proxyRefs as Mt, pushScopeId as Nt, queuePostFlushCb as Pt, reactive as Ft, readonly as It, ref as Lt, registerRuntimeCompiler as Rt, renderList as zt, renderSlot as Bt, resolveComponent as Vt, resolveDirective as Ht, resolveDynamicComponent as Ut, resolveFilter as Wt, resolveTransitionHooks as Gt, setBlockTracking as Kt, setDevtoolsHook as qt, setTransitionHooks as k, shallowReactive as Jt, shallowReadonly as Yt, shallowRef as Xt, ssrContextKey as Zt, ssrUtils as Qt, stop as $t, toDisplayString as en, toHandlerKey as tn, toHandlers as nn, toNumber as A, toRaw as rn, toRef as an, toRefs as on, toValue as sn, transformVNodeArgs as cn, triggerRef as ln, unref as un, useAttrs as dn, useId as fn, useModel as pn, useSSRContext as mn, useSlots as hn, useTemplateRef as gn, useTransitionState as _n, version$1 as vn, warn as yn, watch as bn, watchEffect as xn, watchPostEffect as Sn, watchSyncEffect as Cn, withAsyncContext as wn, withCtx as Tn, withDefaults as En, withDirectives as Dn, withMemo as On, withScopeId as kn } from "./runtime-core.esm-bundler-CFIgNHFT.min.js";
let j;
const An = typeof window < `u` && window.trustedTypes;
if (An) try {
  j = An.createPolicy(`vue`, { createHTML: (e3) => e3 });
} catch {
}
const jn = j ? (e3) => j.createHTML(e3) : (e3) => e3, Mn = `http://www.w3.org/2000/svg`, Nn = `http://www.w3.org/1998/Math/MathML`, M = typeof document < `u` ? document : null, Pn = M && M.createElement(`template`), Fn = { insert: (e3, t2, n2) => {
  t2.insertBefore(e3, n2 || null);
}, remove: (e3) => {
  let t2 = e3.parentNode;
  t2 && t2.removeChild(e3);
}, createElement: (e3, t2, n2, r2) => {
  let i2 = t2 === `svg` ? M.createElementNS(Mn, e3) : t2 === `mathml` ? M.createElementNS(Nn, e3) : n2 ? M.createElement(e3, { is: n2 }) : M.createElement(e3);
  return e3 === `select` && r2 && r2.multiple != null && i2.setAttribute(`multiple`, r2.multiple), i2;
}, createText: (e3) => M.createTextNode(e3), createComment: (e3) => M.createComment(e3), setText: (e3, t2) => {
  e3.nodeValue = t2;
}, setElementText: (e3, t2) => {
  e3.textContent = t2;
}, parentNode: (e3) => e3.parentNode, nextSibling: (e3) => e3.nextSibling, querySelector: (e3) => M.querySelector(e3), setScopeId(e3, t2) {
  e3.setAttribute(t2, ``);
}, insertStaticContent(e3, t2, n2, r2, i2, a2) {
  let o2 = n2 ? n2.previousSibling : t2.lastChild;
  if (i2 && (i2 === a2 || i2.nextSibling)) for (; t2.insertBefore(i2.cloneNode(true), n2), !(i2 === a2 || !(i2 = i2.nextSibling)); ) ;
  else {
    Pn.innerHTML = jn(r2 === `svg` ? `<svg>${e3}</svg>` : r2 === `mathml` ? `<math>${e3}</math>` : e3);
    let i3 = Pn.content;
    if (r2 === `svg` || r2 === `mathml`) {
      let e4 = i3.firstChild;
      for (; e4.firstChild; ) i3.appendChild(e4.firstChild);
      i3.removeChild(e4);
    }
    t2.insertBefore(i3, n2);
  }
  return [o2 ? o2.nextSibling : t2.firstChild, n2 ? n2.previousSibling : t2.lastChild];
} }, N = `transition`, P = `animation`, F = Symbol(`_vtc`), In = { name: String, type: String, css: { type: Boolean, default: true }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }, Ln = x({}, n, In), Rn = (e3) => (e3.displayName = `Transition`, e3.props = Ln, e3), zn = Rn((e3, { slots: n2 }) => Ne(t, Vn(e3), n2)), I = (e3, t2 = []) => {
  w(e3) ? e3.forEach((e4) => e4(...t2)) : e3 && e3(...t2);
}, Bn = (e3) => e3 ? w(e3) ? e3.some((e4) => e4.length > 1) : e3.length > 1 : false;
function Vn(e3) {
  let t2 = {};
  for (let n3 in e3) n3 in In || (t2[n3] = e3[n3]);
  if (e3.css === false) return t2;
  let { name: n2 = `v`, type: r2, duration: i2, enterFromClass: a2 = `${n2}-enter-from`, enterActiveClass: o2 = `${n2}-enter-active`, enterToClass: s2 = `${n2}-enter-to`, appearFromClass: c2 = a2, appearActiveClass: l2 = o2, appearToClass: u2 = s2, leaveFromClass: d2 = `${n2}-leave-from`, leaveActiveClass: f2 = `${n2}-leave-active`, leaveToClass: p2 = `${n2}-leave-to` } = e3, m2 = Hn(i2), ee2 = m2 && m2[0], te2 = m2 && m2[1], { onBeforeEnter: ne2, onEnter: h2, onEnterCancelled: re2, onLeave: g2, onLeaveCancelled: ie2, onBeforeAppear: _2 = ne2, onAppear: ae2 = h2, onAppearCancelled: oe2 = re2 } = t2, v2 = (e4, t3, n3, r3) => {
    e4._enterCancelled = r3, R(e4, t3 ? u2 : s2), R(e4, t3 ? l2 : o2), n3 && n3();
  }, se2 = (e4, t3) => {
    e4._isLeaving = false, R(e4, d2), R(e4, p2), R(e4, f2), t3 && t3();
  }, y2 = (e4) => (t3, n3) => {
    let i3 = e4 ? ae2 : h2, o3 = () => v2(t3, e4, n3);
    I(i3, [t3, o3]), Wn(() => {
      R(t3, e4 ? c2 : a2), L(t3, e4 ? u2 : s2), Bn(i3) || Kn(t3, r2, ee2, o3);
    });
  };
  return x(t2, { onBeforeEnter(e4) {
    I(ne2, [e4]), L(e4, a2), L(e4, o2);
  }, onBeforeAppear(e4) {
    I(_2, [e4]), L(e4, c2), L(e4, l2);
  }, onEnter: y2(false), onAppear: y2(true), onLeave(e4, t3) {
    e4._isLeaving = true;
    let n3 = () => se2(e4, t3);
    L(e4, d2), e4._enterCancelled ? (L(e4, f2), Xn()) : (Xn(), L(e4, f2)), Wn(() => {
      e4._isLeaving && (R(e4, d2), L(e4, p2), Bn(g2) || Kn(e4, r2, te2, n3));
    }), I(g2, [e4, n3]);
  }, onEnterCancelled(e4) {
    v2(e4, false, void 0, true), I(re2, [e4]);
  }, onAppearCancelled(e4) {
    v2(e4, true, void 0, true), I(oe2, [e4]);
  }, onLeaveCancelled(e4) {
    se2(e4), I(ie2, [e4]);
  } });
}
function Hn(e3) {
  if (e3 == null) return null;
  if (Je(e3)) return [Un(e3.enter), Un(e3.leave)];
  {
    let t2 = Un(e3);
    return [t2, t2];
  }
}
function Un(e3) {
  let t2 = A(e3);
  return t2;
}
function L(e3, t2) {
  t2.split(/\s+/).forEach((t3) => t3 && e3.classList.add(t3)), (e3[F] || (e3[F] = /* @__PURE__ */ new Set())).add(t2);
}
function R(e3, t2) {
  t2.split(/\s+/).forEach((t3) => t3 && e3.classList.remove(t3));
  let n2 = e3[F];
  n2 && (n2.delete(t2), n2.size || (e3[F] = void 0));
}
function Wn(e3) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e3);
  });
}
let Gn = 0;
function Kn(e3, t2, n2, r2) {
  let i2 = e3._endId = ++Gn, a2 = () => {
    i2 === e3._endId && r2();
  };
  if (n2 != null) return setTimeout(a2, n2);
  let { type: o2, timeout: s2, propCount: c2 } = qn(e3, t2);
  if (!o2) return r2();
  let l2 = o2 + `end`, u2 = 0, d2 = () => {
    e3.removeEventListener(l2, f2), a2();
  }, f2 = (t3) => {
    t3.target === e3 && ++u2 >= c2 && d2();
  };
  setTimeout(() => {
    u2 < c2 && d2();
  }, s2 + 1), e3.addEventListener(l2, f2);
}
function qn(e3, t2) {
  let n2 = window.getComputedStyle(e3), r2 = (e4) => (n2[e4] || ``).split(`, `), i2 = r2(`${N}Delay`), a2 = r2(`${N}Duration`), o2 = Jn(i2, a2), s2 = r2(`${P}Delay`), c2 = r2(`${P}Duration`), l2 = Jn(s2, c2), u2 = null, d2 = 0, f2 = 0;
  t2 === N ? o2 > 0 && (u2 = N, d2 = o2, f2 = a2.length) : t2 === P ? l2 > 0 && (u2 = P, d2 = l2, f2 = c2.length) : (d2 = Math.max(o2, l2), u2 = d2 > 0 ? o2 > l2 ? N : P : null, f2 = u2 ? u2 === N ? a2.length : c2.length : 0);
  let p2 = u2 === N && /\b(transform|all)(,|$)/.test(r2(`${N}Property`).toString());
  return { type: u2, timeout: d2, propCount: f2, hasTransform: p2 };
}
function Jn(e3, t2) {
  for (; e3.length < t2.length; ) e3 = e3.concat(e3);
  return Math.max(...t2.map((t3, n2) => Yn(t3) + Yn(e3[n2])));
}
function Yn(e3) {
  return e3 === `auto` ? 0 : Number(e3.slice(0, -1).replace(`,`, `.`)) * 1e3;
}
function Xn() {
  return document.body.offsetHeight;
}
function Zn(e3, t2, n2) {
  let r2 = e3[F];
  r2 && (t2 = (t2 ? [t2, ...r2] : [...r2]).join(` `)), t2 == null ? e3.removeAttribute(`class`) : n2 ? e3.setAttribute(`class`, t2) : e3.className = t2;
}
const z = Symbol(`_vod`), Qn = Symbol(`_vsh`), $n = { beforeMount(e3, { value: t2 }, { transition: n2 }) {
  e3[z] = e3.style.display === `none` ? `` : e3.style.display, n2 && t2 ? n2.beforeEnter(e3) : B(e3, t2);
}, mounted(e3, { value: t2 }, { transition: n2 }) {
  n2 && t2 && n2.enter(e3);
}, updated(e3, { value: t2, oldValue: n2 }, { transition: r2 }) {
  !t2 != !n2 && (r2 ? t2 ? (r2.beforeEnter(e3), B(e3, true), r2.enter(e3)) : r2.leave(e3, () => {
    B(e3, false);
  }) : B(e3, t2));
}, beforeUnmount(e3, { value: t2 }) {
  B(e3, t2);
} };
function B(e3, t2) {
  e3.style.display = t2 ? e3[z] : `none`, e3[Qn] = !t2;
}
function er() {
  $n.getSSRProps = ({ value: e3 }) => {
    if (!e3) return { style: { display: `none` } };
  };
}
const tr = Symbol(``);
function nr(e3) {
  let t2 = S();
  if (!t2) return;
  let n2 = t2.ut = (n3 = e3(t2.proxy)) => {
    Array.from(document.querySelectorAll(`[data-v-owner="${t2.uid}"]`)).forEach((e4) => V(e4, n3));
  }, r2 = () => {
    let r3 = e3(t2.proxy);
    t2.ce ? V(t2.ce, r3) : rr(t2.subTree, r3), n2(r3);
  };
  vt(() => {
    Pt(r2);
  }), xt(() => {
    bn(r2, d, { flush: `post` });
    let e4 = new MutationObserver(r2);
    e4.observe(t2.subTree.el.parentNode, { childList: true }), Et(() => e4.disconnect());
  });
}
function rr(e3, t2) {
  if (e3.shapeFlag & 128) {
    let n2 = e3.suspense;
    e3 = n2.activeBranch, n2.pendingBranch && !n2.isHydrating && n2.effects.push(() => {
      rr(n2.activeBranch, t2);
    });
  }
  for (; e3.component; ) e3 = e3.component.subTree;
  if (e3.shapeFlag & 1 && e3.el) V(e3.el, t2);
  else if (e3.type === l) e3.children.forEach((e4) => rr(e4, t2));
  else if (e3.type === p) {
    let { el: n2, anchor: r2 } = e3;
    for (; n2 && (V(n2, t2), n2 !== r2); ) n2 = n2.nextSibling;
  }
}
function V(e3, t2) {
  if (e3.nodeType === 1) {
    let n2 = e3.style, r2 = ``;
    for (let e4 in t2) n2.setProperty(`--${e4}`, t2[e4]), r2 += `--${e4}: ${t2[e4]};`;
    n2[tr] = r2;
  }
}
const ir = /(^|;)\s*display\s*:/;
function ar(e3, t2, n2) {
  let r2 = e3.style, i2 = E(n2), a2 = false;
  if (n2 && !i2) {
    if (t2) if (E(t2)) for (let e4 of t2.split(`;`)) {
      let t3 = e4.slice(0, e4.indexOf(`:`)).trim();
      n2[t3] ?? H(r2, t3, ``);
    }
    else for (let e4 in t2) n2[e4] ?? H(r2, e4, ``);
    for (let e4 in n2) e4 === `display` && (a2 = true), H(r2, e4, n2[e4]);
  } else if (i2) {
    if (t2 !== n2) {
      let e4 = r2[tr];
      e4 && (n2 += `;` + e4), r2.cssText = n2, a2 = ir.test(n2);
    }
  } else t2 && e3.removeAttribute(`style`);
  z in e3 && (e3[z] = a2 ? r2.display : ``, e3[Qn] && (r2.display = `none`));
}
const or = /\s*!important$/;
function H(e3, t2, n2) {
  if (w(n2)) n2.forEach((n3) => H(e3, t2, n3));
  else if (n2 ?? (n2 = ``), t2.startsWith(`--`)) e3.setProperty(t2, n2);
  else {
    let r2 = lr(e3, t2);
    or.test(n2) ? e3.setProperty(C(r2), n2.replace(or, ``), `important`) : e3[r2] = n2;
  }
}
const sr = [`Webkit`, `Moz`, `ms`], cr = {};
function lr(e3, t2) {
  let n2 = cr[t2];
  if (n2) return n2;
  let r2 = _(t2);
  if (r2 !== `filter` && r2 in e3) return cr[t2] = r2;
  r2 = ae(r2);
  for (let n3 = 0; n3 < sr.length; n3++) {
    let i2 = sr[n3] + r2;
    if (i2 in e3) return cr[t2] = i2;
  }
  return t2;
}
const ur = `http://www.w3.org/1999/xlink`;
function dr(e3, t2, n2, r2, i2, a2 = rt(t2)) {
  r2 && t2.startsWith(`xlink:`) ? n2 == null ? e3.removeAttributeNS(ur, t2.slice(6, t2.length)) : e3.setAttributeNS(ur, t2, n2) : n2 == null || a2 && !Ve(n2) ? e3.removeAttribute(t2) : e3.setAttribute(t2, a2 ? `` : it(n2) ? String(n2) : n2);
}
function fr(e3, t2, n2, r2, i2) {
  if (t2 === `innerHTML` || t2 === `textContent`) {
    n2 != null && (e3[t2] = t2 === `innerHTML` ? jn(n2) : n2);
    return;
  }
  let a2 = e3.tagName;
  if (t2 === `value` && a2 !== `PROGRESS` && !a2.includes(`-`)) {
    let r3 = a2 === `OPTION` ? e3.getAttribute(`value`) || `` : e3.value, i3 = n2 == null ? e3.type === `checkbox` ? `on` : `` : String(n2);
    (r3 !== i3 || !(`_value` in e3)) && (e3.value = i3), n2 ?? e3.removeAttribute(t2), e3._value = n2;
    return;
  }
  let o2 = false;
  if (n2 === `` || n2 == null) {
    let r3 = typeof e3[t2];
    r3 === `boolean` ? n2 = Ve(n2) : n2 == null && r3 === `string` ? (n2 = ``, o2 = true) : r3 === `number` && (n2 = 0, o2 = true);
  }
  try {
    e3[t2] = n2;
  } catch {
  }
  o2 && e3.removeAttribute(i2 || t2);
}
function U(e3, t2, n2, r2) {
  e3.addEventListener(t2, n2, r2);
}
function pr(e3, t2, n2, r2) {
  e3.removeEventListener(t2, n2, r2);
}
const mr = Symbol(`_vei`);
function hr(e3, t2, n2, r2, i2 = null) {
  let a2 = e3[mr] || (e3[mr] = {}), o2 = a2[t2];
  if (r2 && o2) o2.value = r2;
  else {
    let [n3, s2] = _r(t2);
    if (r2) {
      let o3 = a2[t2] = xr(r2, i2);
      U(e3, n3, o3, s2);
    } else o2 && (pr(e3, n3, o2, s2), a2[t2] = void 0);
  }
}
const gr = /(?:Once|Passive|Capture)$/;
function _r(e3) {
  let t2;
  if (gr.test(e3)) {
    t2 = {};
    let n3;
    for (; n3 = e3.match(gr); ) e3 = e3.slice(0, e3.length - n3[0].length), t2[n3[0].toLowerCase()] = true;
  }
  let n2 = e3[2] === `:` ? e3.slice(3) : C(e3.slice(2));
  return [n2, t2];
}
let vr = 0;
const yr = Promise.resolve(), br = () => vr || (yr.then(() => vr = 0), vr = Date.now());
function xr(e3, t2) {
  let n2 = (e4) => {
    if (!e4._vts) e4._vts = Date.now();
    else if (e4._vts <= n2.attached) return;
    g(Sr(e4, n2.value), t2, 5, [e4]);
  };
  return n2.value = e3, n2.attached = br(), n2;
}
function Sr(e3, t2) {
  if (w(t2)) {
    let n2 = e3.stopImmediatePropagation;
    return e3.stopImmediatePropagation = () => {
      n2.call(e3), e3._stopped = true;
    }, t2.map((e4) => (t3) => !t3._stopped && e4 && e4(t3));
  } else return t2;
}
const Cr = (e3) => e3.charCodeAt(0) === 111 && e3.charCodeAt(1) === 110 && e3.charCodeAt(2) > 96 && e3.charCodeAt(2) < 123, wr = (e3, t2, n2, r2, i2, a2) => {
  let o2 = i2 === `svg`;
  t2 === `class` ? Zn(e3, r2, o2) : t2 === `style` ? ar(e3, n2, r2) : Ye(t2) ? qe(t2) || hr(e3, t2, n2, r2, a2) : (t2[0] === `.` ? (t2 = t2.slice(1), true) : t2[0] === `^` ? (t2 = t2.slice(1), false) : Tr(e3, t2, r2, o2)) ? (fr(e3, t2, r2), !e3.tagName.includes(`-`) && (t2 === `value` || t2 === `checked` || t2 === `selected`) && dr(e3, t2, r2, o2, a2, t2 !== `value`)) : e3._isVueCE && (/[A-Z]/.test(t2) || !E(r2)) ? fr(e3, _(t2), r2, a2, t2) : (t2 === `true-value` ? e3._trueValue = r2 : t2 === `false-value` && (e3._falseValue = r2), dr(e3, t2, r2, o2));
};
function Tr(e3, t2, n2, r2) {
  if (r2) return !!(t2 === `innerHTML` || t2 === `textContent` || t2 in e3 && Cr(t2) && Ge(n2));
  if (t2 === `spellcheck` || t2 === `draggable` || t2 === `translate` || t2 === `autocorrect` || t2 === `form` || t2 === `list` && e3.tagName === `INPUT` || t2 === `type` && e3.tagName === `TEXTAREA`) return false;
  if (t2 === `width` || t2 === `height`) {
    let t3 = e3.tagName;
    if (t3 === `IMG` || t3 === `VIDEO` || t3 === `CANVAS` || t3 === `SOURCE`) return false;
  }
  return Cr(t2) && E(n2) ? false : t2 in e3;
}
const Er = {};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Dr(e3, t2, n2) {
  let r2 = ye(e3, t2);
  Xe(r2) && x(r2, t2);
  class i2 extends Ar {
    constructor(e4) {
      super(r2, e4, n2);
    }
  }
  return i2.def = r2, i2;
}
const Or = (e3, t2) => /* @__PURE__ */ Dr(e3, t2, ui), kr = typeof HTMLElement < `u` ? HTMLElement : class {
};
var Ar = class e2 extends kr {
  constructor(e3, t2 = {}, n2 = $) {
    super(), this._def = e3, this._props = t2, this._createApp = n2, this._isVueCE = true, this._instance = null, this._app = null, this._nonce = this._def.nonce, this._connected = false, this._resolved = false, this._numberProps = null, this._styleChildren = /* @__PURE__ */ new WeakSet(), this._ob = null, this.shadowRoot && n2 !== $ ? this._root = this.shadowRoot : e3.shadowRoot === false ? this._root = this : (this.attachShadow({ mode: `open` }), this._root = this.shadowRoot);
  }
  connectedCallback() {
    if (!this.isConnected) return;
    !this.shadowRoot && !this._resolved && this._parseSlots(), this._connected = true;
    let t2 = this;
    for (; t2 && (t2 = t2.parentNode || t2.host); ) if (t2 instanceof e2) {
      this._parent = t2;
      break;
    }
    this._instance || (this._resolved ? this._mount(this._def) : t2 && t2._pendingResolve ? this._pendingResolve = t2._pendingResolve.then(() => {
      this._pendingResolve = void 0, this._resolveDef();
    }) : this._resolveDef());
  }
  _setParent(e3 = this._parent) {
    e3 && (this._instance.parent = e3._instance, this._inheritParentContext(e3));
  }
  _inheritParentContext(e3 = this._parent) {
    e3 && this._app && Object.setPrototypeOf(this._app._context.provides, e3._instance.provides);
  }
  disconnectedCallback() {
    this._connected = false, dt(() => {
      this._connected || (this._ob && (this._ob.disconnect(), this._ob = null), this._app && this._app.unmount(), this._instance && (this._instance.ce = void 0), this._app = this._instance = null);
    });
  }
  _resolveDef() {
    if (this._pendingResolve) return;
    for (let e4 = 0; e4 < this.attributes.length; e4++) this._setAttr(this.attributes[e4].name);
    this._ob = new MutationObserver((e4) => {
      for (let t3 of e4) this._setAttr(t3.attributeName);
    }), this._ob.observe(this, { attributes: true });
    let e3 = (e4, t3 = false) => {
      this._resolved = true, this._pendingResolve = void 0;
      let { props: n2, styles: r2 } = e4, i2;
      if (n2 && !w(n2)) for (let e5 in n2) {
        let t4 = n2[e5];
        (t4 === Number || t4 && t4.type === Number) && (e5 in this._props && (this._props[e5] = A(this._props[e5])), (i2 || (i2 = /* @__PURE__ */ Object.create(null)))[_(e5)] = true);
      }
      this._numberProps = i2, this._resolveProps(e4), this.shadowRoot && this._applyStyles(r2), this._mount(e4);
    }, t2 = this._def.__asyncLoader;
    t2 ? this._pendingResolve = t2().then((t3) => e3(this._def = t3, true)) : e3(this._def);
  }
  _mount(e3) {
    this._app = this._createApp(e3), this._inheritParentContext(), e3.configureApp && e3.configureApp(this._app), this._app._ceVNode = this._createVNode(), this._app.mount(this._root);
    let t2 = this._instance && this._instance.exposed;
    if (t2) for (let e4 in t2) Ie(this, e4) || Object.defineProperty(this, e4, { get: () => un(t2[e4]) });
  }
  _resolveProps(e3) {
    let { props: t2 } = e3, n2 = w(t2) ? t2 : Object.keys(t2 || {});
    for (let e4 of Object.keys(this)) e4[0] !== `_` && n2.includes(e4) && this._setProp(e4, this[e4]);
    for (let e4 of n2.map(_)) Object.defineProperty(this, e4, { get() {
      return this._getProp(e4);
    }, set(t3) {
      this._setProp(e4, t3, true, true);
    } });
  }
  _setAttr(e3) {
    if (e3.startsWith(`data-v-`)) return;
    let t2 = this.hasAttribute(e3), n2 = t2 ? this.getAttribute(e3) : Er, r2 = _(e3);
    t2 && this._numberProps && this._numberProps[r2] && (n2 = A(n2)), this._setProp(r2, n2, false, true);
  }
  _getProp(e3) {
    return this._props[e3];
  }
  _setProp(e3, t2, n2 = true, r2 = false) {
    if (t2 !== this._props[e3] && (t2 === Er ? delete this._props[e3] : (this._props[e3] = t2, e3 === `key` && this._app && (this._app._ceVNode.key = t2)), r2 && this._instance && this._update(), n2)) {
      let n3 = this._ob;
      n3 && n3.disconnect(), t2 === true ? this.setAttribute(C(e3), ``) : typeof t2 == `string` || typeof t2 == `number` ? this.setAttribute(C(e3), t2 + ``) : t2 || this.removeAttribute(C(e3)), n3 && n3.observe(this, { attributes: true });
    }
  }
  _update() {
    let e3 = this._createVNode();
    this._app && (e3.appContext = this._app._context), ci(e3, this._root);
  }
  _createVNode() {
    let e3 = {};
    this.shadowRoot || (e3.onVnodeMounted = e3.onVnodeUpdated = this._renderSlots.bind(this));
    let t2 = b(this._def, x(e3, this._props));
    return this._instance || (t2.ce = (e4) => {
      this._instance = e4, e4.ce = this, e4.isCE = true;
      let t3 = (e5, t4) => {
        this.dispatchEvent(new CustomEvent(e5, Xe(t4[0]) ? x({ detail: t4 }, t4[0]) : { detail: t4 }));
      };
      e4.emit = (e5, ...n2) => {
        t3(e5, n2), C(e5) !== e5 && t3(C(e5), n2);
      }, this._setParent();
    }), t2;
  }
  _applyStyles(e3, t2) {
    if (!e3) return;
    if (t2) {
      if (t2 === this._def || this._styleChildren.has(t2)) return;
      this._styleChildren.add(t2);
    }
    let n2 = this._nonce;
    for (let t3 = e3.length - 1; t3 >= 0; t3--) {
      let r2 = document.createElement(`style`);
      n2 && r2.setAttribute(`nonce`, n2), r2.textContent = e3[t3], this.shadowRoot.prepend(r2);
    }
  }
  _parseSlots() {
    let e3 = this._slots = {}, t2;
    for (; t2 = this.firstChild; ) {
      let n2 = t2.nodeType === 1 && t2.getAttribute(`slot`) || `default`;
      (e3[n2] || (e3[n2] = [])).push(t2), this.removeChild(t2);
    }
  }
  _renderSlots() {
    let e3 = (this._teleportTarget || this).querySelectorAll(`slot`), t2 = this._instance.type.__scopeId;
    for (let n2 = 0; n2 < e3.length; n2++) {
      let r2 = e3[n2], i2 = r2.getAttribute(`name`) || `default`, a2 = this._slots[i2], o2 = r2.parentNode;
      if (a2) for (let e4 of a2) {
        if (t2 && e4.nodeType === 1) {
          let n3 = t2 + `-s`, r3 = document.createTreeWalker(e4, 1);
          e4.setAttribute(n3, ``);
          let i3;
          for (; i3 = r3.nextNode(); ) i3.setAttribute(n3, ``);
        }
        o2.insertBefore(e4, r2);
      }
      else for (; r2.firstChild; ) o2.insertBefore(r2.firstChild, r2);
      o2.removeChild(r2);
    }
  }
  _injectChildStyle(e3) {
    this._applyStyles(e3.styles, e3);
  }
  _removeChildStyle(e3) {
  }
};
function jr(e3) {
  let t2 = S(), n2 = t2 && t2.ce;
  return n2 || null;
}
function Mr() {
  let e3 = jr();
  return e3 && e3.shadowRoot;
}
function Nr(e3 = `$style`) {
  {
    let t2 = S();
    if (!t2) return a;
    let n2 = t2.type.__cssModules;
    if (!n2) return a;
    let r2 = n2[e3];
    return r2 || a;
  }
}
const Pr = /* @__PURE__ */ new WeakMap(), Fr = /* @__PURE__ */ new WeakMap(), W = Symbol(`_moveCb`), Ir = Symbol(`_enterCb`), Lr = (e3) => (delete e3.props.mode, e3), Rr = Lr({ name: `TransitionGroup`, props: x({}, Ln, { tag: String, moveClass: String }), setup(e3, { slots: t2 }) {
  let n2 = S(), r2 = _n(), i2, a2;
  return Dt(() => {
    if (!i2.length) return;
    let t3 = e3.moveClass || `${e3.name || `v`}-move`;
    if (!Ur(i2[0].el, n2.vnode.el, t3)) {
      i2 = [];
      return;
    }
    i2.forEach(Br), i2.forEach(Vr);
    let r3 = i2.filter(Hr);
    Xn(), r3.forEach((e4) => {
      let n3 = e4.el, r4 = n3.style;
      L(n3, t3), r4.transform = r4.webkitTransform = r4.transitionDuration = ``;
      let i3 = n3[W] = (e5) => {
        e5 && e5.target !== n3 || (!e5 || /transform$/.test(e5.propertyName)) && (n3.removeEventListener(`transitionend`, i3), n3[W] = null, R(n3, t3));
      };
      n3.addEventListener(`transitionend`, i3);
    }), i2 = [];
  }), () => {
    let o2 = rn(e3), s2 = Vn(o2), c2 = o2.tag || l;
    if (i2 = [], a2) for (let e4 = 0; e4 < a2.length; e4++) {
      let t3 = a2[e4];
      t3.el && t3.el instanceof Element && (i2.push(t3), k(t3, Gt(t3, s2, r2, n2)), Pr.set(t3, t3.el.getBoundingClientRect()));
    }
    a2 = t2.default ? je(t2.default()) : [];
    for (let e4 = 0; e4 < a2.length; e4++) {
      let t3 = a2[e4];
      t3.key != null && k(t3, Gt(t3, s2, r2, n2));
    }
    return b(c2, null, a2);
  };
} }), zr = Rr;
function Br(e3) {
  let t2 = e3.el;
  t2[W] && t2[W](), t2[Ir] && t2[Ir]();
}
function Vr(e3) {
  Fr.set(e3, e3.el.getBoundingClientRect());
}
function Hr(e3) {
  let t2 = Pr.get(e3), n2 = Fr.get(e3), r2 = t2.left - n2.left, i2 = t2.top - n2.top;
  if (r2 || i2) {
    let t3 = e3.el.style;
    return t3.transform = t3.webkitTransform = `translate(${r2}px,${i2}px)`, t3.transitionDuration = `0s`, e3;
  }
}
function Ur(e3, t2, n2) {
  let r2 = e3.cloneNode(), i2 = e3[F];
  i2 && i2.forEach((e4) => {
    e4.split(/\s+/).forEach((e5) => e5 && r2.classList.remove(e5));
  }), n2.split(/\s+/).forEach((e4) => e4 && r2.classList.add(e4)), r2.style.display = `none`;
  let a2 = t2.nodeType === 1 ? t2 : t2.parentNode;
  a2.appendChild(r2);
  let { hasTransform: o2 } = qn(r2);
  return a2.removeChild(r2), o2;
}
const G = (e3) => {
  let t2 = e3.props[`onUpdate:modelValue`] || false;
  return w(t2) ? (e4) => We(t2, e4) : t2;
};
function Wr(e3) {
  e3.target.composing = true;
}
function Gr(e3) {
  let t2 = e3.target;
  t2.composing && (t2.composing = false, t2.dispatchEvent(new Event(`input`)));
}
const K = Symbol(`_assign`), q = { created(e3, { modifiers: { lazy: t2, trim: n2, number: r2 } }, i2) {
  e3[K] = G(i2);
  let a2 = r2 || i2.props && i2.props.type === `number`;
  U(e3, t2 ? `change` : `input`, (t3) => {
    if (t3.target.composing) return;
    let r3 = e3.value;
    n2 && (r3 = r3.trim()), a2 && (r3 = ot(r3)), e3[K](r3);
  }), n2 && U(e3, `change`, () => {
    e3.value = e3.value.trim();
  }), t2 || (U(e3, `compositionstart`, Wr), U(e3, `compositionend`, Gr), U(e3, `change`, Gr));
}, mounted(e3, { value: t2 }) {
  e3.value = t2 ?? ``;
}, beforeUpdate(e3, { value: t2, oldValue: n2, modifiers: { lazy: r2, trim: i2, number: a2 } }, o2) {
  if (e3[K] = G(o2), e3.composing) return;
  let s2 = (a2 || e3.type === `number`) && !/^0\d/.test(e3.value) ? ot(e3.value) : e3.value, c2 = t2 ?? ``;
  s2 !== c2 && (document.activeElement === e3 && e3.type !== `range` && (r2 && t2 === n2 || i2 && e3.value.trim() === c2) || (e3.value = c2));
} }, J = { deep: true, created(e3, t2, n2) {
  e3[K] = G(n2), U(e3, `change`, () => {
    let t3 = e3._modelValue, n3 = X(e3), r2 = e3.checked, i2 = e3[K];
    if (w(t3)) {
      let e4 = O(t3, n3), a2 = e4 !== -1;
      if (r2 && !a2) i2(t3.concat(n3));
      else if (!r2 && a2) {
        let n4 = [...t3];
        n4.splice(e4, 1), i2(n4);
      }
    } else if (T(t3)) {
      let e4 = new Set(t3);
      r2 ? e4.add(n3) : e4.delete(n3), i2(e4);
    } else i2(Yr(e3, r2));
  });
}, mounted: Kr, beforeUpdate(e3, t2, n2) {
  e3[K] = G(n2), Kr(e3, t2, n2);
} };
function Kr(e3, { value: t2, oldValue: n2 }, r2) {
  e3._modelValue = t2;
  let i2;
  if (w(t2)) i2 = O(t2, r2.props.value) > -1;
  else if (T(t2)) i2 = t2.has(r2.props.value);
  else {
    if (t2 === n2) return;
    i2 = D(t2, Yr(e3, true));
  }
  e3.checked !== i2 && (e3.checked = i2);
}
const Y = { created(e3, { value: t2 }, n2) {
  e3.checked = D(t2, n2.props.value), e3[K] = G(n2), U(e3, `change`, () => {
    e3[K](X(e3));
  });
}, beforeUpdate(e3, { value: t2, oldValue: n2 }, r2) {
  e3[K] = G(r2), t2 !== n2 && (e3.checked = D(t2, r2.props.value));
} }, qr = { deep: true, created(e3, { value: t2, modifiers: { number: n2 } }, r2) {
  let i2 = T(t2);
  U(e3, `change`, () => {
    let t3 = Array.prototype.filter.call(e3.options, (e4) => e4.selected).map((e4) => n2 ? ot(X(e4)) : X(e4));
    e3[K](e3.multiple ? i2 ? new Set(t3) : t3 : t3[0]), e3._assigning = true, dt(() => {
      e3._assigning = false;
    });
  }), e3[K] = G(r2);
}, mounted(e3, { value: t2 }) {
  Jr(e3, t2);
}, beforeUpdate(e3, t2, n2) {
  e3[K] = G(n2);
}, updated(e3, { value: t2 }) {
  e3._assigning || Jr(e3, t2);
} };
function Jr(e3, t2) {
  let n2 = e3.multiple, r2 = w(t2);
  if (!(n2 && !r2 && !T(t2))) {
    for (let i2 = 0, a2 = e3.options.length; i2 < a2; i2++) {
      let a3 = e3.options[i2], o2 = X(a3);
      if (n2) if (r2) {
        let e4 = typeof o2;
        e4 === `string` || e4 === `number` ? a3.selected = t2.some((e5) => String(e5) === String(o2)) : a3.selected = O(t2, o2) > -1;
      } else a3.selected = t2.has(o2);
      else if (D(X(a3), t2)) {
        e3.selectedIndex !== i2 && (e3.selectedIndex = i2);
        return;
      }
    }
    !n2 && e3.selectedIndex !== -1 && (e3.selectedIndex = -1);
  }
}
function X(e3) {
  return `_value` in e3 ? e3._value : e3.value;
}
function Yr(e3, t2) {
  let n2 = t2 ? `_trueValue` : `_falseValue`;
  return n2 in e3 ? e3[n2] : t2;
}
const Xr = { created(e3, t2, n2) {
  Z(e3, t2, n2, null, `created`);
}, mounted(e3, t2, n2) {
  Z(e3, t2, n2, null, `mounted`);
}, beforeUpdate(e3, t2, n2, r2) {
  Z(e3, t2, n2, r2, `beforeUpdate`);
}, updated(e3, t2, n2, r2) {
  Z(e3, t2, n2, r2, `updated`);
} };
function Zr(e3, t2) {
  switch (e3) {
    case `SELECT`:
      return qr;
    case `TEXTAREA`:
      return q;
    default:
      switch (t2) {
        case `checkbox`:
          return J;
        case `radio`:
          return Y;
        default:
          return q;
      }
  }
}
function Z(e3, t2, n2, r2, i2) {
  let a2 = Zr(e3.tagName, n2.props && n2.props.type), o2 = a2[i2];
  o2 && o2(e3, t2, n2, r2);
}
function Qr() {
  q.getSSRProps = ({ value: e3 }) => ({ value: e3 }), Y.getSSRProps = ({ value: e3 }, t2) => {
    if (t2.props && D(t2.props.value, e3)) return { checked: true };
  }, J.getSSRProps = ({ value: e3 }, t2) => {
    if (w(e3)) {
      if (t2.props && O(e3, t2.props.value) > -1) return { checked: true };
    } else if (T(e3)) {
      if (t2.props && e3.has(t2.props.value)) return { checked: true };
    } else if (e3) return { checked: true };
  }, Xr.getSSRProps = (e3, t2) => {
    if (typeof t2.type != `string`) return;
    let n2 = Zr(t2.type.toUpperCase(), t2.props && t2.props.type);
    if (n2.getSSRProps) return n2.getSSRProps(e3, t2);
  };
}
const $r = [`ctrl`, `shift`, `alt`, `meta`], ei = { stop: (e3) => e3.stopPropagation(), prevent: (e3) => e3.preventDefault(), self: (e3) => e3.target !== e3.currentTarget, ctrl: (e3) => !e3.ctrlKey, shift: (e3) => !e3.shiftKey, alt: (e3) => !e3.altKey, meta: (e3) => !e3.metaKey, left: (e3) => `button` in e3 && e3.button !== 0, middle: (e3) => `button` in e3 && e3.button !== 1, right: (e3) => `button` in e3 && e3.button !== 2, exact: (e3, t2) => $r.some((n2) => e3[`${n2}Key`] && !t2.includes(n2)) }, ti = (e3, t2) => {
  let n2 = e3._withMods || (e3._withMods = {}), r2 = t2.join(`.`);
  return n2[r2] || (n2[r2] = (n3, ...r3) => {
    for (let e4 = 0; e4 < t2.length; e4++) {
      let r4 = ei[t2[e4]];
      if (r4 && r4(n3, t2)) return;
    }
    return e3(n3, ...r3);
  });
}, ni = { esc: `escape`, space: ` `, up: `arrow-up`, left: `arrow-left`, right: `arrow-right`, down: `arrow-down`, delete: `backspace` }, ri = (e3, t2) => {
  let n2 = e3._withKeys || (e3._withKeys = {}), r2 = t2.join(`.`);
  return n2[r2] || (n2[r2] = (n3) => {
    if (!(`key` in n3)) return;
    let r3 = C(n3.key);
    if (t2.some((e4) => e4 === r3 || ni[e4] === r3)) return e3(n3);
  });
}, ii = x({ patchProp: wr }, Fn);
let Q, ai = false;
function oi() {
  return Q || (Q = pe(ii));
}
function si() {
  return Q = ai ? Q : de(ii), ai = true, Q;
}
const ci = (...e3) => {
  oi().render(...e3);
}, li = (...e3) => {
  si().hydrate(...e3);
}, $ = (...e3) => {
  let t2 = oi().createApp(...e3), { mount: n2 } = t2;
  return t2.mount = (e4) => {
    let r2 = fi(e4);
    if (!r2) return;
    let i2 = t2._component;
    !Ge(i2) && !i2.render && !i2.template && (i2.template = r2.innerHTML), r2.nodeType === 1 && (r2.textContent = ``);
    let a2 = n2(r2, false, di(r2));
    return r2 instanceof Element && (r2.removeAttribute(`v-cloak`), r2.setAttribute(`data-v-app`, ``)), a2;
  }, t2;
}, ui = (...e3) => {
  let t2 = si().createApp(...e3), { mount: n2 } = t2;
  return t2.mount = (e4) => {
    let t3 = fi(e4);
    if (t3) return n2(t3, true, di(t3));
  }, t2;
};
function di(e3) {
  if (e3 instanceof SVGElement) return `svg`;
  if (typeof MathMLElement == `function` && e3 instanceof MathMLElement) return `mathml`;
}
function fi(e3) {
  if (E(e3)) {
    let t2 = document.querySelector(e3);
    return t2;
  }
  return e3;
}
let pi = false;
const mi = () => {
  pi || (pi = true, Qr(), er());
};
var hi = {};
e(hi, { BaseTransition: () => t, BaseTransitionPropsValidators: () => n, Comment: () => r, DeprecationTypes: () => i, EffectScope: () => o, ErrorCodes: () => s, ErrorTypeStrings: () => c, Fragment: () => l, KeepAlive: () => u, ReactiveEffect: () => f, Static: () => p, Suspense: () => m, Teleport: () => ee, Text: () => te, TrackOpTypes: () => ne, Transition: () => zn, TransitionGroup: () => zr, TriggerOpTypes: () => h, VueElement: () => Ar, assertNumber: () => re, callWithAsyncErrorHandling: () => g, callWithErrorHandling: () => ie, camelize: () => _, capitalize: () => ae, cloneVNode: () => oe, compatUtils: () => v, compile: () => gi, computed: () => se, createApp: () => $, createBlock: () => ce, createCommentVNode: () => le, createElementBlock: () => ue, createElementVNode: () => y, createHydrationRenderer: () => de, createPropsRestProxy: () => fe, createRenderer: () => pe, createSSRApp: () => ui, createSlots: () => me, createStaticVNode: () => he, createTextVNode: () => ge, createVNode: () => b, customRef: () => _e, defineAsyncComponent: () => ve, defineComponent: () => ye, defineCustomElement: () => Dr, defineEmits: () => be, defineExpose: () => xe, defineModel: () => Se, defineOptions: () => Ce, defineProps: () => we, defineSSRCustomElement: () => Or, defineSlots: () => Te, devtools: () => Ee, effect: () => De, effectScope: () => Oe, getCurrentInstance: () => S, getCurrentScope: () => ke, getCurrentWatcher: () => Ae, getTransitionRawChildren: () => je, guardReactiveProps: () => Me, h: () => Ne, handleError: () => Pe, hasInjectionContext: () => Fe, hydrate: () => li, hydrateOnIdle: () => Le, hydrateOnInteraction: () => Re, hydrateOnMediaQuery: () => ze, hydrateOnVisible: () => Be, initCustomFormatter: () => He, initDirectivesForSSR: () => mi, inject: () => Ue, isMemoSame: () => Ke, isProxy: () => Ze, isReactive: () => Qe, isReadonly: () => $e, isRef: () => et, isRuntimeOnly: () => tt, isShallow: () => nt, isVNode: () => at, markRaw: () => st, mergeDefaults: () => ct, mergeModels: () => lt, mergeProps: () => ut, nextTick: () => dt, normalizeClass: () => ft, normalizeProps: () => pt, normalizeStyle: () => mt, onActivated: () => ht, onBeforeMount: () => gt, onBeforeUnmount: () => _t, onBeforeUpdate: () => vt, onDeactivated: () => yt, onErrorCaptured: () => bt, onMounted: () => xt, onRenderTracked: () => St, onRenderTriggered: () => Ct, onScopeDispose: () => wt, onServerPrefetch: () => Tt, onUnmounted: () => Et, onUpdated: () => Dt, onWatcherCleanup: () => Ot, openBlock: () => kt, popScopeId: () => At, provide: () => jt, proxyRefs: () => Mt, pushScopeId: () => Nt, queuePostFlushCb: () => Pt, reactive: () => Ft, readonly: () => It, ref: () => Lt, registerRuntimeCompiler: () => Rt, render: () => ci, renderList: () => zt, renderSlot: () => Bt, resolveComponent: () => Vt, resolveDirective: () => Ht, resolveDynamicComponent: () => Ut, resolveFilter: () => Wt, resolveTransitionHooks: () => Gt, setBlockTracking: () => Kt, setDevtoolsHook: () => qt, setTransitionHooks: () => k, shallowReactive: () => Jt, shallowReadonly: () => Yt, shallowRef: () => Xt, ssrContextKey: () => Zt, ssrUtils: () => Qt, stop: () => $t, toDisplayString: () => en, toHandlerKey: () => tn, toHandlers: () => nn, toRaw: () => rn, toRef: () => an, toRefs: () => on, toValue: () => sn, transformVNodeArgs: () => cn, triggerRef: () => ln, unref: () => un, useAttrs: () => dn, useCssModule: () => Nr, useCssVars: () => nr, useHost: () => jr, useId: () => fn, useModel: () => pn, useSSRContext: () => mn, useShadowRoot: () => Mr, useSlots: () => hn, useTemplateRef: () => gn, useTransitionState: () => _n, vModelCheckbox: () => J, vModelDynamic: () => Xr, vModelRadio: () => Y, vModelSelect: () => qr, vModelText: () => q, vShow: () => $n, version: () => vn, warn: () => yn, watch: () => bn, watchEffect: () => xn, watchPostEffect: () => Sn, watchSyncEffect: () => Cn, withAsyncContext: () => wn, withCtx: () => Tn, withDefaults: () => En, withDirectives: () => Dn, withKeys: () => ri, withMemo: () => On, withModifiers: () => ti, withScopeId: () => kn });
const gi = () => {
};
export {
  zn as Transition,
  $ as createApp,
  J as vModelCheckbox,
  Y as vModelRadio,
  $n as vShow,
  hi as vue_runtime_esm_bundler_exports,
  ri as withKeys,
  ti as withModifiers
};
