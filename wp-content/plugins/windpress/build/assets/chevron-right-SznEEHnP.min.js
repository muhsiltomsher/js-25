import { Fragment as e, createBaseVNode as t, createBlock as n, createCommentVNode as r, createElementBlock as i, createVNode as a, defineComponent as o, guardReactiveProps as s, h as c, markRaw as l, mergeProps as u, nextTick as d, normalizeClass as f, normalizeProps as p, normalizeStyle as m, openBlock as h, popScopeId as ee, pushScopeId as te, ref as g, renderSlot as _, resolveComponent as v, toDisplayString as ne, useAttrs as re, watch as ie, withCtx as y, withScopeId as ae } from "./runtime-core.esm-bundler-CFIgNHFT.min.js";
import { createApp as oe, withKeys as se } from "./vue.runtime.esm-bundler-WcNVUy75.min.js";
import { arrow as ce, autoPlacement as le, computePosition as ue, flip as de, offset as fe, rectToClientRect as pe, shift as me, size as he } from "./floating-ui.core-PLF1GSJg.min.js";
const b = {};
function ge(e2) {
  return e2.getIsPending !== void 0;
}
function _e(e2) {
  if (ge(e2)) return e2;
  let t2 = true, n2 = e2.then((e3) => (t2 = false, e3), (e3) => {
    throw t2 = false, e3;
  });
  return n2.getIsPending = function() {
    return t2;
  }, n2;
}
function ve(e2) {
  let t2 = {}, n2 = e2.attributes;
  if (!n2) return t2;
  for (let e3 = n2.length - 1; e3 >= 0; e3--) t2[n2[e3].name] = n2[e3].value;
  return t2;
}
function ye(e2) {
  return Object.keys(e2).reduce((t2, n2) => (e2[n2] !== false && e2[n2] !== null && e2[n2] !== void 0 && (t2[n2] = e2[n2]), t2), {});
}
function be(e2, t2) {
  let { class: n2, style: r2, ...i2 } = ve(e2), { class: a2, style: o2, ...s2 } = ye(t2);
  return { class: [n2, a2], style: [r2, o2], ...i2, ...s2 };
}
const xe = o({ inheritAttrs: false, __name: `InlineSvg`, props: { src: {}, title: { default: void 0 }, transformSource: { type: Function, default: (e2) => e2 }, keepDuringLoading: { type: Boolean, default: true }, uniqueIds: { type: [Boolean, String], default: false }, uniqueIdsBase: { default: `` } }, emits: [`loaded`, `unloaded`, `error`], setup(e2, { expose: t2, emit: r2 }) {
  let i2 = e2, a2 = r2, o2 = re(), s2 = g(), l2 = g(), u2 = g(), f2 = Math.random().toString(36).substring(2);
  t2({ svgElSource: s2, request: u2 }), ie(() => i2.src, (e3) => {
    m2(e3);
  }), m2(i2.src);
  function p2(e3) {
    if (e3 = e3.cloneNode(true), i2.uniqueIds) {
      let t3 = typeof i2.uniqueIds == `string` ? i2.uniqueIds : f2;
      e3 = v2(e3, t3, i2.uniqueIdsBase);
    }
    return e3 = i2.transformSource(e3), i2.title && _2(e3, i2.title), e3.innerHTML;
  }
  function m2(e3) {
    b[e3] || (b[e3] = ee2(e3)), s2.value && b[e3].getIsPending() && !i2.keepDuringLoading && (s2.value = null, a2(`unloaded`)), b[e3].then((e4) => {
      s2.value = e4, d(() => {
        a2(`loaded`, l2.value);
      });
    }).catch((t3) => {
      s2.value && (s2.value = void 0, a2(`unloaded`)), delete b[e3], a2(`error`, t3);
    });
  }
  function ee2(e3) {
    return _e(new Promise((t3, n2) => {
      let r3 = new XMLHttpRequest();
      r3.open(`GET`, e3, true), u2.value = r3, r3.onload = () => {
        if (r3.status >= 200 && r3.status < 400) try {
          let e4 = new DOMParser().parseFromString(r3.responseText, `text/xml`).getElementsByTagName(`svg`)[0];
          e4 ? t3(e4) : n2(Error(`Loaded file is not valid SVG"`));
        } catch (e4) {
          n2(e4);
        }
        else n2(Error(`Error loading SVG`));
      }, r3.onerror = n2, r3.send();
    }));
  }
  let te2 = () => s2.value ? c(`svg`, { ...be(s2.value, o2), innerHTML: p2(s2.value), ref: l2 }) : null;
  function _2(e3, t3) {
    let n2 = e3.getElementsByTagName(`title`);
    if (n2.length) n2[0].textContent = t3;
    else {
      let n3 = document.createElementNS(`http://www.w3.org/2000/svg`, `title`);
      n3.textContent = t3, e3.insertBefore(n3, e3.firstChild);
    }
  }
  function v2(e3, t3, n2 = ``) {
    let r3 = [`id`, `href`, `xlink:href`, `xlink:role`, `xlink:arcrole`], i3 = [`href`, `xlink:href`], a3 = (e4, t4) => i3.includes(e4) && (t4 ? !t4.includes(`#`) : false);
    return [...e3.children].forEach((e4) => {
      var i4;
      if ((i4 = e4.attributes) != null && i4.length) {
        let i5 = Object.values(e4.attributes).map((e5) => {
          let r4 = /url\((.*?)\)/.exec(e5.value);
          return r4 != null && r4[1] && (e5.value = e5.value.replace(r4[0], `url(${n2}${r4[1]}_${t3})`)), e5;
        });
        r3.forEach((e5) => {
          let n3 = i5.find((t4) => t4.name === e5);
          n3 && !a3(e5, n3.value) && (n3.value = `${n3.value}_${t3}`);
        });
      }
      return e4.children.length ? v2(e4, t3, n2) : e4;
    }), e3;
  }
  return (e3, t3) => (h(), n(te2));
} });
function x(e2) {
  var _a;
  var t2;
  return ((_a = t2 = e2.ownerDocument) == null ? void 0 : _a.defaultView) || window;
}
function S(e2) {
  return x(e2).getComputedStyle(e2);
}
const Se = Math.min, C = Math.max, w = Math.round;
function Ce(e2) {
  let t2 = S(e2), n2 = parseFloat(t2.width), r2 = parseFloat(t2.height), i2 = e2.offsetWidth, a2 = e2.offsetHeight, o2 = w(n2) !== i2 || w(r2) !== a2;
  return o2 && (n2 = i2, r2 = a2), { width: n2, height: r2, fallback: o2 };
}
function T(e2) {
  return Te(e2) ? (e2.nodeName || ``).toLowerCase() : ``;
}
let E;
function we() {
  if (E) return E;
  let e2 = navigator.userAgentData;
  return e2 && Array.isArray(e2.brands) ? (E = e2.brands.map((e3) => e3.brand + `/` + e3.version).join(` `), E) : navigator.userAgent;
}
function D(e2) {
  return e2 instanceof x(e2).HTMLElement;
}
function O(e2) {
  return e2 instanceof x(e2).Element;
}
function Te(e2) {
  return e2 instanceof x(e2).Node;
}
function Ee(e2) {
  return typeof ShadowRoot > `u` ? false : e2 instanceof x(e2).ShadowRoot || e2 instanceof ShadowRoot;
}
function k(e2) {
  let { overflow: t2, overflowX: n2, overflowY: r2, display: i2 } = S(e2);
  return /auto|scroll|overlay|hidden|clip/.test(t2 + r2 + n2) && ![`inline`, `contents`].includes(i2);
}
function De(e2) {
  return [`table`, `td`, `th`].includes(T(e2));
}
function Oe(e2) {
  let t2 = /firefox/i.test(we()), n2 = S(e2), r2 = n2.backdropFilter || n2.WebkitBackdropFilter;
  return n2.transform !== `none` || n2.perspective !== `none` || !!r2 && r2 !== `none` || t2 && n2.willChange === `filter` || t2 && !!n2.filter && n2.filter !== `none` || [`transform`, `perspective`].some((e3) => n2.willChange.includes(e3)) || [`paint`, `layout`, `strict`, `content`].some((e3) => {
    let t3 = n2.contain;
    return t3 != null && t3.includes(e3);
  });
}
function ke() {
  return !/^((?!chrome|android).)*safari/i.test(we());
}
function Ae(e2) {
  return [`html`, `body`, `#document`].includes(T(e2));
}
function je(e2) {
  return O(e2) ? e2 : e2.contextElement;
}
const Me = { x: 1, y: 1 };
function A(e2) {
  let t2 = je(e2);
  if (!D(t2)) return Me;
  let n2 = t2.getBoundingClientRect(), { width: r2, height: i2, fallback: a2 } = Ce(t2), o2 = (a2 ? w(n2.width) : n2.width) / r2, s2 = (a2 ? w(n2.height) : n2.height) / i2;
  return o2 && Number.isFinite(o2) || (o2 = 1), s2 && Number.isFinite(s2) || (s2 = 1), { x: o2, y: s2 };
}
function j(e2, t2, n2, r2) {
  var _a, _b;
  var i2, a2;
  t2 === void 0 && (t2 = false), n2 === void 0 && (n2 = false);
  let o2 = e2.getBoundingClientRect(), s2 = je(e2), c2 = Me;
  t2 && (r2 ? O(r2) && (c2 = A(r2)) : c2 = A(e2));
  let l2 = s2 ? x(s2) : window, u2 = !ke() && n2, d2 = (o2.left + (u2 && ((_a = i2 = l2.visualViewport) == null ? void 0 : _a.offsetLeft) || 0)) / c2.x, f2 = (o2.top + (u2 && ((_b = a2 = l2.visualViewport) == null ? void 0 : _b.offsetTop) || 0)) / c2.y, p2 = o2.width / c2.x, m2 = o2.height / c2.y;
  if (s2) {
    let e3 = x(s2), t3 = r2 && O(r2) ? x(r2) : r2, n3 = e3.frameElement;
    for (; n3 && r2 && t3 !== e3; ) {
      let e4 = A(n3), t4 = n3.getBoundingClientRect(), r3 = getComputedStyle(n3);
      t4.x += (n3.clientLeft + parseFloat(r3.paddingLeft)) * e4.x, t4.y += (n3.clientTop + parseFloat(r3.paddingTop)) * e4.y, d2 *= e4.x, f2 *= e4.y, p2 *= e4.x, m2 *= e4.y, d2 += t4.x, f2 += t4.y, n3 = x(n3).frameElement;
    }
  }
  return { width: p2, height: m2, top: f2, right: d2 + p2, bottom: f2 + m2, left: d2, x: d2, y: f2 };
}
function M(e2) {
  return ((Te(e2) ? e2.ownerDocument : e2.document) || window.document).documentElement;
}
function N(e2) {
  return O(e2) ? { scrollLeft: e2.scrollLeft, scrollTop: e2.scrollTop } : { scrollLeft: e2.pageXOffset, scrollTop: e2.pageYOffset };
}
function Ne(e2) {
  return j(M(e2)).left + N(e2).scrollLeft;
}
function P(e2) {
  if (T(e2) === `html`) return e2;
  let t2 = e2.assignedSlot || e2.parentNode || Ee(e2) && e2.host || M(e2);
  return Ee(t2) ? t2.host : t2;
}
function Pe(e2) {
  let t2 = P(e2);
  return Ae(t2) ? t2.ownerDocument.body : D(t2) && k(t2) ? t2 : Pe(t2);
}
function F(e2, t2) {
  var _a;
  var n2;
  t2 === void 0 && (t2 = []);
  let r2 = Pe(e2), i2 = r2 === ((_a = n2 = e2.ownerDocument) == null ? void 0 : _a.body), a2 = x(r2);
  return i2 ? t2.concat(a2, a2.visualViewport || [], k(r2) ? r2 : []) : t2.concat(r2, F(r2));
}
function Fe(e2, t2, n2) {
  return t2 === `viewport` ? pe(function(e3, t3) {
    let n3 = x(e3), r2 = M(e3), i2 = n3.visualViewport, a2 = r2.clientWidth, o2 = r2.clientHeight, s2 = 0, c2 = 0;
    if (i2) {
      a2 = i2.width, o2 = i2.height;
      let e4 = ke();
      (e4 || !e4 && t3 === `fixed`) && (s2 = i2.offsetLeft, c2 = i2.offsetTop);
    }
    return { width: a2, height: o2, x: s2, y: c2 };
  }(e2, n2)) : O(t2) ? pe(function(e3, t3) {
    let n3 = j(e3, true, t3 === `fixed`), r2 = n3.top + e3.clientTop, i2 = n3.left + e3.clientLeft, a2 = D(e3) ? A(e3) : { x: 1, y: 1 };
    return { width: e3.clientWidth * a2.x, height: e3.clientHeight * a2.y, x: i2 * a2.x, y: r2 * a2.y };
  }(t2, n2)) : pe(function(e3) {
    let t3 = M(e3), n3 = N(e3), r2 = e3.ownerDocument.body, i2 = C(t3.scrollWidth, t3.clientWidth, r2.scrollWidth, r2.clientWidth), a2 = C(t3.scrollHeight, t3.clientHeight, r2.scrollHeight, r2.clientHeight), o2 = -n3.scrollLeft + Ne(e3), s2 = -n3.scrollTop;
    return S(r2).direction === `rtl` && (o2 += C(t3.clientWidth, r2.clientWidth) - i2), { width: i2, height: a2, x: o2, y: s2 };
  }(M(e2)));
}
function Ie(e2) {
  return D(e2) && S(e2).position !== `fixed` ? e2.offsetParent : null;
}
function Le(e2) {
  let t2 = x(e2), n2 = Ie(e2);
  for (; n2 && De(n2) && S(n2).position === `static`; ) n2 = Ie(n2);
  return n2 && (T(n2) === `html` || T(n2) === `body` && S(n2).position === `static` && !Oe(n2)) ? t2 : n2 || function(e3) {
    let t3 = P(e3);
    for (; D(t3) && !Ae(t3); ) {
      if (Oe(t3)) return t3;
      t3 = P(t3);
    }
    return null;
  }(e2) || t2;
}
function Re(e2, t2, n2) {
  let r2 = D(t2), i2 = M(t2), a2 = j(e2, true, n2 === `fixed`, t2), o2 = { scrollLeft: 0, scrollTop: 0 }, s2 = { x: 0, y: 0 };
  if (r2 || !r2 && n2 !== `fixed`) if ((T(t2) !== `body` || k(i2)) && (o2 = N(t2)), D(t2)) {
    let e3 = j(t2, true);
    s2.x = e3.x + t2.clientLeft, s2.y = e3.y + t2.clientTop;
  } else i2 && (s2.x = Ne(i2));
  return { x: a2.left + o2.scrollLeft - s2.x, y: a2.top + o2.scrollTop - s2.y, width: a2.width, height: a2.height };
}
const ze = { getClippingRect: function(e2) {
  let { element: t2, boundary: n2, rootBoundary: r2, strategy: i2 } = e2, a2 = n2 === `clippingAncestors` ? function(e3, t3) {
    let n3 = t3.get(e3);
    if (n3) return n3;
    let r3 = F(e3).filter((e4) => O(e4) && T(e4) !== `body`), i3 = null, a3 = S(e3).position === `fixed`, o3 = a3 ? P(e3) : e3;
    for (; O(o3) && !Ae(o3); ) {
      let e4 = S(o3), t4 = Oe(o3);
      (a3 ? t4 || i3 : t4 || e4.position !== `static` || !i3 || ![`absolute`, `fixed`].includes(i3.position)) ? i3 = e4 : r3 = r3.filter((e5) => e5 !== o3), o3 = P(o3);
    }
    return t3.set(e3, r3), r3;
  }(t2, this._c) : [].concat(n2), o2 = [...a2, r2], s2 = o2[0], c2 = o2.reduce((e3, n3) => {
    let r3 = Fe(t2, n3, i2);
    return e3.top = C(r3.top, e3.top), e3.right = Se(r3.right, e3.right), e3.bottom = Se(r3.bottom, e3.bottom), e3.left = C(r3.left, e3.left), e3;
  }, Fe(t2, s2, i2));
  return { width: c2.right - c2.left, height: c2.bottom - c2.top, x: c2.left, y: c2.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e2) {
  let { rect: t2, offsetParent: n2, strategy: r2 } = e2, i2 = D(n2), a2 = M(n2);
  if (n2 === a2) return t2;
  let o2 = { scrollLeft: 0, scrollTop: 0 }, s2 = { x: 1, y: 1 }, c2 = { x: 0, y: 0 };
  if ((i2 || !i2 && r2 !== `fixed`) && ((T(n2) !== `body` || k(a2)) && (o2 = N(n2)), D(n2))) {
    let e3 = j(n2);
    s2 = A(n2), c2.x = e3.x + n2.clientLeft, c2.y = e3.y + n2.clientTop;
  }
  return { width: t2.width * s2.x, height: t2.height * s2.y, x: t2.x * s2.x - o2.scrollLeft * s2.x + c2.x, y: t2.y * s2.y - o2.scrollTop * s2.y + c2.y };
}, isElement: O, getDimensions: function(e2) {
  return D(e2) ? Ce(e2) : e2.getBoundingClientRect();
}, getOffsetParent: Le, getDocumentElement: M, getScale: A, async getElementRects(e2) {
  let { reference: t2, floating: n2, strategy: r2 } = e2, i2 = this.getOffsetParent || Le, a2 = this.getDimensions;
  return { reference: Re(t2, await i2(n2), r2), floating: { x: 0, y: 0, ...await a2(n2) } };
}, getClientRects: (e2) => Array.from(e2.getClientRects()), isRTL: (e2) => S(e2).direction === `rtl` }, Be = (e2, t2, n2) => {
  let r2 = /* @__PURE__ */ new Map(), i2 = { platform: ze, ...n2 }, a2 = { ...i2.platform, _c: r2 };
  return ue(e2, t2, { ...i2, platform: a2 });
};
function Ve(e2, t2) {
  for (let n2 in t2) Object.prototype.hasOwnProperty.call(t2, n2) && (typeof t2[n2] == `object` && e2[n2] ? Ve(e2[n2], t2[n2]) : e2[n2] = t2[n2]);
}
const I = { disabled: false, distance: 5, skidding: 0, container: `body`, boundary: void 0, instantMove: false, disposeTimeout: 150, popperTriggers: [], strategy: `absolute`, preventOverflow: true, flip: true, shift: true, overflowPadding: 0, arrowPadding: 0, arrowOverflow: true, autoHideOnMousedown: false, themes: { tooltip: { placement: `top`, triggers: [`hover`, `focus`, `touch`], hideTriggers: (e2) => [...e2, `click`], delay: { show: 200, hide: 0 }, handleResize: false, html: false, loadingContent: `...` }, dropdown: { placement: `bottom`, triggers: [`click`], delay: 0, handleResize: true, autoHide: true }, menu: { $extend: `dropdown`, triggers: [`hover`, `focus`], popperTriggers: [`hover`], delay: { show: 0, hide: 400 } } } };
function L(e2, t2) {
  let n2 = I.themes[e2] || {}, r2;
  do
    r2 = n2[t2], typeof r2 > `u` ? n2.$extend ? n2 = I.themes[n2.$extend] || {} : (n2 = null, r2 = I[t2]) : n2 = null;
  while (n2);
  return r2;
}
function He(e2) {
  let t2 = [e2], n2 = I.themes[e2] || {};
  do
    n2.$extend && !n2.$resetCss ? (t2.push(n2.$extend), n2 = I.themes[n2.$extend] || {}) : n2 = null;
  while (n2);
  return t2.map((e3) => `v-popper--theme-${e3}`);
}
function Ue(e2) {
  let t2 = [e2], n2 = I.themes[e2] || {};
  do
    n2.$extend ? (t2.push(n2.$extend), n2 = I.themes[n2.$extend] || {}) : n2 = null;
  while (n2);
  return t2;
}
let R = false;
if (typeof window < `u`) {
  R = false;
  try {
    let e2 = Object.defineProperty({}, `passive`, { get() {
      R = true;
    } });
    window.addEventListener(`test`, null, e2);
  } catch {
  }
}
let We = false;
typeof window < `u` && typeof navigator < `u` && (We = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);
const Ge = [`auto`, `top`, `bottom`, `left`, `right`].reduce((e2, t2) => e2.concat([t2, `${t2}-start`, `${t2}-end`]), []), Ke = { hover: `mouseenter`, focus: `focus`, click: `click`, touch: `touchstart`, pointer: `pointerdown` }, qe = { hover: `mouseleave`, focus: `blur`, click: `click`, touch: `touchend`, pointer: `pointerup` };
function Je(e2, t2) {
  let n2 = e2.indexOf(t2);
  n2 !== -1 && e2.splice(n2, 1);
}
function z() {
  return new Promise((e2) => requestAnimationFrame(() => {
    requestAnimationFrame(e2);
  }));
}
const B = [];
let V = null;
const Ye = {};
function Xe(e2) {
  let t2 = Ye[e2];
  return t2 || (t2 = Ye[e2] = []), t2;
}
let Ze = function() {
};
typeof window < `u` && (Ze = window.Element);
function H(e2) {
  return function(t2) {
    return L(t2.theme, e2);
  };
}
const Qe = `__floating-vue__popper`, $e = () => o({ name: `VPopper`, provide() {
  return { [Qe]: { parentPopper: this } };
}, inject: { [Qe]: { default: null } }, props: { theme: { type: String, required: true }, targetNodes: { type: Function, required: true }, referenceNode: { type: Function, default: null }, popperNode: { type: Function, required: true }, shown: { type: Boolean, default: false }, showGroup: { type: String, default: null }, ariaId: { default: null }, disabled: { type: Boolean, default: H(`disabled`) }, positioningDisabled: { type: Boolean, default: H(`positioningDisabled`) }, placement: { type: String, default: H(`placement`), validator: (e2) => Ge.includes(e2) }, delay: { type: [String, Number, Object], default: H(`delay`) }, distance: { type: [Number, String], default: H(`distance`) }, skidding: { type: [Number, String], default: H(`skidding`) }, triggers: { type: Array, default: H(`triggers`) }, showTriggers: { type: [Array, Function], default: H(`showTriggers`) }, hideTriggers: { type: [Array, Function], default: H(`hideTriggers`) }, popperTriggers: { type: Array, default: H(`popperTriggers`) }, popperShowTriggers: { type: [Array, Function], default: H(`popperShowTriggers`) }, popperHideTriggers: { type: [Array, Function], default: H(`popperHideTriggers`) }, container: { type: [String, Object, Ze, Boolean], default: H(`container`) }, boundary: { type: [String, Ze], default: H(`boundary`) }, strategy: { type: String, validator: (e2) => [`absolute`, `fixed`].includes(e2), default: H(`strategy`) }, autoHide: { type: [Boolean, Function], default: H(`autoHide`) }, handleResize: { type: Boolean, default: H(`handleResize`) }, instantMove: { type: Boolean, default: H(`instantMove`) }, eagerMount: { type: Boolean, default: H(`eagerMount`) }, popperClass: { type: [String, Array, Object], default: H(`popperClass`) }, computeTransformOrigin: { type: Boolean, default: H(`computeTransformOrigin`) }, autoMinSize: { type: Boolean, default: H(`autoMinSize`) }, autoSize: { type: [Boolean, String], default: H(`autoSize`) }, autoMaxSize: { type: Boolean, default: H(`autoMaxSize`) }, autoBoundaryMaxSize: { type: Boolean, default: H(`autoBoundaryMaxSize`) }, preventOverflow: { type: Boolean, default: H(`preventOverflow`) }, overflowPadding: { type: [Number, String], default: H(`overflowPadding`) }, arrowPadding: { type: [Number, String], default: H(`arrowPadding`) }, arrowOverflow: { type: Boolean, default: H(`arrowOverflow`) }, flip: { type: Boolean, default: H(`flip`) }, shift: { type: Boolean, default: H(`shift`) }, shiftCrossAxis: { type: Boolean, default: H(`shiftCrossAxis`) }, noAutoFocus: { type: Boolean, default: H(`noAutoFocus`) }, disposeTimeout: { type: Number, default: H(`disposeTimeout`) } }, emits: { show: () => true, hide: () => true, "update:shown": (e2) => true, "apply-show": () => true, "apply-hide": () => true, "close-group": () => true, "close-directive": () => true, "auto-hide": () => true, resize: () => true }, data() {
  return { isShown: false, isMounted: false, skipTransition: false, classes: { showFrom: false, showTo: false, hideFrom: false, hideTo: true }, result: { x: 0, y: 0, placement: ``, strategy: this.strategy, arrow: { x: 0, y: 0, centerOffset: 0 }, transformOrigin: null }, randomId: `popper_${[Math.random(), Date.now()].map((e2) => e2.toString(36).substring(2, 10)).join(`_`)}`, shownChildren: /* @__PURE__ */ new Set(), lastAutoHide: true, pendingHide: false, containsGlobalTarget: false, isDisposed: true, mouseDownContains: false };
}, computed: { popperId() {
  return this.ariaId == null ? this.randomId : this.ariaId;
}, shouldMountContent() {
  return this.eagerMount || this.isMounted;
}, slotData() {
  return { popperId: this.popperId, isShown: this.isShown, shouldMountContent: this.shouldMountContent, skipTransition: this.skipTransition, autoHide: typeof this.autoHide == `function` ? this.lastAutoHide : this.autoHide, show: this.show, hide: this.hide, handleResize: this.handleResize, onResize: this.onResize, classes: { ...this.classes, popperClass: this.popperClass }, result: this.positioningDisabled ? null : this.result, attrs: this.$attrs };
}, parentPopper() {
  var _a;
  var e2;
  return (_a = e2 = this[Qe]) == null ? void 0 : _a.parentPopper;
}, hasPopperShowTriggerHover() {
  var _a, _b;
  var e2, t2;
  return ((_a = e2 = this.popperTriggers) == null ? void 0 : _a.includes(`hover`)) || ((_b = t2 = this.popperShowTriggers) == null ? void 0 : _b.includes(`hover`));
} }, watch: { shown: `$_autoShowHide`, disabled(e2) {
  e2 ? this.dispose() : this.init();
}, async container() {
  this.isShown && (this.$_ensureTeleport(), await this.$_computePosition());
}, triggers: { handler: `$_refreshListeners`, deep: true }, positioningDisabled: `$_refreshListeners`, ...[`placement`, `distance`, `skidding`, `boundary`, `strategy`, `overflowPadding`, `arrowPadding`, `preventOverflow`, `shift`, `shiftCrossAxis`, `flip`].reduce((e2, t2) => (e2[t2] = `$_computePosition`, e2), {}) }, created() {
  this.autoMinSize && console.warn('[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.'), this.autoMaxSize && console.warn("[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.");
}, mounted() {
  this.init(), this.$_detachPopperNode();
}, activated() {
  this.$_autoShowHide();
}, deactivated() {
  this.hide();
}, beforeUnmount() {
  this.dispose();
}, methods: { show({ event: e2 = null, skipDelay: t2 = false, force: n2 = false } = {}) {
  var _a;
  var r2, i2;
  (r2 = this.parentPopper) != null && r2.lockedChild && this.parentPopper.lockedChild !== this || (this.pendingHide = false, (n2 || !this.disabled) && (((_a = i2 = this.parentPopper) == null ? void 0 : _a.lockedChild) === this && (this.parentPopper.lockedChild = null), this.$_scheduleShow(e2, t2), this.$emit(`show`), this.$_showFrameLocked = true, requestAnimationFrame(() => {
    this.$_showFrameLocked = false;
  })), this.$emit(`update:shown`, true));
}, hide({ event: e2 = null, skipDelay: t2 = false } = {}) {
  var _a;
  var n2;
  if (!this.$_hideInProgress) {
    if (this.shownChildren.size > 0) {
      this.pendingHide = true;
      return;
    }
    if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
      this.parentPopper && (this.parentPopper.lockedChild = this, clearTimeout(this.parentPopper.lockedChildTimer), this.parentPopper.lockedChildTimer = setTimeout(() => {
        this.parentPopper.lockedChild === this && (this.parentPopper.lockedChild.hide({ skipDelay: t2 }), this.parentPopper.lockedChild = null);
      }, 1e3));
      return;
    }
    ((_a = n2 = this.parentPopper) == null ? void 0 : _a.lockedChild) === this && (this.parentPopper.lockedChild = null), this.pendingHide = false, this.$_scheduleHide(e2, t2), this.$emit(`hide`), this.$emit(`update:shown`, false);
  }
}, init() {
  var _a;
  var e2;
  this.isDisposed && (this.isDisposed = false, this.isMounted = false, this.$_events = [], this.$_preventShow = false, this.$_referenceNode = ((_a = e2 = this.referenceNode) == null ? void 0 : _a.call(this)) ?? this.$el, this.$_targetNodes = this.targetNodes().filter((e3) => e3.nodeType === e3.ELEMENT_NODE), this.$_popperNode = this.popperNode(), this.$_innerNode = this.$_popperNode.querySelector(`.v-popper__inner`), this.$_arrowNode = this.$_popperNode.querySelector(`.v-popper__arrow-container`), this.$_swapTargetAttrs(`title`, `data-original-title`), this.$_detachPopperNode(), this.triggers.length && this.$_addEventListeners(), this.shown && this.show());
}, dispose() {
  this.isDisposed || (this.isDisposed = true, this.$_removeEventListeners(), this.hide({ skipDelay: true }), this.$_detachPopperNode(), this.isMounted = false, this.isShown = false, this.$_updateParentShownChildren(false), this.$_swapTargetAttrs(`data-original-title`, `title`));
}, async onResize() {
  this.isShown && (await this.$_computePosition(), this.$emit(`resize`));
}, async $_computePosition() {
  if (this.isDisposed || this.positioningDisabled) return;
  let e2 = { strategy: this.strategy, middleware: [] };
  (this.distance || this.skidding) && e2.middleware.push(fe({ mainAxis: this.distance, crossAxis: this.skidding }));
  let t2 = this.placement.startsWith(`auto`);
  if (t2 ? e2.middleware.push(le({ alignment: this.placement.split(`-`)[1] ?? `` })) : e2.placement = this.placement, this.preventOverflow && (this.shift && e2.middleware.push(me({ padding: this.overflowPadding, boundary: this.boundary, crossAxis: this.shiftCrossAxis })), !t2 && this.flip && e2.middleware.push(de({ padding: this.overflowPadding, boundary: this.boundary }))), e2.middleware.push(ce({ element: this.$_arrowNode, padding: this.arrowPadding })), this.arrowOverflow && e2.middleware.push({ name: `arrowOverflow`, fn: ({ placement: e3, rects: t3, middlewareData: n3 }) => {
    let r2, { centerOffset: i2 } = n3.arrow;
    return r2 = e3.startsWith(`top`) || e3.startsWith(`bottom`) ? Math.abs(i2) > t3.reference.width / 2 : Math.abs(i2) > t3.reference.height / 2, { data: { overflow: r2 } };
  } }), this.autoMinSize || this.autoSize) {
    let t3 = this.autoSize ? this.autoSize : this.autoMinSize ? `min` : null;
    e2.middleware.push({ name: `autoSize`, fn: ({ rects: e3, placement: n3, middlewareData: r2 }) => {
      var i2;
      if ((i2 = r2.autoSize) != null && i2.skip) return {};
      let a2, o2;
      return n3.startsWith(`top`) || n3.startsWith(`bottom`) ? a2 = e3.reference.width : o2 = e3.reference.height, this.$_innerNode.style[t3 === `min` ? `minWidth` : t3 === `max` ? `maxWidth` : `width`] = a2 == null ? null : `${a2}px`, this.$_innerNode.style[t3 === `min` ? `minHeight` : t3 === `max` ? `maxHeight` : `height`] = o2 == null ? null : `${o2}px`, { data: { skip: true }, reset: { rects: true } };
    } });
  }
  (this.autoMaxSize || this.autoBoundaryMaxSize) && (this.$_innerNode.style.maxWidth = null, this.$_innerNode.style.maxHeight = null, e2.middleware.push(he({ boundary: this.boundary, padding: this.overflowPadding, apply: ({ availableWidth: e3, availableHeight: t3 }) => {
    this.$_innerNode.style.maxWidth = e3 == null ? null : `${e3}px`, this.$_innerNode.style.maxHeight = t3 == null ? null : `${t3}px`;
  } })));
  let n2 = await Be(this.$_referenceNode, this.$_popperNode, e2);
  Object.assign(this.result, { x: n2.x, y: n2.y, placement: n2.placement, strategy: n2.strategy, arrow: { ...n2.middlewareData.arrow, ...n2.middlewareData.arrowOverflow } });
}, $_scheduleShow(e2, t2 = false) {
  if (this.$_updateParentShownChildren(true), this.$_hideInProgress = false, clearTimeout(this.$_scheduleTimer), V && this.instantMove && V.instantMove && V !== this.parentPopper) {
    V.$_applyHide(true), this.$_applyShow(true);
    return;
  }
  t2 ? this.$_applyShow() : this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay(`show`));
}, $_scheduleHide(e2, t2 = false) {
  if (this.shownChildren.size > 0) {
    this.pendingHide = true;
    return;
  }
  this.$_updateParentShownChildren(false), this.$_hideInProgress = true, clearTimeout(this.$_scheduleTimer), this.isShown && (V = this), t2 ? this.$_applyHide() : this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay(`hide`));
}, $_computeDelay(e2) {
  let t2 = this.delay;
  return parseInt(t2 && t2[e2] || t2 || 0);
}, async $_applyShow(e2 = false) {
  clearTimeout(this.$_disposeTimer), clearTimeout(this.$_scheduleTimer), this.skipTransition = e2, !this.isShown && (this.$_ensureTeleport(), await z(), await this.$_computePosition(), await this.$_applyShowEffect(), this.positioningDisabled || this.$_registerEventListeners([...F(this.$_referenceNode), ...F(this.$_popperNode)], `scroll`, () => {
    this.$_computePosition();
  }));
}, async $_applyShowEffect() {
  if (this.$_hideInProgress) return;
  if (this.computeTransformOrigin) {
    let e3 = this.$_referenceNode.getBoundingClientRect(), t2 = this.$_popperNode.querySelector(`.v-popper__wrapper`), n2 = t2.parentNode.getBoundingClientRect(), r2 = e3.x + e3.width / 2 - (n2.left + t2.offsetLeft), i2 = e3.y + e3.height / 2 - (n2.top + t2.offsetTop);
    this.result.transformOrigin = `${r2}px ${i2}px`;
  }
  this.isShown = true, this.$_applyAttrsToTarget({ "aria-describedby": this.popperId, "data-popper-shown": `` });
  let e2 = this.showGroup;
  if (e2) {
    let t2;
    for (let n2 = 0; n2 < B.length; n2++) t2 = B[n2], t2.showGroup !== e2 && (t2.hide(), t2.$emit(`close-group`));
  }
  B.push(this), document.body.classList.add(`v-popper--some-open`);
  for (let e3 of Ue(this.theme)) Xe(e3).push(this), document.body.classList.add(`v-popper--some-open--${e3}`);
  this.$emit(`apply-show`), this.classes.showFrom = true, this.classes.showTo = false, this.classes.hideFrom = false, this.classes.hideTo = false, await z(), this.classes.showFrom = false, this.classes.showTo = true, this.noAutoFocus || this.$_popperNode.focus();
}, async $_applyHide(e2 = false) {
  if (this.shownChildren.size > 0) {
    this.pendingHide = true, this.$_hideInProgress = false;
    return;
  }
  if (clearTimeout(this.$_scheduleTimer), !this.isShown) return;
  this.skipTransition = e2, Je(B, this), B.length === 0 && document.body.classList.remove(`v-popper--some-open`);
  for (let e3 of Ue(this.theme)) {
    let t3 = Xe(e3);
    Je(t3, this), t3.length === 0 && document.body.classList.remove(`v-popper--some-open--${e3}`);
  }
  V === this && (V = null), this.isShown = false, this.$_applyAttrsToTarget({ "aria-describedby": void 0, "data-popper-shown": void 0 }), clearTimeout(this.$_disposeTimer);
  let t2 = this.disposeTimeout;
  t2 !== null && (this.$_disposeTimer = setTimeout(() => {
    this.$_popperNode && (this.$_detachPopperNode(), this.isMounted = false);
  }, t2)), this.$_removeEventListeners(`scroll`), this.$emit(`apply-hide`), this.classes.showFrom = false, this.classes.showTo = false, this.classes.hideFrom = true, this.classes.hideTo = false, await z(), this.classes.hideFrom = false, this.classes.hideTo = true;
}, $_autoShowHide() {
  this.shown ? this.show() : this.hide();
}, $_ensureTeleport() {
  if (this.isDisposed) return;
  let e2 = this.container;
  if (typeof e2 == `string` ? e2 = window.document.querySelector(e2) : e2 === false && (e2 = this.$_targetNodes[0].parentNode), !e2) throw Error(`No container for popover: ` + this.container);
  e2.appendChild(this.$_popperNode), this.isMounted = true;
}, $_addEventListeners() {
  let e2 = (e3) => {
    this.isShown && !this.$_hideInProgress || (e3.usedByTooltip = true, !this.$_preventShow && this.show({ event: e3 }));
  };
  this.$_registerTriggerListeners(this.$_targetNodes, Ke, this.triggers, this.showTriggers, e2), this.$_registerTriggerListeners([this.$_popperNode], Ke, this.popperTriggers, this.popperShowTriggers, e2);
  let t2 = (e3) => {
    e3.usedByTooltip || this.hide({ event: e3 });
  };
  this.$_registerTriggerListeners(this.$_targetNodes, qe, this.triggers, this.hideTriggers, t2), this.$_registerTriggerListeners([this.$_popperNode], qe, this.popperTriggers, this.popperHideTriggers, t2);
}, $_registerEventListeners(e2, t2, n2) {
  this.$_events.push({ targetNodes: e2, eventType: t2, handler: n2 }), e2.forEach((e3) => e3.addEventListener(t2, n2, R ? { passive: true } : void 0));
}, $_registerTriggerListeners(e2, t2, n2, r2, i2) {
  let a2 = n2;
  r2 != null && (a2 = typeof r2 == `function` ? r2(a2) : r2), a2.forEach((n3) => {
    let r3 = t2[n3];
    r3 && this.$_registerEventListeners(e2, r3, i2);
  });
}, $_removeEventListeners(e2) {
  let t2 = [];
  this.$_events.forEach((n2) => {
    let { targetNodes: r2, eventType: i2, handler: a2 } = n2;
    !e2 || e2 === i2 ? r2.forEach((e3) => e3.removeEventListener(i2, a2)) : t2.push(n2);
  }), this.$_events = t2;
}, $_refreshListeners() {
  this.isDisposed || (this.$_removeEventListeners(), this.$_addEventListeners());
}, $_handleGlobalClose(e2, t2 = false) {
  this.$_showFrameLocked || (this.hide({ event: e2 }), e2.closePopover ? this.$emit(`close-directive`) : this.$emit(`auto-hide`), t2 && (this.$_preventShow = true, setTimeout(() => {
    this.$_preventShow = false;
  }, 300)));
}, $_detachPopperNode() {
  this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);
}, $_swapTargetAttrs(e2, t2) {
  for (let n2 of this.$_targetNodes) {
    let r2 = n2.getAttribute(e2);
    r2 && (n2.removeAttribute(e2), n2.setAttribute(t2, r2));
  }
}, $_applyAttrsToTarget(e2) {
  for (let t2 of this.$_targetNodes) for (let n2 in e2) {
    let r2 = e2[n2];
    r2 == null ? t2.removeAttribute(n2) : t2.setAttribute(n2, r2);
  }
}, $_updateParentShownChildren(e2) {
  let t2 = this.parentPopper;
  for (; t2; ) e2 ? t2.shownChildren.add(this.randomId) : (t2.shownChildren.delete(this.randomId), t2.pendingHide && t2.hide()), t2 = t2.parentPopper;
}, $_isAimingPopper() {
  let e2 = this.$_referenceNode.getBoundingClientRect();
  if (G >= e2.left && G <= e2.right && K >= e2.top && K <= e2.bottom) {
    let e3 = this.$_popperNode.getBoundingClientRect(), t2 = G - U, n2 = K - W, r2 = e3.left + e3.width / 2 - U + (e3.top + e3.height / 2) - W + e3.width + e3.height, i2 = U + t2 * r2, a2 = W + n2 * r2;
    return q(U, W, i2, a2, e3.left, e3.top, e3.left, e3.bottom) || q(U, W, i2, a2, e3.left, e3.top, e3.right, e3.top) || q(U, W, i2, a2, e3.right, e3.top, e3.right, e3.bottom) || q(U, W, i2, a2, e3.left, e3.bottom, e3.right, e3.bottom);
  }
  return false;
} }, render() {
  return this.$slots.default(this.slotData);
} });
if (typeof document < `u` && typeof window < `u`) {
  if (We) {
    let e2 = R ? { passive: true, capture: true } : true;
    document.addEventListener(`touchstart`, (e3) => et(e3, true), e2), document.addEventListener(`touchend`, (e3) => tt(e3, true), e2);
  } else window.addEventListener(`mousedown`, (e2) => et(e2, false), true), window.addEventListener(`click`, (e2) => tt(e2, false), true);
  window.addEventListener(`resize`, at);
}
function et(e2, t2) {
  if (I.autoHideOnMousedown) nt(e2, t2);
  else for (let t3 = 0; t3 < B.length; t3++) {
    let n2 = B[t3];
    try {
      n2.mouseDownContains = n2.popperNode().contains(e2.target);
    } catch {
    }
  }
}
function tt(e2, t2) {
  I.autoHideOnMousedown || nt(e2, t2);
}
function nt(e2, t2) {
  let n2 = {};
  for (let r2 = B.length - 1; r2 >= 0; r2--) {
    let i2 = B[r2];
    try {
      let r3 = i2.containsGlobalTarget = i2.mouseDownContains || i2.popperNode().contains(e2.target);
      i2.pendingHide = false, requestAnimationFrame(() => {
        if (i2.pendingHide = false, !n2[i2.randomId] && rt(i2, r3, e2)) {
          if (i2.$_handleGlobalClose(e2, t2), !e2.closeAllPopover && e2.closePopover && r3) {
            let e3 = i2.parentPopper;
            for (; e3; ) n2[e3.randomId] = true, e3 = e3.parentPopper;
            return;
          }
          let a2 = i2.parentPopper;
          for (; a2 && rt(a2, a2.containsGlobalTarget, e2); ) a2.$_handleGlobalClose(e2, t2), a2 = a2.parentPopper;
        }
      });
    } catch {
    }
  }
}
function rt(e2, t2, n2) {
  return n2.closeAllPopover || n2.closePopover && t2 || it(e2, n2) && !t2;
}
function it(e2, t2) {
  if (typeof e2.autoHide == `function`) {
    let n2 = e2.autoHide(t2);
    return e2.lastAutoHide = n2, n2;
  }
  return e2.autoHide;
}
function at() {
  for (let e2 = 0; e2 < B.length; e2++) B[e2].$_computePosition();
}
let U = 0, W = 0, G = 0, K = 0;
typeof window < `u` && window.addEventListener(`mousemove`, (e2) => {
  U = G, W = K, G = e2.clientX, K = e2.clientY;
}, R ? { passive: true } : void 0);
function q(e2, t2, n2, r2, i2, a2, o2, s2) {
  let c2 = ((o2 - i2) * (t2 - a2) - (s2 - a2) * (e2 - i2)) / ((s2 - a2) * (n2 - e2) - (o2 - i2) * (r2 - t2)), l2 = ((n2 - e2) * (t2 - a2) - (r2 - t2) * (e2 - i2)) / ((s2 - a2) * (n2 - e2) - (o2 - i2) * (r2 - t2));
  return c2 >= 0 && c2 <= 1 && l2 >= 0 && l2 <= 1;
}
const ot = { extends: $e() }, J = (e2, t2) => {
  let n2 = e2.__vccOpts || e2;
  for (let [e3, r2] of t2) n2[e3] = r2;
  return n2;
};
function st(e2, t2, n2, r2, a2, o2) {
  return h(), i(`div`, { ref: `reference`, class: f([`v-popper`, { "v-popper--shown": e2.slotData.isShown }]) }, [_(e2.$slots, `default`, p(s(e2.slotData)))], 2);
}
const ct = J(ot, [[`render`, st]]);
function lt() {
  var e2 = window.navigator.userAgent, t2 = e2.indexOf(`MSIE `);
  if (t2 > 0) return parseInt(e2.substring(t2 + 5, e2.indexOf(`.`, t2)), 10);
  var n2 = e2.indexOf(`Trident/`);
  if (n2 > 0) {
    var r2 = e2.indexOf(`rv:`);
    return parseInt(e2.substring(r2 + 3, e2.indexOf(`.`, r2)), 10);
  }
  var i2 = e2.indexOf(`Edge/`);
  return i2 > 0 ? parseInt(e2.substring(i2 + 5, e2.indexOf(`.`, i2)), 10) : -1;
}
let Y;
function ut() {
  ut.init || (ut.init = true, Y = lt() !== -1);
}
var X = { name: `ResizeObserver`, props: { emitOnMount: { type: Boolean, default: false }, ignoreWidth: { type: Boolean, default: false }, ignoreHeight: { type: Boolean, default: false } }, emits: [`notify`], mounted() {
  ut(), d(() => {
    this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitOnMount && this.emitSize();
  });
  let e2 = document.createElement(`object`);
  this._resizeObject = e2, e2.setAttribute(`aria-hidden`, `true`), e2.setAttribute(`tabindex`, -1), e2.onload = this.addResizeHandlers, e2.type = `text/html`, Y && this.$el.appendChild(e2), e2.data = `about:blank`, Y || this.$el.appendChild(e2);
}, beforeUnmount() {
  this.removeResizeHandlers();
}, methods: { compareAndNotify() {
  (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) && (this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitSize());
}, emitSize() {
  this.$emit(`notify`, { width: this._w, height: this._h });
}, addResizeHandlers() {
  this._resizeObject.contentDocument.defaultView.addEventListener(`resize`, this.compareAndNotify), this.compareAndNotify();
}, removeResizeHandlers() {
  this._resizeObject && this._resizeObject.onload && (!Y && this._resizeObject.contentDocument && this._resizeObject.contentDocument.defaultView.removeEventListener(`resize`, this.compareAndNotify), this.$el.removeChild(this._resizeObject), this._resizeObject.onload = null, this._resizeObject = null);
} } };
const dt = ae(`data-v-b329ee4c`);
te(`data-v-b329ee4c`);
const ft = { class: `resize-observer`, tabindex: `-1` };
ee();
const pt = dt((e2, t2, r2, i2, a2, o2) => (h(), n(`div`, ft)));
X.render = pt, X.__scopeId = `data-v-b329ee4c`, X.__file = `src/components/ResizeObserver.vue`;
const mt = (e2 = `theme`) => ({ computed: { themeClass() {
  return He(this[e2]);
} } }), ht = o({ name: `VPopperContent`, components: { ResizeObserver: X }, mixins: [mt()], props: { popperId: String, theme: String, shown: Boolean, mounted: Boolean, skipTransition: Boolean, autoHide: Boolean, handleResize: Boolean, classes: Object, result: Object }, emits: [`hide`, `resize`], methods: { toPx(e2) {
  return e2 != null && !isNaN(e2) ? `${e2}px` : null;
} } }), gt = [`id`, `aria-hidden`, `tabindex`, `data-popper-placement`], _t = { ref: `inner`, class: `v-popper__inner` }, vt = t(`div`, { class: `v-popper__arrow-outer` }, null, -1), yt = t(`div`, { class: `v-popper__arrow-inner` }, null, -1), bt = [vt, yt];
function xt(a2, o2, s2, c2, l2, u2) {
  let d2 = v(`ResizeObserver`);
  return h(), i(`div`, { id: a2.popperId, ref: `popover`, class: f([`v-popper__popper`, [a2.themeClass, a2.classes.popperClass, { "v-popper__popper--shown": a2.shown, "v-popper__popper--hidden": !a2.shown, "v-popper__popper--show-from": a2.classes.showFrom, "v-popper__popper--show-to": a2.classes.showTo, "v-popper__popper--hide-from": a2.classes.hideFrom, "v-popper__popper--hide-to": a2.classes.hideTo, "v-popper__popper--skip-transition": a2.skipTransition, "v-popper__popper--arrow-overflow": a2.result && a2.result.arrow.overflow, "v-popper__popper--no-positioning": !a2.result }]]), style: m(a2.result ? { position: a2.result.strategy, transform: `translate3d(${Math.round(a2.result.x)}px,${Math.round(a2.result.y)}px,0)` } : void 0), "aria-hidden": a2.shown ? `false` : `true`, tabindex: a2.autoHide ? 0 : void 0, "data-popper-placement": a2.result ? a2.result.placement : void 0, onKeyup: o2[2] || (o2[2] = se((e2) => a2.autoHide && a2.$emit(`hide`), [`esc`])) }, [t(`div`, { class: `v-popper__backdrop`, onClick: o2[0] || (o2[0] = (e2) => a2.autoHide && a2.$emit(`hide`)) }), t(`div`, { class: `v-popper__wrapper`, style: m(a2.result ? { transformOrigin: a2.result.transformOrigin } : void 0) }, [t(`div`, _t, [a2.mounted ? (h(), i(e, { key: 0 }, [t(`div`, null, [_(a2.$slots, `default`)]), a2.handleResize ? (h(), n(d2, { key: 0, onNotify: o2[1] || (o2[1] = (e2) => a2.$emit(`resize`, e2)) })) : r(``, true)], 64)) : r(``, true)], 512), t(`div`, { ref: `arrow`, class: `v-popper__arrow-container`, style: m(a2.result ? { left: a2.toPx(a2.result.arrow.x), top: a2.toPx(a2.result.arrow.y) } : void 0) }, bt, 4)], 4)], 46, gt);
}
const St = J(ht, [[`render`, xt]]), Ct = { methods: { show(...e2) {
  return this.$refs.popper.show(...e2);
}, hide(...e2) {
  return this.$refs.popper.hide(...e2);
}, dispose(...e2) {
  return this.$refs.popper.dispose(...e2);
}, onResize(...e2) {
  return this.$refs.popper.onResize(...e2);
} } };
let wt = function() {
};
typeof window < `u` && (wt = window.Element);
const Tt = o({ name: `VPopperWrapper`, components: { Popper: ct, PopperContent: St }, mixins: [Ct, mt(`finalTheme`)], props: { theme: { type: String, default: null }, referenceNode: { type: Function, default: null }, shown: { type: Boolean, default: false }, showGroup: { type: String, default: null }, ariaId: { default: null }, disabled: { type: Boolean, default: void 0 }, positioningDisabled: { type: Boolean, default: void 0 }, placement: { type: String, default: void 0 }, delay: { type: [String, Number, Object], default: void 0 }, distance: { type: [Number, String], default: void 0 }, skidding: { type: [Number, String], default: void 0 }, triggers: { type: Array, default: void 0 }, showTriggers: { type: [Array, Function], default: void 0 }, hideTriggers: { type: [Array, Function], default: void 0 }, popperTriggers: { type: Array, default: void 0 }, popperShowTriggers: { type: [Array, Function], default: void 0 }, popperHideTriggers: { type: [Array, Function], default: void 0 }, container: { type: [String, Object, wt, Boolean], default: void 0 }, boundary: { type: [String, wt], default: void 0 }, strategy: { type: String, default: void 0 }, autoHide: { type: [Boolean, Function], default: void 0 }, handleResize: { type: Boolean, default: void 0 }, instantMove: { type: Boolean, default: void 0 }, eagerMount: { type: Boolean, default: void 0 }, popperClass: { type: [String, Array, Object], default: void 0 }, computeTransformOrigin: { type: Boolean, default: void 0 }, autoMinSize: { type: Boolean, default: void 0 }, autoSize: { type: [Boolean, String], default: void 0 }, autoMaxSize: { type: Boolean, default: void 0 }, autoBoundaryMaxSize: { type: Boolean, default: void 0 }, preventOverflow: { type: Boolean, default: void 0 }, overflowPadding: { type: [Number, String], default: void 0 }, arrowPadding: { type: [Number, String], default: void 0 }, arrowOverflow: { type: Boolean, default: void 0 }, flip: { type: Boolean, default: void 0 }, shift: { type: Boolean, default: void 0 }, shiftCrossAxis: { type: Boolean, default: void 0 }, noAutoFocus: { type: Boolean, default: void 0 }, disposeTimeout: { type: Number, default: void 0 } }, emits: { show: () => true, hide: () => true, "update:shown": (e2) => true, "apply-show": () => true, "apply-hide": () => true, "close-group": () => true, "close-directive": () => true, "auto-hide": () => true, resize: () => true }, computed: { finalTheme() {
  return this.theme ?? this.$options.vPopperTheme;
} }, methods: { getTargetNodes() {
  return Array.from(this.$el.children).filter((e2) => e2 !== this.$refs.popperContent.$el);
} } });
function Et(e2, t2, r2, i2, o2, s2) {
  let c2 = v(`PopperContent`), l2 = v(`Popper`);
  return h(), n(l2, u({ ref: `popper` }, e2.$props, { theme: e2.finalTheme, "target-nodes": e2.getTargetNodes, "popper-node": () => e2.$refs.popperContent.$el, class: [e2.themeClass], onShow: t2[0] || (t2[0] = () => e2.$emit(`show`)), onHide: t2[1] || (t2[1] = () => e2.$emit(`hide`)), "onUpdate:shown": t2[2] || (t2[2] = (t3) => e2.$emit(`update:shown`, t3)), onApplyShow: t2[3] || (t2[3] = () => e2.$emit(`apply-show`)), onApplyHide: t2[4] || (t2[4] = () => e2.$emit(`apply-hide`)), onCloseGroup: t2[5] || (t2[5] = () => e2.$emit(`close-group`)), onCloseDirective: t2[6] || (t2[6] = () => e2.$emit(`close-directive`)), onAutoHide: t2[7] || (t2[7] = () => e2.$emit(`auto-hide`)), onResize: t2[8] || (t2[8] = () => e2.$emit(`resize`)) }), { default: y(({ popperId: t3, isShown: n2, shouldMountContent: r3, skipTransition: i3, autoHide: o3, show: s3, hide: l3, handleResize: u2, onResize: d2, classes: f2, result: p2 }) => [_(e2.$slots, `default`, { shown: n2, show: s3, hide: l3 }), a(c2, { ref: `popperContent`, "popper-id": t3, theme: e2.finalTheme, shown: n2, mounted: r3, "skip-transition": i3, "auto-hide": o3, "handle-resize": u2, classes: f2, result: p2, onHide: l3, onResize: d2 }, { default: y(() => [_(e2.$slots, `popper`, { shown: n2, hide: l3 })]), _: 2 }, 1032, [`popper-id`, `theme`, `shown`, `mounted`, `skip-transition`, `auto-hide`, `handle-resize`, `classes`, `result`, `onHide`, `onResize`])]), _: 3 }, 16, [`theme`, `target-nodes`, `popper-node`, `class`]);
}
const Z = J(Tt, [[`render`, Et]]), Dt = { ...Z, name: `VDropdown`, vPopperTheme: `dropdown` }, Ot = { ...Z, name: `VMenu`, vPopperTheme: `menu` }, kt = { ...Z, name: `VTooltip`, vPopperTheme: `tooltip` }, At = o({ name: `VTooltipDirective`, components: { Popper: $e(), PopperContent: St }, mixins: [Ct], inheritAttrs: false, props: { theme: { type: String, default: `tooltip` }, html: { type: Boolean, default: (e2) => L(e2.theme, `html`) }, content: { type: [String, Number, Function], default: null }, loadingContent: { type: String, default: (e2) => L(e2.theme, `loadingContent`) }, targetNodes: { type: Function, required: true } }, data() {
  return { asyncContent: null };
}, computed: { isContentAsync() {
  return typeof this.content == `function`;
}, loading() {
  return this.isContentAsync && this.asyncContent == null;
}, finalContent() {
  return this.isContentAsync ? this.loading ? this.loadingContent : this.asyncContent : this.content;
} }, watch: { content: { handler() {
  this.fetchContent(true);
}, immediate: true }, async finalContent() {
  await this.$nextTick(), this.$refs.popper.onResize();
} }, created() {
  this.$_fetchId = 0;
}, methods: { fetchContent(e2) {
  if (typeof this.content == `function` && this.$_isShown && (e2 || !this.$_loading && this.asyncContent == null)) {
    this.asyncContent = null, this.$_loading = true;
    let e3 = ++this.$_fetchId, t2 = this.content(this);
    t2.then ? t2.then((t3) => this.onResult(e3, t3)) : this.onResult(e3, t2);
  }
}, onResult(e2, t2) {
  e2 === this.$_fetchId && (this.$_loading = false, this.asyncContent = t2);
}, onShow() {
  this.$_isShown = true, this.fetchContent();
}, onHide() {
  this.$_isShown = false;
} } }), jt = [`innerHTML`], Mt = [`textContent`];
function Nt(e2, t2, r2, o2, s2, c2) {
  let l2 = v(`PopperContent`), d2 = v(`Popper`);
  return h(), n(d2, u({ ref: `popper` }, e2.$attrs, { theme: e2.theme, "target-nodes": e2.targetNodes, "popper-node": () => e2.$refs.popperContent.$el, onApplyShow: e2.onShow, onApplyHide: e2.onHide }), { default: y(({ popperId: t3, isShown: n2, shouldMountContent: r3, skipTransition: o3, autoHide: s3, hide: c3, handleResize: u2, onResize: d3, classes: p2, result: m2 }) => [a(l2, { ref: `popperContent`, class: f({ "v-popper--tooltip-loading": e2.loading }), "popper-id": t3, theme: e2.theme, shown: n2, mounted: r3, "skip-transition": o3, "auto-hide": s3, "handle-resize": u2, classes: p2, result: m2, onHide: c3, onResize: d3 }, { default: y(() => [e2.html ? (h(), i(`div`, { key: 0, innerHTML: e2.finalContent }, null, 8, jt)) : (h(), i(`div`, { key: 1, textContent: ne(e2.finalContent) }, null, 8, Mt))]), _: 2 }, 1032, [`class`, `popper-id`, `theme`, `shown`, `mounted`, `skip-transition`, `auto-hide`, `handle-resize`, `classes`, `result`, `onHide`, `onResize`])]), _: 1 }, 16, [`theme`, `target-nodes`, `popper-node`, `onApplyShow`, `onApplyHide`]);
}
const Pt = J(At, [[`render`, Nt]]), Ft = `v-popper--has-tooltip`;
function It(e2, t2) {
  let n2 = e2.placement;
  if (!n2 && t2) for (let e3 of Ge) t2[e3] && (n2 = e3);
  return n2 || (n2 = L(e2.theme || `tooltip`, `placement`)), n2;
}
function Lt(e2, t2, n2) {
  let r2, i2 = typeof t2;
  return r2 = i2 === `string` ? { content: t2 } : t2 && i2 === `object` ? t2 : { content: false }, r2.placement = It(r2, n2), r2.targetNodes = () => [e2], r2.referenceNode = () => e2, r2;
}
let Rt, Q, zt = 0;
function Bt() {
  if (Rt) return;
  Q = g([]), Rt = oe({ name: `VTooltipDirectiveApp`, setup() {
    return { directives: Q };
  }, render() {
    return this.directives.map((e3) => c(Pt, { ...e3.options, shown: e3.shown || e3.options.shown, key: e3.id }));
  }, devtools: { hide: true } });
  let e2 = document.createElement(`div`);
  document.body.appendChild(e2), Rt.mount(e2);
}
function Vt(e2, t2, n2) {
  Bt();
  let r2 = g(Lt(e2, t2, n2)), i2 = g(false), a2 = { id: zt++, options: r2, shown: i2 };
  return Q.value.push(a2), e2.classList && e2.classList.add(Ft), e2.$_popper = { options: r2, item: a2, show() {
    i2.value = true;
  }, hide() {
    i2.value = false;
  } };
}
function Ht(e2) {
  if (e2.$_popper) {
    let t2 = Q.value.indexOf(e2.$_popper.item);
    t2 !== -1 && Q.value.splice(t2, 1), delete e2.$_popper, delete e2.$_popperOldShown, delete e2.$_popperMountTarget;
  }
  e2.classList && e2.classList.remove(Ft);
}
function Ut(e2, { value: t2, modifiers: n2 }) {
  let r2 = Lt(e2, t2, n2);
  if (!r2.content || L(r2.theme || `tooltip`, `disabled`)) Ht(e2);
  else {
    let i2;
    e2.$_popper ? (i2 = e2.$_popper, i2.options.value = r2) : i2 = Vt(e2, t2, n2), typeof t2.shown < `u` && t2.shown !== e2.$_popperOldShown && (e2.$_popperOldShown = t2.shown, t2.shown ? i2.show() : i2.hide());
  }
}
const Wt = { beforeMount: Ut, updated: Ut, beforeUnmount(e2) {
  Ht(e2);
} };
function Gt(e2) {
  e2.addEventListener(`mousedown`, $), e2.addEventListener(`click`, $), e2.addEventListener(`touchstart`, qt, R ? { passive: true } : false);
}
function Kt(e2) {
  e2.removeEventListener(`mousedown`, $), e2.removeEventListener(`click`, $), e2.removeEventListener(`touchstart`, qt), e2.removeEventListener(`touchend`, Jt), e2.removeEventListener(`touchcancel`, Yt);
}
function $(e2) {
  let t2 = e2.currentTarget;
  e2.closePopover = !t2.$_vclosepopover_touch, e2.closeAllPopover = t2.$_closePopoverModifiers && !!t2.$_closePopoverModifiers.all;
}
function qt(e2) {
  if (e2.changedTouches.length === 1) {
    let t2 = e2.currentTarget;
    t2.$_vclosepopover_touch = true;
    let n2 = e2.changedTouches[0];
    t2.$_vclosepopover_touchPoint = n2, t2.addEventListener(`touchend`, Jt), t2.addEventListener(`touchcancel`, Yt);
  }
}
function Jt(e2) {
  let t2 = e2.currentTarget;
  if (t2.$_vclosepopover_touch = false, e2.changedTouches.length === 1) {
    let n2 = e2.changedTouches[0], r2 = t2.$_vclosepopover_touchPoint;
    e2.closePopover = Math.abs(n2.screenY - r2.screenY) < 20 && Math.abs(n2.screenX - r2.screenX) < 20, e2.closeAllPopover = t2.$_closePopoverModifiers && !!t2.$_closePopoverModifiers.all;
  }
}
function Yt(e2) {
  let t2 = e2.currentTarget;
  t2.$_vclosepopover_touch = false;
}
const Xt = { beforeMount(e2, { value: t2, modifiers: n2 }) {
  e2.$_closePopoverModifiers = n2, (typeof t2 > `u` || t2) && Gt(e2);
}, updated(e2, { value: t2, oldValue: n2, modifiers: r2 }) {
  e2.$_closePopoverModifiers = r2, t2 !== n2 && (typeof t2 > `u` || t2 ? Gt(e2) : Kt(e2));
}, beforeUnmount(e2) {
  Kt(e2);
} }, Zt = I, Qt = Wt, $t = Wt, en = Xt, tn = Xt, nn = Dt, rn = Ot, an = $e, on = St, sn = Ct, cn = Z, ln = mt, un = kt, dn = Pt;
function fn(e2, t2 = {}) {
  e2.$_vTooltipInstalled || (e2.$_vTooltipInstalled = true, Ve(I, t2), e2.directive(`tooltip`, Wt), e2.directive(`close-popper`, Xt), e2.component(`VTooltip`, kt), e2.component(`VDropdown`, Dt), e2.component(`VMenu`, Ot));
}
const pn = { version: `5.2.2`, install: fn, options: I }, mn = { viewBox: `0 0 384 512`, width: `0.75em`, height: `1em` };
function hn(e2, n2) {
  return h(), i(`svg`, mn, n2[0] || (n2[0] = [t(`path`, { fill: `currentColor`, d: `M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7L86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256L41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3l105.4 105.3c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256z` }, null, -1)]));
}
var gn = l({ name: `fa6-solid-xmark`, render: hn }), _n = `data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='iso-8859-1'?%3e%3c!--%20Generator:%20Adobe%20Illustrator%2019.0.0,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%206.00%20Build%200)%20--%3e%3csvg%20version='1.1'%20id='Capa_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%20512%20512'%20style='enable-background:new%200%200%20512%20512;'%20xml:space='preserve'%3e%3cg%3e%3cpath%20fill='currentColor'%20d='M176,384H16c-8.832,0-16,7.168-16,16c0,8.832,7.168,16,16,16h160c8.832,0,16,7.2,16,16s-7.168,16-16,16%20c-8.832,0-16,7.168-16,16c0,8.832,7.168,16,16,16c26.464,0,48-21.536,48-48S202.464,384,176,384z'%20/%3e%3c/g%3e%3cg%3e%3cpath%20d='M240,256c-8.832,0-16,7.168-16,16c0,8.832,7.168,16,16,16c8.832,0,16,7.2,16,16s-7.168,16-16,16H16%20c-8.832,0-16,7.168-16,16c0,8.832,7.168,16,16,16h224c26.464,0,48-21.536,48-48S266.464,256,240,256z'%20/%3e%3c/g%3e%3cg%3e%3cpath%20d='M288,32C164.288,32,64,132.288,64,256c0,10.88,1.056,21.536,2.56,32h128.192c-1.792-4.992-2.752-10.4-2.752-16%20c0-26.464,21.536-48,48-48c44.096,0,80,35.904,80,80c0,44.128-35.904,80-80,80h-0.416C249.76,397.408,256,413.92,256,432%20c0,16.032-4.864,30.944-13.024,43.456c14.56,2.976,29.6,4.544,45.024,4.544c123.712,0,224-100.288,224-224S411.712,32,288,32z'%20/%3e%3c/g%3e%3c/svg%3e`;
const vn = { viewBox: `0 0 320 512`, width: `0.63em`, height: `1em` };
function yn(e2, n2) {
  return h(), i(`svg`, vn, n2[0] || (n2[0] = [t(`path`, { fill: `currentColor`, d: `M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256L73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z` }, null, -1)]));
}
var bn = l({ name: `fa6-solid-chevron-right`, render: yn });
export {
  pn as Gt,
  xe as R,
  bn as chevron_right_default,
  _n as windpress_default$1,
  gn as xmark_default
};
